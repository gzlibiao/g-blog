import{_ as n,o as e,c as s,a6 as t}from"./chunks/framework.DxlwMnnj.js";const u=JSON.parse('{"title":"nuxtjs","description":"","frontmatter":{"tag":["前端"]},"headers":[],"relativePath":"articles/前端/nuxtjs.md","filePath":"articles/前端/nuxtjs.md"}'),o={name:"articles/前端/nuxtjs.md"};function c(i,a,p,l,r,d){return e(),s("div",{"data-pagefind-body":!0},a[0]||(a[0]=[t(`<h1 id="nuxtjs" tabindex="-1">nuxtjs <a class="header-anchor" href="#nuxtjs" aria-label="Permalink to &quot;nuxtjs&quot;">​</a></h1><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><h2 id="asyncdata-和-fetch" tabindex="-1">asyncData 和 fetch <a class="header-anchor" href="#asyncdata-和-fetch" aria-label="Permalink to &quot;asyncData 和 fetch&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1.两者都是服务端钩子</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2.asyncData只能在page中用 component不支持   fetch page 和 component都可以</span></span>
<span class="line"><span></span></span>
<span class="line"><span>3. asyncData 发生在路由阶段 错误会导致界面跳转失效</span></span>
<span class="line"><span>4. asyncData发生在route阶段 在beforeCreate之前</span></span>
<span class="line"><span>5. 在服务端端执行 fetch在beforeCreate之前</span></span>
<span class="line"><span>5. 在客户端执行 fetch在beforeMount之后</span></span>
<span class="line"><span>6. asyncData 函数参数自带context</span></span>
<span class="line"><span>7. fetch 需要通过this.$nuxt.context获取</span></span>
<span class="line"><span>8. fetch可以操作组件上的data asyncData则会和data进行合并输出</span></span></code></pre></div><h2 id="seo" tabindex="-1">seo <a class="header-anchor" href="#seo" aria-label="Permalink to &quot;seo&quot;">​</a></h2><h2 id="解决-token-丢失并持久化方案" tabindex="-1">解决 token 丢失并持久化方案 <a class="header-anchor" href="#解决-token-丢失并持久化方案" aria-label="Permalink to &quot;解决 token 丢失并持久化方案&quot;">​</a></h2><p>1.下载 yarn add cookie-universal-nuxt -S 2.配置 nuxt.config.js modules:[ &#39;cookie-universal-nuxt&#39; ] 3.操作 this.$cookies.get this.$cookies.set this.$cookies.remove</p><p>1, 刚开始做项目得时候登录后会把 Token 存在客户端的本地存储中用来判断用户是否登录，然后会在全局请求是带上登录后返回来的 token 以及其他的信息，但是在项目中使用 localstroge 会报 window or document 对象未定义，这是因为在服务端是没有 window 或者 document 对象的。</p><p>2, 鉴于上边的问题，但是又要实现这个功能，所以就开始折腾，过程中发现 cookie-universal-nuxt 这个在服务端获取 cookie 的插件。这里把 cookie-universal-nuxt 官网链接放在这里，以供参考，官网的介绍很全面。</p><p>3,（个人见解） 在用完后才领悟到这里是利用了存到 cookie 中的内容是会被携带在请求头中的原理做的，你也可以利用这个原理在你存到 cookie 中后，然后在请求头中取出来，在分别加进去或者在 asyncData 或 fetch 获取 cookie 中的内容，做一些自己的操作</p>`,10)]))}const f=n(o,[["render",c]]);export{u as __pageData,f as default};
