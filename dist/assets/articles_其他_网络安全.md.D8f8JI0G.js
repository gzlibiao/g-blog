import{_ as s,o as i,c as t,a6 as e}from"./chunks/framework.DxlwMnnj.js";const k=JSON.parse('{"title":"网络安全","description":"","frontmatter":{},"headers":[],"relativePath":"articles/其他/网络安全.md","filePath":"articles/其他/网络安全.md"}'),l={name:"articles/其他/网络安全.md"};function r(h,a,n,o,c,p){return i(),t("div",{"data-pagefind-body":!0},a[0]||(a[0]=[e('<h1 id="网络安全" tabindex="-1">网络安全 <a class="header-anchor" href="#网络安全" aria-label="Permalink to &quot;网络安全&quot;">​</a></h1><h3 id="http和‌https的主要区别‌" tabindex="-1">HTTP和‌HTTPS的主要区别‌ <a class="header-anchor" href="#http和‌https的主要区别‌" aria-label="Permalink to &quot;HTTP和‌HTTPS的主要区别‌&quot;">​</a></h3><ol><li>‌安全性‌：HTTP以明文方式传输数据，不提供任何方式的数据加密，存在较大的安全风险；而HTTPS通过‌SSL/TLS协议对数据进行加密，提供数据传输的安全性和完整性。‌12</li><li>‌数据传输方式‌：HTTP使用TCP/IP协议的80端口进行数据传输，而HTTPS使用443端口进行加密传输。‌</li><li>‌证书管理‌：HTTPS需要使用CA（证书颁发机构）颁发的证书进行加密和解密操作，而HTTP则不需要证书。</li><li>连接状态‌：HTTPS连接在数据传输过程中始终保持加密状态，而HTTP连接是无状态的，每个请求都是独立的。</li><li>资源消耗‌：由于HTTPS需要进行加密和解密操作，资源消耗较大，可能会影响网页加载速度；而HTTP的资源消耗较小。</li><li>兼容性‌：HTTPS可能需要配置证书，在某些情况下可能会出现兼容性问题；而HTTP的兼容性较好，可以在各种设备和操作系统上使用。</li></ol><h4 id="‌详细解释http和https的区别‌" tabindex="-1">‌详细解释HTTP和HTTPS的区别‌ <a class="header-anchor" href="#‌详细解释http和https的区别‌" aria-label="Permalink to &quot;‌详细解释HTTP和HTTPS的区别‌&quot;">​</a></h4><p>‌协议基础概念‌：HTTP是一种超文本传输协议，用于在Web浏览器和Web服务器之间传输数据，使用明文传输，不提供数据加密；而HTTPS是HTTP的安全版本，通过SSL/TLS协议对数据进行加密，提供数据传输的安全性和完整性。 ‌安全性差异‌：HTTPS通过SSL/TLS协议对数据进行加密，确保数据在传输过程中的机密性和完整性，防止数据被截获和篡改；而HTTP则没有这样的加密功能，数据在传输过程中可能被截获或篡改。 ‌连接方式与证书管理‌：HTTP使用明文传输，不需要额外的安全验证；而HTTPS需要SSL/TLS的握手过程，客户端和服务器在交换过程中比较复杂，但提高了连接的安全性。</p><h4 id="https的优点和缺点‌" tabindex="-1">HTTPS的优点和缺点‌ <a class="header-anchor" href="#https的优点和缺点‌" aria-label="Permalink to &quot;HTTPS的优点和缺点‌&quot;">​</a></h4><p>‌优点‌：HTTPS提供了高级别的安全性，通过SSL/TLS协议对数据进行加密，防止数据在传输过程中被截获和篡改；此外，HTTPS还通过数字证书进行身份认证，防止中间人攻击等安全风险。 ‌缺点‌：由于需要进行加密和解密操作，HTTPS可能会影响网页的加载速度；此外，部署HTTPS需要购买SSL/TLS证书，增加了网站的运营成本。</p><h3 id="xss-xxe-csrf区别" tabindex="-1">xss xxe csrf区别 <a class="header-anchor" href="#xss-xxe-csrf区别" aria-label="Permalink to &quot;xss xxe csrf区别&quot;">​</a></h3><h4 id="xss-跨站脚本攻击" tabindex="-1">XSS（跨站脚本攻击） <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS（跨站脚本攻击）&quot;">​</a></h4><p>本质，是把用户输入的数据当做代码执行。 第一个是用户能够控制输入 第二个是原本程序要执行的代码，拼接了用户输入的数据</p><h5 id="xss类型" tabindex="-1">xss类型 <a class="header-anchor" href="#xss类型" aria-label="Permalink to &quot;xss类型&quot;">​</a></h5><ol><li><p>反射：通过url传输恶意代码让客户端执行</p></li><li><p>存储：通过后端返回恶意代码执行</p></li></ol><ul><li>例如提交一条评论，上面写入一串会被浏览器解析执行的脚本 其他用户在打开评论看到这条数据就会将这串脚本执行</li></ul><ol start="3"><li>dom：通过修改dom 注入恶意代码</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`&#39; onerror=&#39;alert()&#39;`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=`</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&#39;http://server/api/${content}`/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="预防xss-攻击" tabindex="-1">预防xss 攻击 <a class="header-anchor" href="#预防xss-攻击" aria-label="Permalink to &quot;预防xss 攻击&quot;">​</a></h4><h5 id="对用户输入的数据进行严格验证和过滤-确保只接受有效和预期的数据。可以使用白名单过滤或正则表达式验证来限制输入内容" tabindex="-1">对用户输入的数据进行严格验证和过滤，确保只接受有效和预期的数据。可以使用白名单过滤或正则表达式验证来限制输入内容 <a class="header-anchor" href="#对用户输入的数据进行严格验证和过滤-确保只接受有效和预期的数据。可以使用白名单过滤或正则表达式验证来限制输入内容" aria-label="Permalink to &quot;对用户输入的数据进行严格验证和过滤，确保只接受有效和预期的数据。可以使用白名单过滤或正则表达式验证来限制输入内容&quot;">​</a></h5><h5 id="content-security-policy-内容安全策略" tabindex="-1">Content Security Policy 内容安全策略 <a class="header-anchor" href="#content-security-policy-内容安全策略" aria-label="Permalink to &quot;Content Security Policy 内容安全策略&quot;">​</a></h5><p>nginx配置 Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https: meta标签配置 <meta http-equiv="Content-Security-Policy" content="script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:"></p><h4 id="csrf-跨站请求伪造" tabindex="-1">CSRF（跨站请求伪造） <a class="header-anchor" href="#csrf-跨站请求伪造" aria-label="Permalink to &quot;CSRF（跨站请求伪造）&quot;">​</a></h4><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol><h4 id="预防csrf攻击" tabindex="-1">预防csrf攻击 <a class="header-anchor" href="#预防csrf攻击" aria-label="Permalink to &quot;预防csrf攻击&quot;">​</a></h4><ol><li>referer 请求头中设置源站点服务器地址</li><li>请求头中加入 csrfToken</li></ol><h4 id="xxe-xml-外部实体攻击" tabindex="-1">XXE（XML 外部实体攻击） <a class="header-anchor" href="#xxe-xml-外部实体攻击" aria-label="Permalink to &quot;XXE（XML 外部实体攻击）&quot;">​</a></h4><p>XXE 攻击是指攻击者利用 XML 解析器的特性，通过在 XML 中引用外部实体文件，达到读取敏感数据或执行远程请求的目的。 预防 XXE 攻击的方法包括禁用或限制 XML 实体、过滤用户输入中的 XML 内容等。</p><h4 id="xss-和-csrf区别" tabindex="-1">xss 和 csrf区别 <a class="header-anchor" href="#xss-和-csrf区别" aria-label="Permalink to &quot;xss 和 csrf区别&quot;">​</a></h4><p>1、CSRF是跨站请求伪造; XSS是跨域脚本攻击。 2、CSRF需要用户先登录网站A,获取cookie; XSS不需要登录。 3、CSRF是利用网站A本身的漏洞,去请求网站A的api; XSS是向网站A注入JS代码,然后执行JS里的代码,篡改网站A的内容。（XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。你可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求。）</p>',27)]))}const T=s(l,[["render",r]]);export{k as __pageData,T as default};
