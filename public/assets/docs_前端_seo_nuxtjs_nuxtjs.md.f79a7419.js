import{_ as s,o as n,c as e,a as t}from"./app.d0abd10b.js";const h=JSON.parse('{"title":"nuxtjs","description":"","frontmatter":{},"headers":[{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"asyncData 和 fetch","slug":"asyncdata-和-fetch","link":"#asyncdata-和-fetch","children":[]},{"level":2,"title":"seo","slug":"seo","link":"#seo","children":[]},{"level":2,"title":"解决 token 丢失并持久化方案","slug":"解决-token-丢失并持久化方案","link":"#解决-token-丢失并持久化方案","children":[]}],"relativePath":"docs/前端/seo/nuxtjs/nuxtjs.md"}'),l={name:"docs/前端/seo/nuxtjs/nuxtjs.md"};function o(c,a,r,p,i,d){return n(),e("div",null,a[0]||(a[0]=[t(`<h1 id="nuxtjs" tabindex="-1">nuxtjs <a class="header-anchor" href="#nuxtjs" aria-hidden="true">#</a></h1><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><h2 id="asyncdata-和-fetch" tabindex="-1">asyncData 和 fetch <a class="header-anchor" href="#asyncdata-和-fetch" aria-hidden="true">#</a></h2><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">1.两者都是服务端钩子</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">2.asyncData只能在page中用 component不支持   fetch page 和 component都可以</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">3. asyncData 发生在路由阶段 错误会导致界面跳转失效</span></span>
<span class="line"><span style="color:#A6ACCD;">4. asyncData发生在route阶段 在beforeCreate之前</span></span>
<span class="line"><span style="color:#A6ACCD;">5. 在服务端端执行 fetch在beforeCreate之前</span></span>
<span class="line"><span style="color:#A6ACCD;">5. 在客户端执行 fetch在beforeMount之后</span></span>
<span class="line"><span style="color:#A6ACCD;">6. asyncData 函数参数自带context</span></span>
<span class="line"><span style="color:#A6ACCD;">7. fetch 需要通过this.$nuxt.context获取</span></span>
<span class="line"><span style="color:#A6ACCD;">8. fetch可以操作组件上的data asyncData则会和data进行合并输出</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="seo" tabindex="-1">seo <a class="header-anchor" href="#seo" aria-hidden="true">#</a></h2><h2 id="解决-token-丢失并持久化方案" tabindex="-1">解决 token 丢失并持久化方案 <a class="header-anchor" href="#解决-token-丢失并持久化方案" aria-hidden="true">#</a></h2><p>1.下载 yarn add cookie-universal-nuxt -S 2.配置 nuxt.config.js modules:[ &#39;cookie-universal-nuxt&#39; ] 3.操作 this.$cookies.get this.$cookies.set this.$cookies.remove</p><p>1, 刚开始做项目得时候登录后会把 Token 存在客户端的本地存储中用来判断用户是否登录，然后会在全局请求是带上登录后返回来的 token 以及其他的信息，但是在项目中使用 localstroge 会报 window or document 对象未定义，这是因为在服务端是没有 window 或者 document 对象的。</p><p>2, 鉴于上边的问题，但是又要实现这个功能，所以就开始折腾，过程中发现 cookie-universal-nuxt 这个在服务端获取 cookie 的插件。这里把 cookie-universal-nuxt 官网链接放在这里，以供参考，官网的介绍很全面。</p><p>3,（个人见解） 在用完后才领悟到这里是利用了存到 cookie 中的内容是会被携带在请求头中的原理做的，你也可以利用这个原理在你存到 cookie 中后，然后在请求头中取出来，在分别加进去或者在 asyncData 或 fetch 获取 cookie 中的内容，做一些自己的操作</p>`,10)]))}const b=s(l,[["render",o]]);export{h as __pageData,b as default};
