import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  _typeof
} from "./chunk-E7FFEZEH.js";
import {
  h,
  isVNode,
  toRaw
} from "./chunk-GOZHMCMR.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.js
var require_rbush = __commonJS({
  "node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.js"(exports, module) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = global2 || self, global2.RBush = factory2());
    })(exports, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare2) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare2 || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare2) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s2 = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s2 / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s2 / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare2);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare2(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare2(arr[i], t) < 0) {
              i++;
            }
            while (compare2(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare2(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swap(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var RBush2 = function RBush3(maxEntries) {
        if (maxEntries === void 0)
          maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush2.prototype.all = function all() {
        return this._all(this.data, []);
      };
      RBush2.prototype.search = function search(bbox) {
        var node = this.data;
        var result = [];
        if (!intersects(bbox, node)) {
          return result;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) {
                result.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush2.prototype.load = function load(data2) {
        if (!(data2 && data2.length)) {
          return this;
        }
        if (data2.length < this._minEntries) {
          for (var i = 0; i < data2.length; i++) {
            this.insert(data2[i]);
          }
          return this;
        }
        var node = this._build(data2.slice(), 0, data2.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush2.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush2.prototype.clear = function clear() {
        this.data = createNode([]);
        return this;
      };
      RBush2.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path = [];
        var indexes = [];
        var i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush2.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush2.prototype.compareMinX = function compareMinX(a, b) {
        return a.minX - b.minX;
      };
      RBush2.prototype.compareMinY = function compareMinY(a, b) {
        return a.minY - b.minY;
      };
      RBush2.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush2.prototype.fromJSON = function fromJSON(data2) {
        this.data = data2;
        return this;
      };
      RBush2.prototype._all = function _all(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result.push.apply(result, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype._build = function _build(items, left, right, height) {
        var N = right - left + 1;
        var M = this._maxEntries;
        var node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M);
        var N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (var i = left; i <= right; i += N1) {
          var right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (var j = i; j <= right2; j += N2) {
            var right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      };
      RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush2.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend2(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush2.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M = node.children.length;
        var m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      };
      RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {
        var index;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);
          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      };
      RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m, M, compareMinX);
        var yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush2.prototype._allDistMargin = function _allDistMargin(node, m, M, compare2) {
        node.children.sort(compare2);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m, toBBox);
        var rightBBox = distBBox(node, M - m, M, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend2(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend2(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend2(path[i], bbox);
        }
      };
      RBush2.prototype._condense = function _condense(path) {
        for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox(path[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend2(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend2(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX);
        var minY = Math.max(a.minY, b.minY);
        var maxX = Math.min(a.maxX, b.maxX);
        var maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare2) {
        var stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) {
            continue;
          }
          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare2);
          stack.push(left, mid, mid, right);
        }
      }
      return RBush2;
    });
  }
});

// node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE4(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE4(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length14 = listeners.length, j;
        for (i = 0; i < length14; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length14 = listeners.length; i < length14; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad2) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s2 = Math.sin(rad2), c = Math.cos(rad2);
  out[0] = c * a00 + s2 * a10;
  out[1] = c * a01 + s2 * a11;
  out[2] = c * a02 + s2 * a12;
  out[3] = c * a10 - s2 * a00;
  out[4] = c * a11 - s2 * a01;
  out[5] = c * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad2) {
  var s2 = Math.sin(rad2), c = Math.cos(rad2);
  out[0] = c;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad2, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s2, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c = Math.cos(rad2);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s2;
  b02 = z * x * t - y * s2;
  b10 = x * y * t - z * s2;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s2;
  b20 = x * z * t + y * s2;
  b21 = y * z * t - x * s2;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s2;
  out[5] = a11 * c + a21 * s2;
  out[6] = a12 * c + a22 * s2;
  out[7] = a13 * c + a23 * s2;
  out[8] = a20 * c - a10 * s2;
  out[9] = a21 * c - a11 * s2;
  out[10] = a22 * c - a12 * s2;
  out[11] = a23 * c - a13 * s2;
  return out;
}
function rotateY(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s2;
  out[1] = a01 * c - a21 * s2;
  out[2] = a02 * c - a22 * s2;
  out[3] = a03 * c - a23 * s2;
  out[8] = a00 * s2 + a20 * c;
  out[9] = a01 * s2 + a21 * c;
  out[10] = a02 * s2 + a22 * c;
  out[11] = a03 * s2 + a23 * c;
  return out;
}
function rotateZ(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s2;
  out[1] = a01 * c + a11 * s2;
  out[2] = a02 * c + a12 * s2;
  out[3] = a03 * c + a13 * s2;
  out[4] = a10 * c - a00 * s2;
  out[5] = a11 * c - a01 * s2;
  out[6] = a12 * c - a02 * s2;
  out[7] = a13 * c - a03 * s2;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad2, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s2, c, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c = Math.cos(rad2);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s2;
  out[2] = z * x * t - y * s2;
  out[3] = 0;
  out[4] = x * y * t - z * s2;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s2;
  out[7] = 0;
  out[8] = x * z * t + y * s2;
  out[9] = y * z * t - x * s2;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = c;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = c;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s2) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s2, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.hypot(x0, x1, x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.hypot(y0, y1, y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  out[9] = a[9] + b[9] * scale8;
  out[10] = a[10] + b[10] * scale8;
  out[11] = a[11] + b[11] * scale8;
  out[12] = a[12] + b[12] * scale8;
  out[13] = a[13] + b[13] * scale8;
  out[14] = a[14] + b[14] * scale8;
  out[15] = a[15] + b[15] * scale8;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len5 = x * x + y * y + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  out[2] = a[2] * len5;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d4, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d4[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d4[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d4[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d4, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d4[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d4[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d4[2] * factor4;
  return out;
}
function random(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad2) - p[2] * Math.sin(rad2);
  r[2] = p[1] * Math.sin(rad2) + p[2] * Math.cos(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad2) + p[0] * Math.cos(rad2);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad2) - p[0] * Math.sin(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad2) - p[1] * Math.sin(rad2);
  r[1] = p[0] * Math.sin(rad2) + p[1] * Math.cos(rad2);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len5 = x * x + y * y + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x * len5;
  out[1] = y * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A4 = v[0] * w[1] - v[1] * w[0], B4 = v[0] * w[2] - v[2] * w[0], C4 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C4 - J * B4;
  out[2] = G * E2 - H * C4 + J * A4;
  out[3] = -(G * D2) + H * B4 - I * A4;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale8) {
  scale8 = scale8 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d4 = Math.sqrt((1 - s1) / s2);
  out[0] = scale8 * v1;
  out[1] = scale8 * v2;
  out[2] = scale8 * v3 * d4;
  out[3] = scale8 * v4 * d4;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s2 = Math.sin(rad2);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad2);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad2 = Math.acos(q[3]) * 2;
  var s2 = Math.sin(rad2 / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q[0] / s2;
    out_axis[1] = q[1] / s2;
    out_axis[2] = q[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad2;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s2 = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s2;
  out[1] = y * s2;
  out[2] = z * s2;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot6 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot6 ? 1 / dot6 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot6 = dot(a, b);
    if (dot6 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot6 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot6;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d4, t) {
    slerp(temp1, a, d4, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone6,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues6(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set6(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len5 = x * x + y * y;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale8;
  out[1] = Math.sin(r) * scale8;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad2) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals6(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path) {
  return path.map(function(x) {
    return Array.isArray(x) ? [].concat(x) : x;
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi = pathArray[i];
    var ni = i;
    while (pi.length) {
      allPathCommands[i] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a) {
    var x = _a[0];
    return x === x.toUpperCase();
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a) {
    var pc = _a[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path) {
  var index = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "' + pathValue[index] + '", expecting 0 or 1 at index ' + index;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path) {
  var max4 = path.max, pathValue = path.pathValue, start = path.index;
  var index = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index >= max4) {
    path.err = "[path-util]: Invalid path value at index " + index + ', "pathValue" is missing param';
    return;
  }
  ch = pathValue.charCodeAt(index);
  if (ch === 43 || ch === 45) {
    index += 1;
    ch = pathValue.charCodeAt(index);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" is not a number';
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (zeroFirst && index < max4) {
      if (ch && isDigit(ch)) {
        path.err = "[path-util]: Invalid path value at index " + start + ', "' + pathValue[start] + '" illegal number';
        return;
      }
    }
    while (index < max4 && isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 46) {
    hasDot = true;
    index += 1;
    while (isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" invalid float exponent';
      return;
    }
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (ch === 43 || ch === 45) {
      index += 1;
    }
    if (index < max4 && isDigit(pathValue.charCodeAt(index))) {
      while (index < max4 && isDigit(pathValue.charCodeAt(index))) {
        index += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" invalid integer exponent';
      return;
    }
  }
  path.index = index;
  path.param = +path.pathValue.slice(start, index);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path) {
  var pathValue = path.pathValue, max4 = path.max;
  while (path.index < max4 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path) {
  var max4 = path.max, pathValue = path.pathValue, index = path.index;
  var cmdCode = pathValue.charCodeAt(index);
  var reqParams = paramsCount[pathValue[index].toLowerCase()];
  path.segmentStart = index;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "' + pathValue[index] + '" is not a path command';
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max4 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = parsePathString(pathInput);
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x = values[0], y = values[1];
      mx = x;
      my = y;
      return ["M", x, y];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5] + x,
            values[6] + y
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values[0] + y];
          break;
        case "H":
          absoluteSegment = [absCommand, values[0] + x];
          break;
        default: {
          var absValues = values.map(function(n, j) {
            return n + (j % 2 ? y : x);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x = mx;
        y = my;
        break;
      case "H":
        x = absoluteSegment[1];
        break;
      case "V":
        y = absoluteSegment[1];
        break;
      default:
        x = absoluteSegment[segLength - 2];
        y = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x;
          my = y;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values);
  } else if (pathCommand === "Q") {
    var nqx = values[0], nqy = values[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i = 0; i < path.length; i += 1) {
    path[i] = normalizeSegment(path[i], params);
    var segment = path[i];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a) {
    var pc = _a[0];
    return "MC".includes(pc);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x, y, rad2) {
  var X = x * Math.cos(rad2) - y * Math.sin(rad2);
  var Y = x * Math.sin(rad2) + y * Math.cos(rad2);
  return { x: X, y: Y };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x2 = X2;
  var y2 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad2 = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad2);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x2, y2, -rad2);
    x2 = xy.x;
    y2 = xy.y;
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h2 = x * x / (rx * rx) + y * y / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y2 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = arcToCubic(x2, y2, rx, ry, angle3, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return m2.concat(m3, m4, res);
  }
  res = m2.concat(m3, m4, res);
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad2).y : rotateVector(res[i], res[i + 1], rad2).x;
  }
  return newres;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x1, y1, qx, qy, x2, y2) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    r13 * y1 + r23 * qy,
    r13 * x2 + r23 * qx,
    r13 * y2 + r23 * qy,
    x2,
    y2
    // x,y
  ];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a, b) {
  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x1, y1, x2, y2, distance6) {
  var length14 = distanceSquareRoot([x1, y1], [x2, y2]);
  var point = { x: 0, y: 0 };
  if (typeof distance6 === "number") {
    if (distance6 <= 0) {
      point = { x: x1, y: y1 };
    } else if (distance6 >= length14) {
      point = { x: x2, y: y2 };
    } else {
      var _a = midPoint([x1, y1], [x2, y2], distance6 / length14), x = _a[0], y = _a[1];
      point = { x, y };
    }
  }
  return {
    length: length14,
    point,
    min: {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2)
    },
    max: {
      x: Math.max(x1, x2),
      y: Math.max(y1, y2)
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/line-2-cubic.js
function lineToCubic(x1, y1, x2, y2) {
  var t = 0.5;
  var p0 = [x1, y1];
  var p1 = [x2, y2];
  var p2 = midPoint(p0, p1, t);
  var p3 = midPoint(p1, p2, t);
  var p4 = midPoint(p2, p3, t);
  var p5 = midPoint(p3, p4, t);
  var p6 = midPoint(p4, p5, t);
  var cp1 = segmentLineFactory(p0[0], p0[1], p2[0], p2[1], p4[0]).point;
  var cp2 = segmentLineFactory(p6[0], p6[1], p5[0], p5[1], p3[0]).point;
  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values = segment.slice(1).map(Number);
  var x = values[0], y = values[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x;
      params.y = y;
      return segment;
    case "A":
      args = [px1, py1].concat(values);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x;
      params.qy = y;
      args = [px1, py1].concat(values);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x, y));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
    default:
  }
  return segment;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = clonePath(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (path[i])
      pathCommand = path[i][0];
    allPathCommands[i] = pathCommand;
    var curveSegment = segmentToCubic(path[i], params);
    path[i] = curveSegment;
    fixArc(path, allPathCommands, i);
    ii = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i);
    }
    segment = path[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x, i, curveOnly) {
    return !i ? pathArray[0].slice(1).concat(x.slice(1)) : curveOnly[i - 1].slice(-2).concat(x.slice(1));
  }).map(function(x) {
    return x.map(function(y, i) {
      return x[x.length - i - 2 * (1 - i % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x) {
    return ["C"].concat(x.slice(2));
  }));
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p = v0x * v1x + v0y * v1y;
  var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle3, LAF, SF, x, y, t) {
  var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, PI3 = Math.PI;
  var rx = abs(RX);
  var ry = abs(RY);
  var xRot = (angle3 % 360 + 360) % 360;
  var xRotRad = xRot * (PI3 / 180);
  if (x1 === x && y1 === y) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x, y, t).point;
  }
  var dx = (x1 - x) / 2;
  var dy = (y1 - y) / 2;
  var transformedPoint = {
    x: cos(xRotRad) * dx + sin(xRotRad) * dy,
    y: -sin(xRotRad) * dx + cos(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,
    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI3;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI3;
  }
  sweepAngle %= 2 * PI3;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos(alpha);
  var ellipseComponentY = ry * sin(alpha);
  var point = {
    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
  };
  return point;
}
function segmentArcFactory(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = X1;
  var y = Y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 3) * x1 + 3 * Math.pow(t12, 2) * t * c1x + 3 * t12 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x2,
    y: Math.pow(t12, 3) * y1 + 3 * Math.pow(t12, 2) * t * c1y + 3 * t12 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y2
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = x1;
  var y = y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 2) * x1 + 2 * t12 * t * cx + Math.pow(t, 2) * x2,
    y: Math.pow(t12, 2) * y1 + 2 * t12 * t * cy + Math.pow(t, 2) * y2
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = x1;
  var y = y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance6, options) {
  var _a, _b, _c, _d, _e, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance6 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length14 = 0;
  var min4 = { x: 0, y: 0 };
  var max4 = min4;
  var point = min4;
  var POINT = min4;
  var LENGTH = 0;
  for (var i = 0, ll = path.length; i < ll; i += 1) {
    seg = path[i];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x, y].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min4 = { x: mx, y: my };
      max4 = min4;
      length14 = 0;
      if (distanceIsNumber && distance6 < 1e-3) {
        POINT = min4;
      }
    } else if (pathCommand === "L") {
      _a = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length14 = _a.length, min4 = _a.min, max4 = _a.max, point = _a.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance6 || 0) - LENGTH, options || {}), length14 = _b.length, min4 = _b.min, max4 = _b.max, point = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance6 || 0) - LENGTH, options || {}), length14 = _c.length, min4 = _c.min, max4 = _c.max, point = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance6 || 0) - LENGTH, options || {}), length14 = _d.length, min4 = _d.min, max4 = _d.max, point = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x, y, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length14 = _e.length, min4 = _e.min, max4 = _e.max, point = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance6 && LENGTH + length14 >= distance6) {
      POINT = point;
    }
    MAX.push(max4);
    MIN.push(min4);
    LENGTH += length14;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x = _f[0], y = _f[1];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x, y };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a) {
  var segCount = a.length;
  var pointCount = segCount - 1;
  return a.map(function(f, idx) {
    return a.map(function(p, i) {
      var oldSegIdx = idx + i;
      var seg;
      if (i === 0 || a[oldSegIdx] && a[oldSegIdx][0] === "M") {
        seg = a[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a[oldSegIdx];
    });
  });
}
function getRotatedCurve(a, b) {
  var segCount = a.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a);
  rotations.forEach(function(r, i) {
    a.slice(1).forEach(function(s2, j) {
      sumLensSqrd += distanceSquareRoot(a[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x2, y2) {
  return 3 * ((y2 - y1) * (c1x + c2x) - (x2 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y2 * (c2x + x1 / 3) - x2 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x = 0;
  var y = 0;
  var len5 = 0;
  return path2Curve(path).map(function(seg) {
    var _a;
    switch (seg[0]) {
      case "M":
        x = seg[1], y = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x2 = _b[4], y2 = _b[5];
        len5 = getCubicSegArea(x, y, c1x, c1y, c2x, c2y, x2, y2);
        _a = seg.slice(-2), x = _a[0], y = _a[1];
        return len5;
    }
  }).reduce(function(a, b) {
    return a + b;
  }, 0);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance6, options) {
  return pathLengthFactory(pathInput, distance6, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i, pathArray) {
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c2 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c2.length;
  var l1 = c1.filter(function(x) {
    return x.l;
  }).length;
  var l2 = c2.filter(function(x) {
    return x.l;
  }).length;
  var m1 = c1.filter(function(x) {
    return x.l;
  }).reduce(function(a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l1 || 0;
  var m2 = c2.filter(function(x) {
    return x.l;
  }).reduce(function(a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m2];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c2].map(function(x, i) {
    return x.l === tl ? x.map(function(y) {
      return y.s;
    }) : x.map(function(y, j) {
      canSplit = j && dif[i] && y.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y.ss : [y.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-function.js
var is_function_default = function(value) {
  return typeof value === "function";
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-nil.js
var isNil = function(value) {
  return value === null || value === void 0;
};
var is_nil_default = isNil;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value, type) {
  return toString.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-array.js
var is_array_default = function(value) {
  return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value) {
  if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/max.js
var max_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!is_array_default(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-string.js
var is_string_default = function(str7) {
  return is_type_default(str7, "String");
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a, min4, max4) {
  if (a < min4) {
    return min4;
  } else if (a > max4) {
    return max4;
  }
  return a;
};
var clamp_default = clamp;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-number.js
var isNumber = function(value) {
  return is_type_default(value, "Number");
};
var is_number_default = isNumber;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n, m) {
  return (n % m + m) % m;
};
var mod_default = mod;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value) {
  return is_type_default(value, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value) {
  return value === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/component/index.js
var Component = (
  /** @class */
  function() {
    function Component2(props, context, updater) {
      this.isMounted = false;
      this.destroyed = false;
      this.props = props;
      this.state = {};
      this.context = context;
      this.updater = updater;
    }
    Component2.prototype.willMount = function() {
    };
    Component2.prototype.didMount = function() {
    };
    Component2.prototype.shouldUpdate = function(_nextProps) {
      return true;
    };
    Component2.prototype.willReceiveProps = function(_props, _context) {
    };
    Component2.prototype.willUpdate = function() {
    };
    Component2.prototype.didUpdate = function() {
    };
    Component2.prototype.render = function() {
      return null;
    };
    Component2.prototype.willUnmount = function() {
    };
    Component2.prototype.didUnmount = function() {
    };
    Component2.prototype.setState = function(partialState, callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueSetState(this, partialState, callback);
    };
    Component2.prototype.forceUpdate = function(callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueForceUpdate(this, {}, callback);
    };
    Component2.prototype.setAnimate = function(animate) {
      this.animate = animate;
    };
    Component2.prototype.destroy = function() {
      this.destroyed = true;
      this.animator = null;
    };
    return Component2;
  }()
);
Component.prototype.isF2Component = true;
var component_default = Component;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/children.js
function cloneElement(element, props) {
  if (!element)
    return element;
  return __assign(__assign({}, element), {
    props: __assign(__assign({}, element.props), props)
  });
}
function map(children, fn) {
  if (!children) {
    return fn(children);
  }
  if (is_array_default(children)) {
    return children.map(function(child) {
      return map(child, fn);
    });
  }
  return fn(children);
}
function compareArray(nextElements, lastElements, callback) {
  var keyed = {};
  var nextLength = nextElements.length;
  var lastLength = lastElements.length;
  for (var i = 0, len5 = lastLength; i < len5; i++) {
    var element = lastElements[i];
    if (element && !is_nil_default(element.key)) {
      var key = element.key;
      keyed[key] = element;
    }
  }
  var result = [];
  for (var i = 0, len5 = nextLength; i < len5; i++) {
    var element = nextElements[i];
    if (!element) {
      continue;
    }
    var key = element.key;
    var lastElement = void 0;
    if (!is_nil_default(element.key)) {
      lastElement = keyed[key];
      if (lastElement)
        delete keyed[key];
    } else {
      lastElement = lastElements[i];
    }
    if (!lastElement) {
      result.push(compare(element, null, callback));
      continue;
    }
    if (lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed) {
      result.push(compare(element, null, callback));
      continue;
    }
    lastElement.__processed = true;
    result.push(compare(element, lastElement, callback));
  }
  for (var i = 0, len5 = lastLength; i < len5; i++) {
    var lastElement = lastElements[i];
    if (!lastElement) {
      continue;
    }
    if (!(lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed)) {
      result.push(compare(null, lastElement, callback));
    } else {
      delete lastElement.__processed;
    }
  }
  return result;
}
function compare(nextElement, lastElement, callback) {
  if (!nextElement || !lastElement) {
    return callback(nextElement, lastElement);
  }
  if (is_array_default(nextElement) || is_array_default(lastElement)) {
    var nextElementArray = is_array_default(nextElement) ? nextElement : [nextElement];
    var lastElementArray = is_array_default(lastElement) ? lastElement : [lastElement];
    return compareArray(nextElementArray, lastElementArray, callback);
  }
  return callback(nextElement, lastElement);
}
function toArray(element) {
  if (!element) {
    return element;
  }
  if (!is_array_default(element)) {
    return [element];
  }
  var newArray = [];
  for (var i = 0, len5 = element.length; i < len5; i++) {
    var item = element[i];
    if (is_array_default(item)) {
      newArray = newArray.concat(toArray(item));
    } else {
      newArray.push(item);
    }
  }
  return newArray;
}
var Children = {
  cloneElement,
  map,
  toArray,
  compare
};
var children_default = Children;

// node_modules/.pnpm/@antv+g-lite@1.0.42/node_modules/@antv/g-lite/dist/index.esm.js
var import_rbush = __toESM(require_rbush());
var import_rbush2 = __toESM(require_rbush());

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/define.js
function define_default(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l, a) {
  if (a <= 0)
    h2 = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h2 = NaN, s2 = max4 - min4, l = (max4 + min4) / 2;
  if (s2) {
    if (r === max4)
      h2 = (g - b) / s2 + (g < b) * 6;
    else if (g === max4)
      h2 = (b - r) / s2 + 2;
    else
      h2 = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l, o.opacity);
}
function hsl(h2, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h2, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h2, c, l, opacity) {
  this.h = +h2;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h2 = s2 ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l, o.opacity);
}
function cubehelix(h2, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h2), sinh = Math.sin(h2);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

// node_modules/.pnpm/@antv+g-math@1.7.42/node_modules/@antv/g-math/dist/index.esm.js
function distance4(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, xArr);
  var minY = Math.min.apply(Math, yArr);
  var maxX = Math.max.apply(Math, xArr);
  var maxY = Math.max.apply(Math, yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: Math.min(x1, x2),
    maxX: Math.max(x1, x2),
    minY: Math.min(y1, y2),
    maxY: Math.max(y1, y2)
  };
}
function piMod(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
var util = Object.freeze({
  __proto__: null,
  distance: distance4,
  isNumberEqual: isNumberEqual2,
  getBBoxByArray,
  getBBoxRange,
  piMod
});
var line = {
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {object} 
   */
  box: function box(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  length: function length5(x1, y1, x2, y2) {
    return distance4(x1, y1, x2, y2);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} t 
   * @return {object}  x, y 
   */
  pointAt: function pointAt(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
    var cross4 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross4 < 0) {
      return distance4(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross4 > lengthSquare) {
      return distance4(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
    var d4 = [x2 - x1, y2 - y1];
    if (vec2_exports.exactEquals(d4, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d4[1], d4[0]];
    vec2_exports.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2_exports.dot(a, u));
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  tangentAngle: function tangentAngle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length14) {
  var t = -1;
  var d4 = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length14 && length14 > 200) {
    segNum = length14 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d4) {
      t = _t;
      d4 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d4 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval < EPSILON2) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
    var _d = distance4(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d4) {
      t = prev;
      d4 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d4) {
        t = next;
        d4 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, xArr.concat([t])),
    y: tCallback.apply(void 0, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance4(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);
  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance4(x1, y1, x2, y2) + distance4(x2, y2, x3, y3) + distance4(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(void 0, left) + quadraticLength.apply(void 0, right);
}
var quadratic = {
  box: function box2(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function length6(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function nearestPoint$1(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function pointDistance2(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance4(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function pointAt2(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function divide4(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function tangentAngle2(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle3 = Math.atan2(dy, dx);
    return piMod(angle3);
  }
};
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt$1(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema$1(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line.pointAt(x1, y1, x2, y2, t);
  var c2 = line.pointAt(x2, y2, x3, y3, t);
  var c3 = line.pointAt(x3, y3, x4, y4, t);
  var c12 = line.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = [].concat(cubics[0], [iterationCount - 1]);
  var right = [].concat(cubics[1], [iterationCount - 1]);
  return cubicLength.apply(void 0, left) + cubicLength.apply(void 0, right);
}
var cubic = {
  extrema: extrema$1,
  box: function box3(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema$1(x1, x2, x3, x4);
    var yExtrema2 = extrema$1(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var _i = 0; _i < yExtrema2.length; _i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[_i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function length7(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function nearestPoint$12(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length14);
  },
  pointDistance: function pointDistance3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14);
    return distance4(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function pointAt3(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function divide5(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function tangentAngle3(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt$1(x1, x2, x3, x4, t);
    var dy = derivativeAt$1(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse = {
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {object} 
   */
  box: function box4(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {number} 
   */
  length: function length8(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {object} 
   */
  nearestPoint: function nearestPoint2(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px2 = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX = 0;
    var nearestY = 0;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px2 - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {number} 
   */
  pointDistance: function pointDistance4(x, y, rx, ry, x0, y0) {
    var nearestPoint5 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance4(nearestPoint5.x, nearestPoint5.y, x0, y0);
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t x 0
   * @return {object} 
   */
  pointAt: function pointAt4(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle3),
      y: y + ry * Math.sin(angle3)
    };
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t  0 - 1 x 0 0-1  null
   * @return {number}  0 - 2PI 
   */
  tangentAngle: function tangentAngle4(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    var tangentAngle10 = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
    return piMod(tangentAngle10);
  }
};
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function getAngle2(rx, ry, x0, y0) {
  var angle3 = Math.atan2(y0 * rx, x0 * ry);
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle3) {
  return {
    x: rx * Math.cos(angle3),
    y: ry * Math.sin(angle3)
  };
}
function rotate4(x, y, angle3) {
  var cos = Math.cos(angle3);
  var sin = Math.sin(angle3);
  return [x * cos - y * sin, x * sin + y * cos];
}
var arc = {
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @return {object} 
   */
  box: function box5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var _i = 0; _i < xs.length; _i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
      var yAngle = yDim + _i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var _i3 = 0; _i3 < ys.length; _i3++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  /**
   * 
   *  rx, ry, startAngle, endAngle 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   */
  length: function length9(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @param {number} x0          x
   * @param {number} y0          y
   * @return {object} 
   */
  nearestPoint: function nearestPoint3(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate4(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle3 = getAngle2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle3 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle3 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate4(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function pointDistance5(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint5 = this.nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0);
    return distance4(nearestPoint5.x, nearestPoint5.y, x0, y0);
  },
  pointAt: function pointAt5(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle3),
      y: yAt(cx, cy, rx, ry, xRotation, angle3)
    };
  },
  tangentAngle: function tangentAngle5(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    return piMod(Math.atan2(dy, dx));
  }
};
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length14 = distance4(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length14
    };
    segments.push(seg);
    totalLength += length14;
  }
  return {
    segments,
    totalLength
  };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _analyzePoints = analyzePoints(points), segments = _analyzePoints.segments, totalLength = _analyzePoints.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _analyzePoints2 = analyzePoints(points), segments = _analyzePoints2.segments, totalLength = _analyzePoints2.totalLength;
  var startRatio = 0;
  var angle3 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle3 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle3;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];
    var _distance = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
    if (_distance < minDistance) {
      minDistance = _distance;
    }
  }
  return minDistance;
}
var polyline = {
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  box: function box6(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  length: function length10(points) {
    return lengthOfSegment(points);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  pointAt: function pointAt6(points, t) {
    return pointAtSegments(points, t);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} x  x
   * @param {number} y  y
   * @return {number} 
   */
  pointDistance: function pointDistance6(points, x, y) {
    return distanceAtSegment(points, x, y);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  tangentAngle: function tangentAngle6(points, t) {
    return angleAtSegments(points, t);
  }
};

// node_modules/.pnpm/@antv+g-lite@1.0.42/node_modules/@antv/g-lite/dist/index.esm.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var PropertySyntax;
(function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
})(PropertySyntax || (PropertySyntax = {}));
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i = 0, arr2 = new Array(len5); i < len5; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var UnitType;
(function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
})(UnitType || (UnitType = {}));
var UnitCategory;
(function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
})(UnitCategory || (UnitCategory = {}));
var ValueRange;
(function(ValueRange2) {
  ValueRange2[ValueRange2["kAll"] = 0] = "kAll";
  ValueRange2[ValueRange2["kNonNegative"] = 1] = "kNonNegative";
  ValueRange2[ValueRange2["kInteger"] = 2] = "kInteger";
  ValueRange2[ValueRange2["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
  ValueRange2[ValueRange2["kPositiveInteger"] = 4] = "kPositiveInteger";
})(ValueRange || (ValueRange = {}));
var Nested;
(function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
})(Nested || (Nested = {}));
var ParenLess;
(function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
})(ParenLess || (ParenLess = {}));
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType;
(function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
})(CSSStyleValueType || (CSSStyleValueType = {}));
var stringToUnitType = function stringToUnitType2(name) {
  return data.find(function(item) {
    return item.name === name;
  }).unit_type;
};
var unitFromName = function unitFromName2(name) {
  if (!name) {
    return UnitType.kUnknown;
  }
  if (name === "number") {
    return UnitType.kNumber;
  }
  if (name === "percent" || name === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = function() {
  function CSSStyleValue2() {
  }
  CSSStyleValue2.isAngle = function isAngle(unit) {
    return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
  };
  CSSStyleValue2.isLength = function isLength(type) {
    return type >= UnitType.kEms && type < UnitType.kDegrees;
  };
  CSSStyleValue2.isRelativeUnit = function isRelativeUnit(type) {
    return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
    type === UnitType.kRems;
  };
  CSSStyleValue2.isTime = function isTime(unit) {
    return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
  };
  var _proto = CSSStyleValue2.prototype;
  _proto.toString = function toString3() {
    return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
  };
  _proto.isNumericValue = function isNumericValue() {
    return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
  };
  return CSSStyleValue2;
}();
var CSSColorValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSColorValue2, _CSSStyleValue);
  function CSSColorValue2(colorSpace) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.colorSpace = void 0;
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  var _proto = CSSColorValue2.prototype;
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  };
  _proto.to = function to(colorSpace) {
    return this;
  };
  return CSSColorValue2;
}(CSSStyleValue);
var GradientType;
(function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
})(GradientType || (GradientType = {}));
var CSSGradientValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSGradientValue2, _CSSStyleValue);
  function CSSGradientValue2(type, value) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.type = void 0;
    _this2.value = void 0;
    _this2.type = type;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSGradientValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSGradientValue2(this.type, this.value);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  };
  return CSSGradientValue2;
}(CSSStyleValue);
var CSSKeywordValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSKeywordValue2, _CSSStyleValue);
  function CSSKeywordValue2(value) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.value = void 0;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSKeywordValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSKeywordValue2(this.value);
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kKeywordType;
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + this.value;
  };
  return CSSKeywordValue2;
}(CSSStyleValue);
function memoize(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var memoized = function memoized2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized2.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized2.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || Map)();
  return memoized;
}
memoize.Cache = Map;
var camelCase = memoize(function(str7) {
  if (str7 === void 0) {
    str7 = "";
  }
  return str7.replace(/-([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
});
var kebabize = function kebabize2(str7) {
  return str7.split("").map(function(letter, idx) {
    return letter.toUpperCase() === letter ? (idx !== 0 ? "-" : "") + letter.toLowerCase() : letter;
  }).join("");
};
function DCHECK(bool) {
  if (!bool) {
    throw new Error();
  }
}
function isFunction(func) {
  return typeof func === "function";
}
function isSymbol(value) {
  return typeof value === "symbol";
}
var FORMAT_ATTR_MAP = {
  d: {
    alias: "path"
  },
  strokeDasharray: {
    alias: "lineDash"
  },
  strokeWidth: {
    alias: "lineWidth"
  },
  textAnchor: {
    alias: "textAlign"
  },
  src: {
    alias: "img"
  }
};
var formatAttributeName = memoize(function(name) {
  var attributeName = camelCase(name);
  var map3 = FORMAT_ATTR_MAP[attributeName];
  attributeName = (map3 === null || map3 === void 0 ? void 0 : map3.alias) || attributeName;
  return attributeName;
});
var formatInfinityOrNaN = function formatInfinityOrNaN2(number2, suffix) {
  if (suffix === void 0) {
    suffix = "";
  }
  var result = "";
  if (!Number.isFinite(number2)) {
    if (number2 > 0)
      result = "infinity";
    else
      result = "-infinity";
  } else {
    DCHECK(Number.isNaN(number2));
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSUnitValue2, _CSSStyleValue);
  function CSSUnitValue2(value, unitOrName) {
    var _this2;
    if (unitOrName === void 0) {
      unitOrName = UnitType.kNumber;
    }
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.unit = void 0;
    _this2.value = void 0;
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSUnitValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSUnitValue2(this.value, this.unit);
  };
  _proto.equals = function equals7(other) {
    var other_unit_value = other;
    return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kUnitType;
  };
  _proto.convertTo = function convertTo(target_unit) {
    if (this.unit === target_unit) {
      return new CSSUnitValue2(this.value, this.unit);
    }
    var canonical_unit = toCanonicalUnit(this.unit);
    if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
      return null;
    }
    var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
    return new CSSUnitValue2(this.value * scale_factor, target_unit);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    var text;
    switch (this.unit) {
      case UnitType.kUnknown:
        break;
      case UnitType.kInteger:
        text = Number(this.value).toFixed(0);
        break;
      case UnitType.kNumber:
      case UnitType.kPercentage:
      case UnitType.kEms:
      case UnitType.kRems:
      case UnitType.kPixels:
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
      case UnitType.kTurns: {
        var kMinInteger = -999999;
        var kMaxInteger = 999999;
        var value = this.value;
        var unit = unitTypeToString(this.unit);
        if (value < kMinInteger || value > kMaxInteger) {
          var _unit = unitTypeToString(this.unit);
          if (!Number.isFinite(value) || Number.isNaN(value)) {
            text = formatInfinityOrNaN(value, _unit);
          } else {
            text = value + (_unit || "");
          }
        } else {
          text = "" + value + unit;
        }
      }
    }
    result += text;
    return result;
  };
  return CSSUnitValue2;
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
var Lpx = new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = function(_CSSColorValue) {
  _inheritsLoose(CSSRGB2, _CSSColorValue);
  function CSSRGB2(r, g, b, alpha, isNone) {
    var _this2;
    if (alpha === void 0) {
      alpha = 1;
    }
    if (isNone === void 0) {
      isNone = false;
    }
    _this2 = _CSSColorValue.call(this, "rgb") || this;
    _this2.r = void 0;
    _this2.g = void 0;
    _this2.b = void 0;
    _this2.alpha = void 0;
    _this2.isNone = void 0;
    _this2.r = r;
    _this2.g = g;
    _this2.b = b;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  var _proto = CSSRGB2.prototype;
  _proto.clone = function clone7() {
    return new CSSRGB2(this.r, this.g, this.b, this.alpha);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + ("rgba(" + this.r + "," + this.g + "," + this.b + "," + this.alpha + ")");
  };
  return CSSRGB2;
}(CSSColorValue);
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n) {
    return new CSSUnitValue(n, "%");
  },
  /**
   * <length>
   */
  px: function px(n) {
    return new CSSUnitValue(n, "px");
  },
  /**
   * <length>
   */
  em: function em(n) {
    return new CSSUnitValue(n, "em");
  },
  rem: function rem(n) {
    return new CSSUnitValue(n, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n) {
    return new CSSUnitValue(n, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n) {
    return new CSSUnitValue(n, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n) {
    return new CSSUnitValue(n, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n) {
    return new CSSUnitValue(n, "turn");
  },
  /**
   * <time>
   */
  s: function s(n) {
    return new CSSUnitValue(n, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n) {
    return new CSSUnitValue(n, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name,
      inh: inherits,
      int: interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name, clazz) {
    runtime.layoutRegistry.registerLayout(name, clazz);
  }
};
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name) {
  if (!keywordCache[name]) {
    keywordCache[name] = new CSSKeywordValue(name);
  }
  return keywordCache[name];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize(function(r, g, b, a) {
  return new CSSRGB(r, g, b, a);
}, function(r, g, b, a) {
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value, unitOrName) {
  if (unitOrName === void 0) {
    unitOrName = UnitType.kNumber;
  }
  return new CSSUnitValue(value, unitOrName);
};
var canvasMap = {};
var defaultCanvasIdCounter = 0;
function cleanExistedCanvas(container, canvas) {
  if (container) {
    var id2 = typeof container === "string" ? container : container.id || defaultCanvasIdCounter++;
    if (canvasMap[id2]) {
      canvasMap[id2].destroy();
    }
    canvasMap[id2] = canvas;
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.style.zIndex);
  var zIndex2 = Number(o2.style.zIndex);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$style;
    var clipPath = (_el$style = el.style) === null || _el$style === void 0 ? void 0 : _el$style.clipPath;
    if (clipPath)
      return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
function copyVec3(a, b) {
  a[0] = b[0];
  a[1] = b[1];
  a[2] = b[2];
  return a;
}
function subVec3(o, a, b) {
  o[0] = a[0] - b[0];
  o[1] = a[1] - b[1];
  o[2] = a[2] - b[2];
  return o;
}
function addVec3(o, a, b) {
  o[0] = a[0] + b[0];
  o[1] = a[1] + b[1];
  o[2] = a[2] + b[2];
  return o;
}
function scaleVec3(o, a, b) {
  o[0] = a[0] * b;
  o[1] = a[1] * b;
  o[2] = a[2] * b;
  return o;
}
function maxVec3(o, a, b) {
  o[0] = Math.max(a[0], b[0]);
  o[1] = Math.max(a[1], b[1]);
  o[2] = Math.max(a[2], b[2]);
  return o;
}
function minVec3(o, a, b) {
  o[0] = Math.min(a[0], b[0]);
  o[1] = Math.min(a[1], b[1]);
  o[2] = Math.min(a[2], b[2]);
  return o;
}
function getAngle3(angle3) {
  if (angle3 === void 0) {
    return 0;
  } else if (angle3 > 360 || angle3 < -360) {
    return angle3 % 360;
  }
  return angle3;
}
function createVec3(x, y, z) {
  if (y === void 0) {
    y = 0;
  }
  if (z === void 0) {
    z = 0;
  }
  if (is_number_default(x)) {
    return vec3_exports.fromValues(x, y, z);
  }
  if (Array.isArray(x) && x.length === 3) {
    return vec3_exports.clone(x);
  }
  return vec3_exports.fromValues(x[0], x[1] || y, x[2] || z);
}
function deg2rad2(deg2) {
  return deg2 * (Math.PI / 180);
}
function rad2deg2(rad2) {
  return rad2 * (180 / Math.PI);
}
function turn2deg(turn2) {
  return 360 * turn2;
}
function getEulerFromQuat(out, quat2) {
  var x = quat2[0];
  var y = quat2[1];
  var z = quat2[2];
  var w = quat2[3];
  var x2 = x * x;
  var y2 = y * y;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x2 + y2 + z2 + w2;
  var test = x * w - y * z;
  if (test > 0.499995 * unit) {
    out[0] = Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x * z - w * y));
    out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m) {
  var x;
  var z;
  var halfPi = Math.PI * 0.5;
  var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m), sx = _mat4$getScaling[0], sy = _mat4$getScaling[1], sz = _mat4$getScaling[2];
  var y = Math.asin(-m[2] / sx);
  if (y < halfPi) {
    if (y > -halfPi) {
      x = Math.atan2(m[6] / sy, m[10] / sz);
      z = Math.atan2(m[1] / sx, m[0] / sx);
    } else {
      z = 0;
      x = -Math.atan2(m[4] / sy, m[5] / sy);
    }
  } else {
    z = 0;
    x = Math.atan2(m[4] / sy, m[5] / sy);
  }
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  } else {
    return getEulerFromQuat(out, quat2);
  }
}
function fromRotationTranslationScale2(rotation, x, y, scaleX, scaleY) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var x = 2 * near / (right - left);
  var y = 2 * near / (top - bottom);
  var a = (right + left) / (right - left);
  var b = (top + bottom) / (top - bottom);
  var c = -(far + near) / (far - near);
  var d4 = -2 * far * near / (far - near);
  out[0] = x;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y;
  out[6] = 0;
  out[7] = 0;
  out[8] = a;
  out[9] = b;
  out[10] = c;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d4;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    row0x *= 1 / scalingX;
    row0y *= 1 / scalingX;
  }
  if (scalingY) {
    row1x *= 1 / scalingY;
    row1y *= 1 / scalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle3 = rad2deg2(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle3];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix, translation, scale8, skew, perspective2, quaternion) {
  if (!normalize5(tmp, matrix))
    return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8)
    return false;
  var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret)
      return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale8[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew[0] = vec3_exports.dot(row[0], row[1]);
  combine(row[1], row[1], row[0], 1, -skew[0]);
  scale8[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew[0] /= scale8[1];
  skew[1] = vec3_exports.dot(row[0], row[2]);
  combine(row[2], row[2], row[0], 1, -skew[1]);
  skew[2] = vec3_exports.dot(row[1], row[2]);
  combine(row[2], row[2], row[1], 1, -skew[2]);
  scale8[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew[1] /= scale8[2];
  skew[2] /= scale8[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale8[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2];
  return true;
}
function normalize5(out, mat) {
  var m44 = mat[15];
  if (m44 === 0)
    return false;
  var scale8 = 1 / m44;
  for (var i = 0; i < 16; i++) {
    out[i] = mat[i] * scale8;
  }
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine(out, a, b, scale1, scale22) {
  out[0] = a[0] * scale1 + b[0] * scale22;
  out[1] = a[1] * scale1 + b[1] * scale22;
  out[2] = a[2] * scale1 + b[2] * scale22;
}
var tmpMat4 = mat4_exports.create();
function parsedTransformToMat4(transform, object) {
  if (transform && transform.length) {
    var defX = 0;
    var defY = 0;
    if (object) {
      defX = object.parsedStyle.defX || 0;
      defY = object.parsedStyle.defY || 0;
      object.resetLocalTransform();
      object.setLocalPosition(defX, defY);
    } else {
      object = new DisplayObject({});
    }
    transform.forEach(function(parsed) {
      var t = parsed.t, d4 = parsed.d;
      if (t === "scale") {
        var newScale = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1, 1];
        object.scaleLocal(newScale[0], newScale[1], 1);
      } else if (t === "scalex") {
        var _newScale = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(_newScale[0], 1, 1);
      } else if (t === "scaley") {
        var _newScale2 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(1, _newScale2[0], 1);
      } else if (t === "scalez") {
        var _newScale3 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(1, 1, _newScale3[0]);
      } else if (t === "scale3d") {
        var _newScale4 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1, 1, 1];
        object.scaleLocal(_newScale4[0], _newScale4[1], _newScale4[2]);
      } else if (t === "translate") {
        var newTranslation = d4 || [Opx, Opx];
        object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
      } else if (t === "translatex") {
        var _newTranslation = d4 || [Opx];
        object.translateLocal(_newTranslation[0].value, 0, 0);
      } else if (t === "translatey") {
        var _newTranslation2 = d4 || [Opx];
        object.translateLocal(0, _newTranslation2[0].value, 0);
      } else if (t === "translatez") {
        var _newTranslation3 = d4 || [Opx];
        object.translateLocal(0, 0, _newTranslation3[0].value);
      } else if (t === "translate3d") {
        var _newTranslation4 = d4 || [Opx, Opx, Opx];
        object.translateLocal(_newTranslation4[0].value, _newTranslation4[1].value, _newTranslation4[2].value);
      } else if (t === "rotate") {
        var newAngles = d4 || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
      } else if (t === "rotatex") {
        var _newAngles = d4 || [Odeg];
        object.rotateLocal(convertAngleUnit(_newAngles[0]), 0, 0);
      } else if (t === "rotatey") {
        var _newAngles2 = d4 || [Odeg];
        object.rotateLocal(0, convertAngleUnit(_newAngles2[0]), 0);
      } else if (t === "rotatez") {
        var _newAngles3 = d4 || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(_newAngles3[0]));
      } else if (t === "rotate3d")
        ;
      else if (t === "skew") {
        var newSkew = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0, 0];
        object.setLocalSkew(deg2rad2(newSkew[0]), deg2rad2(newSkew[1]));
      } else if (t === "skewx") {
        var _newSkew = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0];
        object.setLocalSkew(deg2rad2(_newSkew[0]), object.getLocalSkew()[1]);
      } else if (t === "skewy") {
        var _newSkew2 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0];
        object.setLocalSkew(object.getLocalSkew()[0], deg2rad2(_newSkew2[0]));
      } else if (t === "matrix") {
        var _d$map = d4.map(function(s2) {
          return s2.value;
        }), a = _d$map[0], b = _d$map[1], c = _d$map[2], dd = _d$map[3], tx = _d$map[4], ty = _d$map[5];
        object.setLocalTransform(mat4_exports.set(tmpMat4, a, b, 0, 0, c, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
      } else if (t === "matrix3d") {
        mat4_exports.set.apply(mat4_exports, [tmpMat4].concat(d4.map(function(s2) {
          return s2.value;
        })));
        tmpMat4[12] += defX;
        tmpMat4[13] += defY;
        object.setLocalTransform(tmpMat4);
      }
    });
  }
  return object.getLocalTransform();
}
function colorStopToString(colorStop) {
  var type = colorStop.type, value = colorStop.value;
  if (type === "hex") {
    return "#" + value;
  } else if (type === "literal") {
    return value;
  } else if (type === "rgb") {
    return "rgb(" + value.join(",") + ")";
  } else {
    return "rgba(" + value.join(",") + ")";
  }
}
var parseGradient = function() {
  var tokens = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error(msg) {
    throw new Error(input + ": " + msg);
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle2 = match("shape", /^(circle)/i, 0);
    if (circle2) {
      circle2.style = matchLength() || matchExtentKeyword();
    }
    return circle2;
  }
  function matchEllipse() {
    var ellipse2 = match("shape", /^(ellipse)/i, 0);
    if (ellipse2) {
      ellipse2.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse2;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size2) {
    input = input.substring(size2);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(width, height, angle3) {
  var rad2 = deg2rad2(angle3.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length14 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
  var x1 = rcx - Math.cos(rad2) * length14 / 2;
  var y1 = rcy - Math.sin(rad2) * length14 / 2;
  var x2 = rcx + Math.cos(rad2) * length14 / 2;
  var y2 = rcy + Math.sin(rad2) * length14 / 2;
  return {
    x1,
    y1,
    x2,
    y2
  };
}
function computeRadialGradient(width, height, cx, cy, size2) {
  var x = cx.value;
  var y = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y = cy.value / 100 * height;
  }
  var r = Math.max(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
  if (size2) {
    if (size2 instanceof CSSUnitValue) {
      r = size2.value;
    } else if (size2 instanceof CSSKeywordValue) {
      if (size2.value === "closest-side") {
        r = Math.min(x, width - x, y, height - y);
      } else if (size2.value === "farthest-side") {
        r = Math.max(x, width - x, y, height - y);
      } else if (size2.value === "closest-corner") {
        r = Math.min(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
      }
    }
  }
  return {
    x,
    y,
    r
  };
}
var Shape;
(function(Shape3) {
  Shape3["GROUP"] = "g";
  Shape3["CIRCLE"] = "circle";
  Shape3["ELLIPSE"] = "ellipse";
  Shape3["IMAGE"] = "image";
  Shape3["RECT"] = "rect";
  Shape3["LINE"] = "line";
  Shape3["POLYLINE"] = "polyline";
  Shape3["POLYGON"] = "polygon";
  Shape3["TEXT"] = "text";
  Shape3["PATH"] = "path";
  Shape3["HTML"] = "html";
  Shape3["MESH"] = "mesh";
})(Shape || (Shape = {}));
function getOrCalculatePathTotalLength(path) {
  if (path.parsedStyle.path.totalLength === 0) {
    path.parsedStyle.path.totalLength = getTotalLength(path.parsedStyle.path.absolutePath);
  }
  return path.parsedStyle.path.totalLength;
}
function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box10 = void 0;
    switch (segment.command) {
      case "Q":
        box10 = quadratic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box10 = cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box10 = arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box10) {
      segment.box = box10;
      xArr.push(box10.x, box10.x + box10.width);
      yArr.push(box10.y, box10.y + box10.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (_currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
var angleBetween2 = function angleBetween3(v0, v1) {
  var p = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad2(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx = Math.sqrt(radiiCheck) * rx;
    ry = Math.sqrt(radiiCheck) * ry;
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween2({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween2(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle3 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle3);
  var ellipseComponentY = ry * Math.sin(angle3);
  var point = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle3,
    ellipticalArcCenter: center,
    resultantRx: rx,
    resultantRy: ry
  };
  return point;
};
function path2Segments(path) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio, sign) {
  if (sign === void 0) {
    sign = true;
  }
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist4 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist4,
    y: -yDist / dist4
  };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad2(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform) {
  var _object$parsedStyle = object.parsedStyle, _object$parsedStyle$d = _object$parsedStyle.defX, defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d, _object$parsedStyle$d2 = _object$parsedStyle.defY, defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
  return commands.reduce(function(prev, cur) {
    var path = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(p, p, transform);
      }
      path = "" + cur[0] + p[0] + "," + p[1];
    } else if (cur[0] === "Z") {
      path = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var p2 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      var p3 = vec3_exports.fromValues(cur[5] - defX, cur[6] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(p1, p1, transform);
        vec3_exports.transformMat4(p2, p2, transform);
        vec3_exports.transformMat4(p3, p3, transform);
      }
      path = "" + cur[0] + p1[0] + "," + p1[1] + "," + p2[0] + "," + p2[1] + "," + p3[0] + "," + p3[1];
    } else if (cur[0] === "A") {
      var c = vec3_exports.fromValues(cur[6] - defX, cur[7] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(c, c, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "," + cur[5] + "," + c[0] + "," + c[1];
    } else if (cur[0] === "Q") {
      var _p = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var _p2 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(_p, _p, transform);
        vec3_exports.transformMat4(_p2, _p2, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "}";
    }
    return prev += path;
  }, "");
}
function lineToCommands(x1, y1, x2, y2) {
  return [["M", x1, y1], ["L", x2, y2]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left = cx - rx;
  var right = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [["M", left, cy], ["C", left, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right, cy - dy, right, cy], ["C", right, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left, cy + dy, left, cy], ["Z"]];
}
function polygonToCommands(points, closed) {
  var result = points.map(function(point, i) {
    return [i === 0 ? "M" : "L", point[0], point[1]];
  });
  if (closed) {
    result.push(["Z"]);
  }
  return result;
}
function rectToCommands(width, height, x, y, radius) {
  if (radius) {
    var tlr = radius[0], trr = radius[1], brr = radius[2], blr = radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [["M", signX * tlr + x, y], ["L", width - signX * trr + x, y], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x, signY * trr + y] : null, ["L", width + x, height - signY * brr + y], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x - signX * brr, height + y] : null, ["L", x + signX * blr, height + y], blr ? ["A", blr, blr, 0, 0, sweepFlag, x, height + y - signY * blr] : null, ["L", x, signY * tlr + y], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x, y] : null, ["Z"]].filter(function(command) {
      return command;
    });
  }
  return [["M", x, y], ["L", x + width, y], ["L", x + width, y + height], ["L", x, y + height], ["Z"]];
}
function convertToPath(object, transform) {
  if (transform === void 0) {
    transform = object.getLocalTransform();
  }
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _object$parsedStyle2 = object.parsedStyle, x1 = _object$parsedStyle2.x1, y1 = _object$parsedStyle2.y1, x2 = _object$parsedStyle2.x2, y2 = _object$parsedStyle2.y2;
      commands = lineToCommands(x1, y1, x2, y2);
      break;
    case Shape.CIRCLE: {
      var _object$parsedStyle3 = object.parsedStyle, r = _object$parsedStyle3.r, cx = _object$parsedStyle3.cx, cy = _object$parsedStyle3.cy;
      commands = ellipseToCommands(r, r, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _object$parsedStyle4 = object.parsedStyle, rx = _object$parsedStyle4.rx, ry = _object$parsedStyle4.ry, _cx = _object$parsedStyle4.cx, _cy = _object$parsedStyle4.cy;
      commands = ellipseToCommands(rx, ry, _cx, _cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _object$parsedStyle5 = object.parsedStyle, width = _object$parsedStyle5.width, height = _object$parsedStyle5.height, x = _object$parsedStyle5.x, y = _object$parsedStyle5.y, radius = _object$parsedStyle5.radius;
      var hasRadius = radius && radius.some(function(r2) {
        return r2 !== 0;
      });
      commands = rectToCommands(width, height, x, y, hasRadius && radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.path.absolutePath;
      commands = [].concat(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform);
  }
}
function isFillOrStrokeAffected(pointerEvents, fill, stroke) {
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var CALL_DELEGATE = function CALL_DELEGATE2() {
  this.call = this._createCall("sync");
  return this.call.apply(this, arguments);
};
var CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE2() {
  this.callAsync = this._createCall("async");
  return this.callAsync.apply(this, arguments);
};
var PROMISE_DELEGATE = function PROMISE_DELEGATE2() {
  this.promise = this._createCall("promise");
  return this.promise.apply(this, arguments);
};
var Hook = function() {
  function Hook2(args, name) {
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    this.name = void 0;
    this.taps = void 0;
    this.promise = void 0;
    this._promise = void 0;
    this._args = args;
    this.name = name;
    this.taps = [];
    this.interceptors = [];
    this._call = CALL_DELEGATE;
    this.call = CALL_DELEGATE;
    this._callAsync = CALL_ASYNC_DELEGATE;
    this.callAsync = CALL_ASYNC_DELEGATE;
    this._promise = PROMISE_DELEGATE;
    this.promise = PROMISE_DELEGATE;
    this._x = void 0;
  }
  var _proto = Hook2.prototype;
  _proto.compile = function compile(options) {
    throw new Error("Abstract: should be overridden");
  };
  _proto._createCall = function _createCall(type) {
    return this.compile({
      taps: this.taps,
      interceptors: this.interceptors,
      args: this._args,
      type
    });
  };
  _proto._tap = function _tap(type, options, fn) {
    if (typeof options === "string") {
      options = {
        name: options.trim()
      };
    } else if (typeof options !== "object" || options === null) {
      throw new Error("Invalid tap options");
    }
    if (typeof options.name !== "string" || options.name === "") {
      throw new Error("Missing name for tap");
    }
    options = Object.assign({
      type,
      fn
    }, options);
    options = this._runRegisterInterceptors(options);
    this._insert(options);
  };
  _proto.tap = function tap(options, fn) {
    this._tap("sync", options, fn);
  };
  _proto.tapAsync = function tapAsync(options, fn) {
    this._tap("async", options, fn);
  };
  _proto.tapPromise = function tapPromise(options, fn) {
    this._tap("promise", options, fn);
  };
  _proto._runRegisterInterceptors = function _runRegisterInterceptors(options) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.interceptors), _step; !(_step = _iterator()).done; ) {
      var interceptor = _step.value;
      if (interceptor.register) {
        var newOptions = interceptor.register(options);
        if (newOptions !== void 0) {
          options = newOptions;
        }
      }
    }
    return options;
  };
  _proto.withOptions = function withOptions(options) {
    var _this2 = this;
    var mergeOptions = function mergeOptions2(opt) {
      return Object.assign({}, options, typeof opt === "string" ? {
        name: opt
      } : opt);
    };
    return {
      name: this.name,
      tap: function tap(opt, fn) {
        return _this2.tap(mergeOptions(opt), fn);
      },
      tapAsync: function tapAsync(opt, fn) {
        return _this2.tapAsync(mergeOptions(opt), fn);
      },
      tapPromise: function tapPromise(opt, fn) {
        return _this2.tapPromise(mergeOptions(opt), fn);
      },
      // intercept: (interceptor) => this.intercept(interceptor),
      isUsed: function isUsed() {
        return _this2.isUsed();
      },
      withOptions: function withOptions2(opt) {
        return _this2.withOptions(mergeOptions(opt));
      }
    };
  };
  _proto.isUsed = function isUsed() {
    return this.taps.length > 0 || this.interceptors.length > 0;
  };
  _proto._resetCompilation = function _resetCompilation() {
    this.call = this._call;
    this.callAsync = this._callAsync;
    this.promise = this._promise;
  };
  _proto._insert = function _insert(item) {
    this._resetCompilation();
    var before;
    if (typeof item.before === "string") {
      before = /* @__PURE__ */ new Set([item.before]);
    } else if (Array.isArray(item.before)) {
      before = new Set(item.before);
    }
    var stage = 0;
    if (typeof item.stage === "number") {
      stage = item.stage;
    }
    var i = this.taps.length;
    while (i > 0) {
      i--;
      var x = this.taps[i];
      this.taps[i + 1] = x;
      var xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) {
          continue;
        }
      }
      if (xStage > stage) {
        continue;
      }
      i++;
      break;
    }
    this.taps[i] = item;
  };
  return Hook2;
}();
var HookCodeFactory = function() {
  function HookCodeFactory2(config) {
    this.config = config;
    this.options = void 0;
    this._args = void 0;
  }
  var _proto = HookCodeFactory2.prototype;
  _proto.create = function create8(options) {
    this.init(options);
    var fn;
    switch (this.options.type) {
      case "sync":
        fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "throw " + err + ";\n";
          },
          onResult: function onResult(result) {
            return "return " + result + ";\n";
          },
          resultReturns: true,
          onDone: function onDone() {
            return "";
          },
          rethrowIfPossible: true
        }));
        break;
      case "async":
        fn = new Function(this.args({
          after: "_callback"
        }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "_callback(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_callback(null, " + result + ");\n";
          },
          onDone: function onDone() {
            return "_callback();\n";
          }
        }));
        break;
      case "promise":
        var errorHelperUsed = false;
        var content = this.contentWithInterceptors({
          onError: function onError(err) {
            errorHelperUsed = true;
            return "_error(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_resolve(" + result + ");\n";
          },
          onDone: function onDone() {
            return "_resolve();\n";
          }
        });
        var code = "";
        code += '"use strict";\n';
        code += this.header();
        code += "return new Promise((function(_resolve, _reject) {\n";
        if (errorHelperUsed) {
          code += "var _sync = true;\n";
          code += "function _error(_err) {\n";
          code += "if(_sync)\n";
          code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
          code += "else\n";
          code += "_reject(_err);\n";
          code += "};\n";
        }
        code += content;
        if (errorHelperUsed) {
          code += "_sync = false;\n";
        }
        code += "}));\n";
        fn = new Function(this.args(), code);
        break;
    }
    this.deinit();
    return fn;
  };
  _proto.setup = function setup(instance, options) {
    instance._x = options.taps.map(function(t) {
      return t.fn;
    });
  };
  _proto.init = function init(options) {
    this.options = options;
    this._args = options.args.slice();
  };
  _proto.deinit = function deinit() {
    this.options = void 0;
    this._args = void 0;
  };
  _proto.contentWithInterceptors = function contentWithInterceptors(options) {
    var _this2 = this;
    if (this.options.interceptors.length > 0) {
      var onError = options.onError;
      var onResult = options.onResult;
      var onDone = options.onDone;
      var code = "";
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.call) {
          code += this.getInterceptor(i) + ".call(" + this.args({
            before: interceptor.context ? "_context" : void 0
          }) + ");\n";
        }
      }
      code += this.content(Object.assign(options, {
        onError: onError && function(err) {
          var code2 = "";
          for (var _i = 0; _i < _this2.options.interceptors.length; _i++) {
            var _interceptor = _this2.options.interceptors[_i];
            if (_interceptor.error) {
              code2 += _this2.getInterceptor(_i) + ".error(" + err + ");\n";
            }
          }
          code2 += onError(err);
          return code2;
        },
        onResult: onResult && function(result) {
          var code2 = "";
          for (var _i2 = 0; _i2 < _this2.options.interceptors.length; _i2++) {
            var _interceptor2 = _this2.options.interceptors[_i2];
            if (_interceptor2.result) {
              code2 += _this2.getInterceptor(_i2) + ".result(" + result + ");\n";
            }
          }
          code2 += onResult(result);
          return code2;
        },
        onDone: onDone && function() {
          var code2 = "";
          for (var _i3 = 0; _i3 < _this2.options.interceptors.length; _i3++) {
            var _interceptor3 = _this2.options.interceptors[_i3];
            if (_interceptor3.done) {
              code2 += _this2.getInterceptor(_i3) + ".done();\n";
            }
          }
          code2 += onDone();
          return code2;
        }
      }));
      return code;
    } else {
      return this.content(options);
    }
  };
  _proto.header = function header() {
    var code = "";
    if (this.needContext()) {
      code += "var _context = {};\n";
    } else {
      code += "var _context;\n";
    }
    code += "var _x = this._x;\n";
    if (this.options.interceptors.length > 0) {
      code += "var _taps = this.taps;\n";
      code += "var _interceptors = this.interceptors;\n";
    }
    return code;
  };
  _proto.needContext = function needContext() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.options.taps), _step; !(_step = _iterator()).done; ) {
      var tap = _step.value;
      if (tap.context)
        return true;
    }
    return false;
  };
  _proto.callTap = function callTap(tapIndex, _ref) {
    var onError = _ref.onError, onResult = _ref.onResult, onDone = _ref.onDone, rethrowIfPossible = _ref.rethrowIfPossible;
    var code = "";
    var hasTapCached = false;
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.tap) {
        if (!hasTapCached) {
          code += "var _tap" + tapIndex + " = " + this.getTap(tapIndex) + ";\n";
          hasTapCached = true;
        }
        code += this.getInterceptor(i) + ".tap(" + (interceptor.context ? "_context, " : "") + "_tap" + tapIndex + ");\n";
      }
    }
    code += "var _fn" + tapIndex + " = " + this.getTapFn(tapIndex) + ";\n";
    var tap = this.options.taps[tapIndex];
    switch (tap.type) {
      case "sync":
        if (!rethrowIfPossible) {
          code += "var _hasError" + tapIndex + " = false;\n";
          code += "try {\n";
        }
        if (onResult) {
          code += "var _result" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
            before: tap.context ? "_context" : void 0
          }) + ");\n";
        } else {
          code += "_fn" + tapIndex + "(" + this.args({
            before: tap.context ? "_context" : void 0
          }) + ");\n";
        }
        if (!rethrowIfPossible) {
          code += "} catch(_err) {\n";
          code += "_hasError" + tapIndex + " = true;\n";
          code += onError("_err");
          code += "}\n";
          code += "if(!_hasError" + tapIndex + ") {\n";
        }
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        if (!rethrowIfPossible) {
          code += "}\n";
        }
        break;
      case "async":
        var cbCode = "";
        if (onResult)
          cbCode += "(function(_err" + tapIndex + ", _result" + tapIndex + ") {\n";
        else
          cbCode += "(function(_err" + tapIndex + ") {\n";
        cbCode += "if(_err" + tapIndex + ") {\n";
        cbCode += onError("_err" + tapIndex);
        cbCode += "} else {\n";
        if (onResult) {
          cbCode += onResult("_result" + tapIndex);
        }
        if (onDone) {
          cbCode += onDone();
        }
        cbCode += "}\n";
        cbCode += "})";
        code += "_fn" + tapIndex + "(" + this.args({
          before: tap.context ? "_context" : void 0,
          after: cbCode
        }) + ");\n";
        break;
      case "promise":
        code += "var _hasResult" + tapIndex + " = false;\n";
        code += "var _promise" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
          before: tap.context ? "_context" : void 0
        }) + ");\n";
        code += "if (!_promise" + tapIndex + " || !_promise" + tapIndex + ".then)\n";
        code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise" + tapIndex + " + ')');\n";
        code += "_promise" + tapIndex + ".then((function(_result" + tapIndex + ") {\n";
        code += "_hasResult" + tapIndex + " = true;\n";
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        code += "}), function(_err" + tapIndex + ") {\n";
        code += "if(_hasResult" + tapIndex + ") throw _err" + tapIndex + ";\n";
        code += onError("_err" + tapIndex);
        code += "});\n";
        break;
    }
    return code;
  };
  _proto.callTapsSeries = function callTapsSeries(_ref2) {
    var _this2 = this;
    var _onError = _ref2.onError, onResult = _ref2.onResult, resultReturns = _ref2.resultReturns, onDone = _ref2.onDone, doneReturns = _ref2.doneReturns, rethrowIfPossible = _ref2.rethrowIfPossible;
    if (this.options.taps.length === 0)
      return onDone();
    var firstAsync = this.options.taps.findIndex(function(t) {
      return t.type !== "sync";
    });
    var somethingReturns = resultReturns || doneReturns;
    var code = "";
    var current = onDone;
    var unrollCounter = 0;
    var _loop = function _loop2(j2) {
      var i = j2;
      var unroll = current !== onDone && (_this2.options.taps[i].type !== "sync" || unrollCounter++ > 20);
      if (unroll) {
        unrollCounter = 0;
        code += "function _next" + i + "() {\n";
        code += current();
        code += "}\n";
        current = function current2() {
          return (somethingReturns ? "return " : "") + "_next" + i + "();\n";
        };
      }
      var done = current;
      var doneBreak = function doneBreak2(skipDone) {
        if (skipDone)
          return "";
        return onDone();
      };
      var content = _this2.callTap(i, {
        onError: function onError(error) {
          return _onError(i, error, done, doneBreak);
        },
        onResult: onResult && function(result) {
          return onResult(i, result, done, doneBreak);
        },
        onDone: !onResult && done,
        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
      });
      current = function current2() {
        return content;
      };
    };
    for (var j = this.options.taps.length - 1; j >= 0; j--) {
      _loop(j);
    }
    code += current();
    return code;
  };
  _proto.callTapsLooping = function callTapsLooping(_ref3) {
    var onError = _ref3.onError, onDone = _ref3.onDone, rethrowIfPossible = _ref3.rethrowIfPossible;
    if (this.options.taps.length === 0)
      return onDone();
    var syncOnly = this.options.taps.every(function(t) {
      return t.type === "sync";
    });
    var code = "";
    if (!syncOnly) {
      code += "var _looper = (function() {\n";
      code += "var _loopAsync = false;\n";
    }
    code += "var _loop;\n";
    code += "do {\n";
    code += "_loop = false;\n";
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.loop) {
        code += this.getInterceptor(i) + ".loop(" + this.args({
          before: interceptor.context ? "_context" : void 0
        }) + ");\n";
      }
    }
    code += this.callTapsSeries({
      onError,
      onResult: function onResult(i2, result, next, doneBreak) {
        var code2 = "";
        code2 += "if(" + result + " !== undefined) {\n";
        code2 += "_loop = true;\n";
        if (!syncOnly)
          code2 += "if(_loopAsync) _looper();\n";
        code2 += doneBreak(true);
        code2 += "} else {\n";
        code2 += next();
        code2 += "}\n";
        return code2;
      },
      onDone: onDone && function() {
        var code2 = "";
        code2 += "if(!_loop) {\n";
        code2 += onDone();
        code2 += "}\n";
        return code2;
      },
      rethrowIfPossible: rethrowIfPossible && syncOnly
    });
    code += "} while(_loop);\n";
    if (!syncOnly) {
      code += "_loopAsync = true;\n";
      code += "});\n";
      code += "_looper();\n";
    }
    return code;
  };
  _proto.callTapsParallel = function callTapsParallel(_ref4) {
    var _this3 = this;
    var _onError2 = _ref4.onError, onResult = _ref4.onResult, onDone = _ref4.onDone, rethrowIfPossible = _ref4.rethrowIfPossible, _ref4$onTap = _ref4.onTap, onTap = _ref4$onTap === void 0 ? function(i2, run) {
      return run();
    } : _ref4$onTap;
    if (this.options.taps.length <= 1) {
      return this.callTapsSeries({
        onError: _onError2,
        onResult,
        onDone,
        rethrowIfPossible
      });
    }
    var code = "";
    code += "do {\n";
    code += "var _counter = " + this.options.taps.length + ";\n";
    if (onDone) {
      code += "var _done = (function() {\n";
      code += onDone();
      code += "});\n";
    }
    var _loop2 = function _loop22(i2) {
      var done = function done2() {
        if (onDone)
          return "if(--_counter === 0) _done();\n";
        else
          return "--_counter;";
      };
      var doneBreak = function doneBreak2(skipDone) {
        if (skipDone || !onDone)
          return "_counter = 0;\n";
        else
          return "_counter = 0;\n_done();\n";
      };
      code += "if(_counter <= 0) break;\n";
      code += onTap(i2, function() {
        return _this3.callTap(i2, {
          onError: function onError(error) {
            var code2 = "";
            code2 += "if(_counter > 0) {\n";
            code2 += _onError2(i2, error, done, doneBreak);
            code2 += "}\n";
            return code2;
          },
          onResult: onResult && function(result) {
            var code2 = "";
            code2 += "if(_counter > 0) {\n";
            code2 += onResult(i2, result, done, doneBreak);
            code2 += "}\n";
            return code2;
          },
          onDone: !onResult && function() {
            return done();
          },
          rethrowIfPossible
        });
      }, done, doneBreak);
    };
    for (var i = 0; i < this.options.taps.length; i++) {
      _loop2(i);
    }
    code += "} while(false);\n";
    return code;
  };
  _proto.args = function args(_temp) {
    var _ref5 = _temp === void 0 ? {} : _temp, before = _ref5.before, after = _ref5.after;
    var allArgs = this._args;
    if (before)
      allArgs = [before].concat(allArgs);
    if (after)
      allArgs = allArgs.concat(after);
    if (allArgs.length === 0) {
      return "";
    } else {
      return allArgs.join(", ");
    }
  };
  _proto.getTapFn = function getTapFn(idx) {
    return "_x[" + idx + "]";
  };
  _proto.getTap = function getTap(idx) {
    return "_taps[" + idx + "]";
  };
  _proto.getInterceptor = function getInterceptor(idx) {
    return "_interceptors[" + idx + "]";
  };
  return HookCodeFactory2;
}();
var AsyncParallelHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(AsyncParallelHookCodeFactory2, _HookCodeFactory);
  function AsyncParallelHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncParallelHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError, onDone = _ref.onDone;
    return this.callTapsParallel({
      onError: function onError(i, err, done, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onDone
    });
  };
  return AsyncParallelHookCodeFactory2;
}(HookCodeFactory);
var factory = new AsyncParallelHookCodeFactory();
var COMPILE = function COMPILE2(options) {
  factory.setup(this, options);
  return factory.create(options);
};
var AsyncParallelHook = function(_Hook) {
  _inheritsLoose(AsyncParallelHook2, _Hook);
  function AsyncParallelHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.compile = COMPILE;
    _this2._call = void 0;
    _this2.call = void 0;
    return _this2;
  }
  return AsyncParallelHook2;
}(Hook);
var AsyncSeriesWaterfallHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(AsyncSeriesWaterfallHookCodeFactory2, _HookCodeFactory);
  function AsyncSeriesWaterfallHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncSeriesWaterfallHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _this2 = this;
    var _onError = _ref.onError, onResult = _ref.onResult, onDone = _ref.onDone;
    return this.callTapsSeries({
      onError: function onError(i, err, next, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onResult: function onResult2(i, result, next) {
        var code = "";
        code += "if(" + result + " !== undefined) {\n";
        code += _this2._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone2() {
        return onResult(_this2._args[0]);
      }
    });
  };
  return AsyncSeriesWaterfallHookCodeFactory2;
}(HookCodeFactory);
var factory$1 = new AsyncSeriesWaterfallHookCodeFactory();
var COMPILE$1 = function COMPILE3(options) {
  factory$1.setup(this, options);
  return factory$1.create(options);
};
var AsyncSeriesWaterfallHook = function(_Hook) {
  _inheritsLoose(AsyncSeriesWaterfallHook2, _Hook);
  function AsyncSeriesWaterfallHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.compile = COMPILE$1;
    _this2._call = void 0;
    _this2.call = void 0;
    return _this2;
  }
  return AsyncSeriesWaterfallHook2;
}(Hook);
var SyncHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(SyncHookCodeFactory2, _HookCodeFactory);
  function SyncHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError, onDone = _ref.onDone, rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onDone,
      rethrowIfPossible
    });
  };
  return SyncHookCodeFactory2;
}(HookCodeFactory);
var factory$2 = new SyncHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC2() {
  throw new Error("tapAsync is not supported on a SyncHook");
};
var TAP_PROMISE = function TAP_PROMISE2() {
  throw new Error("tapPromise is not supported on a SyncHook");
};
var COMPILE$2 = function COMPILE4(options) {
  factory$2.setup(this, options);
  return factory$2.create(options);
};
var SyncHook = function(_Hook) {
  _inheritsLoose(SyncHook2, _Hook);
  function SyncHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.tapAsync = TAP_ASYNC;
    _this2.tapPromise = TAP_PROMISE;
    _this2.compile = COMPILE$2;
    return _this2;
  }
  return SyncHook2;
}(Hook);
var SyncWaterfallHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(SyncWaterfallHookCodeFactory2, _HookCodeFactory);
  function SyncWaterfallHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncWaterfallHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _this2 = this;
    var _onError = _ref.onError, onResult = _ref.onResult, resultReturns = _ref.resultReturns, rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onResult: function onResult2(i, result, next) {
        var code = "";
        code += "if(" + result + " !== undefined) {\n";
        code += _this2._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone() {
        return onResult(_this2._args[0]);
      },
      doneReturns: resultReturns,
      rethrowIfPossible
    });
  };
  return SyncWaterfallHookCodeFactory2;
}(HookCodeFactory);
var factory$3 = new SyncWaterfallHookCodeFactory();
var TAP_ASYNC$1 = function TAP_ASYNC3() {
  throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
var TAP_PROMISE$1 = function TAP_PROMISE3() {
  throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
var COMPILE$3 = function COMPILE5(options) {
  factory$3.setup(this, options);
  return factory$3.create(options);
};
var SyncWaterfallHook = function(_SyncHook) {
  _inheritsLoose(SyncWaterfallHook2, _SyncHook);
  function SyncWaterfallHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _SyncHook.call(this, args, name) || this;
    _this2.tapAsync = TAP_ASYNC$1;
    _this2.tapPromise = TAP_PROMISE$1;
    _this2.compile = COMPILE$3;
    return _this2;
  }
  return SyncWaterfallHook2;
}(SyncHook);
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function toFontString(attributes) {
  var fontSize = attributes.fontSize, fontFamily = attributes.fontFamily, fontStyle = attributes.fontStyle, fontVariant = attributes.fontVariant, fontWeight = attributes.fontWeight;
  var fontSizeString = is_number_default(fontSize) && fontSize + "px" || "16px";
  var fontFamilies = is_string_default(fontFamily) ? fontFamily.split(",") : [fontFamily];
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    var _fontFamily = fontFamilies[i].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"' + _fontFamily + '"';
    }
    fontFamilies[i] = _fontFamily;
  }
  return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = typeof self === "object" && self.self == self ? self : (
  // @ts-ignore
  typeof global === "object" && global.global == global ? (
    // @ts-ignore
    global
  ) : {}
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id2 = uniqueId();
  reservedCBs[id2] = callback;
  if (Object.keys(reservedCBs).length > 1)
    return id2;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id2;
};
var polyfillCaf = function polyfillCaf2(id2) {
  delete reservedCBs[id2];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillRaf;
  if (vp2 === "")
    return root["requestAnimationFrame"];
  return root[vp2 + "RequestAnimationFrame"];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillCaf;
  if (vp2 === "")
    return root["cancelAnimationFrame"];
  return root[vp2 + "CancelAnimationFrame"] || root[vp2 + "CancelRequestAnimationFrame"];
};
var find = function find2(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i]))
      return arr[i];
    i = i + 1;
  }
};
var vp = find(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length14 = colorStops.length;
  colorStops[length14 - 1].length = (_colorStops$length = colorStops[length14 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length14 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length14; i++) {
    var _colorStops$i$length;
    var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!is_nil_default(offset) && !is_nil_default(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++) {
        colorStops[previousIndex + j].length = {
          type: "%",
          value: "" + (previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
        };
      }
      previousIndex = i;
      previousOffset = Number(offset);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize(function(orientation) {
  var angle3;
  if (orientation.type === "angular") {
    angle3 = Number(orientation.value);
  } else {
    angle3 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle3, "deg");
});
var positonToCSSUnitValue = memoize(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _position$value = position.value, x = _position$value.x, y = _position$value.y;
    if ((x === null || x === void 0 ? void 0 : x.type) === "position-keyword") {
      if (x.value === "left") {
        cx = 0;
      } else if (x.value === "center") {
        cx = 50;
      } else if (x.value === "right") {
        cx = 100;
      } else if (x.value === "top") {
        cy = 0;
      } else if (x.value === "bottom") {
        cy = 100;
      }
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === "position-keyword") {
      if (y.value === "left") {
        cx = 0;
      } else if (y.value === "center") {
        cy = 50;
      } else if (y.value === "right") {
        cx = 100;
      } else if (y.value === "top") {
        cy = 0;
      } else if (y.value === "bottom") {
        cy = 100;
      }
    }
    if ((x === null || x === void 0 ? void 0 : x.type) === "px" || (x === null || x === void 0 ? void 0 : x.type) === "%" || (x === null || x === void 0 ? void 0 : x.type) === "em") {
      unitX = x === null || x === void 0 ? void 0 : x.type;
      cx = Number(x.value);
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === "px" || (y === null || y === void 0 ? void 0 : y.type) === "%" || (y === null || y === void 0 ? void 0 : y.type) === "em") {
      unitY = y === null || y === void 0 ? void 0 : y.type;
      cy = Number(y.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient$1 = memoize(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      } else if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size2;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size2 = getOrCreateKeyword(value);
            } else {
              size2 = getOrCreateUnitValue(value, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size2,
            steps: steps2
          });
        }
      }
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var offset = _ref2[0], color2 = _ref2[1];
            return {
              offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
              color: color2
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (is_string_default(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref3) {
        var offset = _ref3[0], color2 = _ref3[1];
        return {
          offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
          color: color2
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return is_object_default(object) && !!object.image;
}
function isCSSRGB(object) {
  return is_object_default(object) && !is_nil_default(object.r) && !is_nil_default(object.g) && !is_nil_default(object.b);
}
var parseColor = memoize(function(colorStr) {
  if (isPattern(colorStr)) {
    return _extends({
      repetition: "repeat"
    }, colorStr);
  }
  if (is_nil_default(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  } else if (colorStr === "currentColor") {
    colorStr = "black";
  }
  var g = parseGradient$1(colorStr);
  if (g) {
    return g;
  }
  var color$1 = color(colorStr);
  var rgba2 = [0, 0, 0, 0];
  if (color$1 !== null) {
    rgba2[0] = color$1.r || 0;
    rgba2[1] = color$1.g || 0;
    rgba2[2] = color$1.b || 0;
    rgba2[3] = color$1.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba2);
});
function mergeColors(left, right) {
  if (!isCSSRGB(left) || !isCSSRGB(right)) {
    return;
  }
  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color2) {
    var rgba2 = color2.slice();
    if (rgba2[3]) {
      for (var i = 0; i < 3; i++) {
        rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
      }
    }
    rgba2[3] = clamp_default(rgba2[3], 0, 1);
    return "rgba(" + rgba2.join(",") + ")";
  }];
}
var AABB = function() {
  AABB2.isEmpty = function isEmpty(aabb) {
    return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
  };
  function AABB2(center, halfExtents) {
    if (center === void 0) {
      center = [0, 0, 0];
    }
    if (halfExtents === void 0) {
      halfExtents = [0, 0, 0];
    }
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
    this.update(center, halfExtents);
  }
  var _proto = AABB2.prototype;
  _proto.update = function update(center, halfExtents) {
    copyVec3(this.center, center);
    copyVec3(this.halfExtents, halfExtents);
    subVec3(this.min, this.center, this.halfExtents);
    addVec3(this.max, this.center, this.halfExtents);
  };
  _proto.setMinMax = function setMinMax(min4, max4) {
    addVec3(this.center, max4, min4);
    scaleVec3(this.center, this.center, 0.5);
    subVec3(this.halfExtents, max4, min4);
    scaleVec3(this.halfExtents, this.halfExtents, 0.5);
    copyVec3(this.min, min4);
    copyVec3(this.max, max4);
  };
  _proto.getMin = function getMin() {
    return this.min;
  };
  _proto.getMax = function getMax() {
    return this.max;
  };
  _proto.add = function add7(aabb) {
    if (AABB2.isEmpty(aabb)) {
      return;
    }
    if (AABB2.isEmpty(this)) {
      this.setMinMax(aabb.getMin(), aabb.getMax());
      return;
    }
    var tc = this.center;
    var tcx = tc[0];
    var tcy = tc[1];
    var tcz = tc[2];
    var th = this.halfExtents;
    var thx = th[0];
    var thy = th[1];
    var thz = th[2];
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = aabb.center;
    var ocx = oc[0];
    var ocy = oc[1];
    var ocz = oc[2];
    var oh = aabb.halfExtents;
    var ohx = oh[0];
    var ohy = oh[1];
    var ohz = oh[2];
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;
    if (ominx < tminx) {
      tminx = ominx;
    }
    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }
    if (ominy < tminy) {
      tminy = ominy;
    }
    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }
    if (ominz < tminz) {
      tminz = ominz;
    }
    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }
    tc[0] = (tminx + tmaxx) * 0.5;
    tc[1] = (tminy + tmaxy) * 0.5;
    tc[2] = (tminz + tmaxz) * 0.5;
    th[0] = (tmaxx - tminx) * 0.5;
    th[1] = (tmaxy - tminy) * 0.5;
    th[2] = (tmaxz - tminz) * 0.5;
    this.min[0] = tminx;
    this.min[1] = tminy;
    this.min[2] = tminz;
    this.max[0] = tmaxx;
    this.max[1] = tmaxy;
    this.max[2] = tmaxz;
  };
  _proto.setFromTransformedAABB = function setFromTransformedAABB(aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center;
    var ar = aabb.halfExtents;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
    bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
    bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
    br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
    br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
    br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
    subVec3(this.min, bc, br);
    addVec3(this.max, bc, br);
  };
  _proto.intersects = function intersects(aabb) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = aabb.getMax();
    var bMin = aabb.getMin();
    return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
  };
  _proto.intersection = function intersection(aabb) {
    if (!this.intersects(aabb)) {
      return null;
    }
    var intersection2 = new AABB2();
    var min4 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
    var max4 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
    intersection2.setMinMax(min4, max4);
    return intersection2;
  };
  _proto.getNegativeFarPoint = function getNegativeFarPoint(plane) {
    if (plane.pnVertexFlag === 273) {
      return copyVec3([0, 0, 0], this.min);
    } else if (plane.pnVertexFlag === 272) {
      return [this.min[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 257) {
      return [this.min[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 256) {
      return [this.min[0], this.max[1], this.max[2]];
    } else if (plane.pnVertexFlag === 17) {
      return [this.max[0], this.min[1], this.min[2]];
    } else if (plane.pnVertexFlag === 16) {
      return [this.max[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 1) {
      return [this.max[0], this.max[1], this.min[2]];
    } else {
      return [this.max[0], this.max[1], this.max[2]];
    }
  };
  _proto.getPositiveFarPoint = function getPositiveFarPoint(plane) {
    if (plane.pnVertexFlag === 273) {
      return copyVec3([0, 0, 0], this.max);
    } else if (plane.pnVertexFlag === 272) {
      return [this.max[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 257) {
      return [this.max[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 256) {
      return [this.max[0], this.min[1], this.min[2]];
    } else if (plane.pnVertexFlag === 17) {
      return [this.min[0], this.max[1], this.max[2]];
    } else if (plane.pnVertexFlag === 16) {
      return [this.min[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 1) {
      return [this.min[0], this.min[1], this.max[2]];
    } else {
      return [this.min[0], this.min[1], this.min[2]];
    }
  };
  return AABB2;
}();
var Plane = function() {
  function Plane2(distance6, normal) {
    this.distance = void 0;
    this.normal = void 0;
    this.pnVertexFlag = void 0;
    this.distance = distance6 || 0;
    this.normal = normal || vec3_exports.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  var _proto = Plane2.prototype;
  _proto.updatePNVertexFlag = function updatePNVertexFlag() {
    this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
  };
  _proto.distanceToPoint = function distanceToPoint(point) {
    return vec3_exports.dot(point, this.normal) - this.distance;
  };
  _proto.normalize = function normalize6() {
    var invLen = 1 / vec3_exports.len(this.normal);
    vec3_exports.scale(this.normal, this.normal, invLen);
    this.distance *= invLen;
  };
  _proto.intersectsLine = function intersectsLine(start, end, point) {
    var d0 = this.distanceToPoint(start);
    var d1 = this.distanceToPoint(end);
    var t = d0 / (d0 - d1);
    var intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      vec3_exports.lerp(point, start, end, t);
    }
    return intersects;
  };
  return Plane2;
}();
var Mask;
(function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
})(Mask || (Mask = {}));
var Frustum = function() {
  function Frustum2(planes) {
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i = 0; i < 6; i++) {
        this.planes.push(new Plane());
      }
    }
  }
  var _proto = Frustum2.prototype;
  _proto.extractFromVPMatrix = function extractFromVPMatrix(projectionMatrix) {
    var m0 = projectionMatrix[0], m1 = projectionMatrix[1], m2 = projectionMatrix[2], m3 = projectionMatrix[3], m4 = projectionMatrix[4], m5 = projectionMatrix[5], m6 = projectionMatrix[6], m7 = projectionMatrix[7], m8 = projectionMatrix[8], m9 = projectionMatrix[9], m10 = projectionMatrix[10], m11 = projectionMatrix[11], m12 = projectionMatrix[12], m13 = projectionMatrix[13], m14 = projectionMatrix[14], m15 = projectionMatrix[15];
    vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
    this.planes[0].distance = m15 - m12;
    vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
    this.planes[1].distance = m15 + m12;
    vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
    this.planes[2].distance = m15 + m13;
    vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
    this.planes[3].distance = m15 - m13;
    vec3_exports.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
    this.planes[4].distance = m15 - m14;
    vec3_exports.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
    this.planes[5].distance = m15 + m14;
    this.planes.forEach(function(plane) {
      plane.normalize();
      plane.updatePNVertexFlag();
    });
  };
  return Frustum2;
}();
var Point = function() {
  function Point2(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point2.prototype;
  _proto.clone = function clone7() {
    return new Point2(this.x, this.y);
  };
  _proto.copyFrom = function copyFrom(p) {
    this.x = p.x;
    this.y = p.y;
  };
  return Point2;
}();
var Rectangle = function() {
  function Rectangle2(x, y, width, height) {
    this.x = void 0;
    this.y = void 0;
    this.width = void 0;
    this.height = void 0;
    this.left = void 0;
    this.right = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.left = x;
    this.right = x + width;
    this.top = y;
    this.bottom = y + height;
  }
  var _proto = Rectangle2.prototype;
  _proto.toJSON = function toJSON() {
  };
  return Rectangle2;
}();
function parseDimension(unitRegExp, string) {
  if (is_nil_default(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = ("" + string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    } else if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U" + match;
  });
  var taggedUnitRegExp = "U(" + unitRegExp.source + ")";
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U" + unit, "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLength = memoize(function(css) {
  return parseDimension(new RegExp("px", "g"), css);
});
var parserPercentage = memoize(function(css) {
  return parseDimension(new RegExp("%", "g"), css);
});
var parseLengthOrPercentage = function parseLengthOrPercentage2(css) {
  if (is_number_default(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css), "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseAngle = memoize(function(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
});
function mergeDimensions(left, right, target, nonNegative, index) {
  if (index === void 0) {
    index = 0;
  }
  var unit = "";
  var leftValue = left.value || 0;
  var rightValue = right.value || 0;
  var canonicalUnit = toCanonicalUnit(left.unit);
  var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left.unit);
  } else {
    if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
      leftValue = convertPercentUnit(left, index, target);
      rightValue = convertPercentUnit(right, index, target);
      unit = "px";
    }
  }
  return [leftValue, rightValue, function(value) {
    if (nonNegative) {
      value = Math.max(value, 0);
    }
    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg2 = 0;
  if (value.unit === UnitType.kDegrees) {
    deg2 = value.value;
  } else if (value.unit === UnitType.kRadians) {
    deg2 = rad2deg2(Number(value.value));
  } else if (value.unit === UnitType.kTurns) {
    deg2 = turn2deg(Number(value.value));
  }
  return deg2;
}
function parseDimensionArrayFormat(string, size2) {
  var parsed;
  if (is_string_default(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (is_number_default(string)) {
    parsed = [string];
  } else {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  }
  if (size2 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    } else {
      return [parsed[0], parsed[1]];
    }
  } else {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
  }
}
function parseDimensionArray(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(function(segment) {
      return parseLengthOrPercentage(segment);
    });
  } else {
    return string.map(function(segment) {
      return parseLengthOrPercentage(segment.toString());
    });
  }
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    var size2 = 0;
    if (!AABB.isEmpty(bounds)) {
      size2 = bounds.halfExtents[vec3Index] * 2;
    }
    return Number(valueWithUnit.value) / 100 * size2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter(filterStr) {
  if (filterStr === void 0) {
    filterStr = "";
  }
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(" ").map(function(p) {
          return parseParam(p) || parseColor(p);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x) {
  return x.toString();
}
var parseNumber = memoize(function(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  } else {
    return getOrCreateUnitValue(0);
  }
});
var parseNumberList = memoize(function(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(parseNumber);
  } else {
    return string.map(parseNumber);
  }
});
function mergeNumbers(left, right) {
  return [left, right, numberToString];
}
function clampedMergeNumbers(min4, max4) {
  return function(left, right) {
    return [left, right, function(x) {
      return numberToString(clamp_default(x, min4, max4));
    }];
  };
}
function mergeNumberLists(left, right) {
  if (left.length !== right.length) {
    return;
  }
  return [left, right, function(numberList) {
    return numberList;
  }];
}
var internalParsePath = function internalParsePath2(path) {
  if (path === "" || Array.isArray(path) && path.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path);
  } catch (e2) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: " + path);
  }
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox2(segments, 0), x = _getPathBBox.x, y = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x) ? x : 0,
      y: Number.isFinite(y) ? y : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize(internalParsePath);
function parsePath(path, object) {
  var result = is_string_default(path) ? memoizedParsePath(path) : internalParsePath(path);
  if (object) {
    object.parsedStyle.defX = result.rect.x;
    object.parsedStyle.defY = result.rect.y;
  }
  return result;
}
function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left.absolutePath, false);
    left.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right.absolutePath, false);
    right.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (is_string_default(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), x = _pointStr$split[0], y = _pointStr$split[1];
      return [Number(x), Number(y)];
    });
  } else {
    points = pointsOrStr;
  }
  var segments = [];
  var tempLength = 0;
  var segmentT;
  var segmentL;
  var totalLength = polyline.length(points);
  points.forEach(function(p, i) {
    if (points[i + 1]) {
      segmentT = [0, 0];
      segmentT[0] = tempLength / totalLength;
      segmentL = line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
      tempLength += segmentL;
      segmentT[1] = tempLength / totalLength;
      segments.push(segmentT);
    }
  });
  var minX = Math.min.apply(Math, points.map(function(point) {
    return point[0];
  }));
  var minY = Math.min.apply(Math, points.map(function(point) {
    return point[1];
  }));
  if (object) {
    object.parsedStyle.defX = minX;
    object.parsedStyle.defY = minY;
  }
  return {
    points,
    totalLength,
    segments
  };
}
var _ = null;
function cast(pattern) {
  return function(contents) {
    var i = 0;
    return pattern.map(function(x) {
      return x === _ ? contents[i++] : x;
    });
  };
}
function id(x) {
  return x;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotatex: ["A"],
  rotatey: ["A"],
  rotatez: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scalex: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaley: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scalez: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewx: ["A", null, cast([_, Odeg])],
  skewy: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translatex: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translatey: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translatez: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseTransform(string) {
  string = (string || "none").toLowerCase().trim();
  if (string === "none") {
    return [];
  }
  var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = transformRegExp.exec(string)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A4(s2) {
            return s2.trim() === "0" ? Odeg : parseAngle(s2);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (transformRegExp.lastIndex === string.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x;
  var y;
  var z;
  var angle3;
  switch (item.t) {
    case "rotatex":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotatey":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), 0, -Math.sin(angle3), 0, 0, 1, 0, 0, Math.sin(angle3), 0, Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotatez":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x = item.d[0].value;
      y = item.d[1].value;
      z = item.d[2].value;
      angle3 = deg2rad2(convertAngleUnit(item.d[3]));
      var sqrLength = x * x + y * y + z * z;
      if (sqrLength === 0) {
        x = 1;
        y = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length14 = Math.sqrt(sqrLength);
        x /= length14;
        y /= length14;
        z /= length14;
      }
      var s2 = Math.sin(angle3 / 2);
      var sc = s2 * Math.cos(angle3 / 2);
      var sq = s2 * s2;
      return [1 - 2 * (y * y + z * z) * sq, 2 * (x * y * sq + z * sc), 2 * (x * z * sq - y * sc), 0, 2 * (x * y * sq - z * sc), 1 - 2 * (x * x + z * z) * sq, 2 * (y * z * sq + x * sc), 0, 2 * (x * z * sq + y * sc), 2 * (y * z * sq - x * sc), 1 - 2 * (x * x + y * y) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scalex":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaley":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scalez":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad2(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad2(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewx":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle3), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewy":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle3), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, 0, 1];
    case "translatex":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
    case "translatey":
      y = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
    case "translatez":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d4) {
        return d4.value;
      });
  }
}
function multiplyMatrices(a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate3 = [0, 0, 0];
  var scale8 = [1, 1, 1];
  var skew = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(convertToMatrix(transformList), translate3, scale8, skew, perspective2, quaternion);
  return [[translate3, scale8, skew, quaternion, perspective2]];
}
var composeMatrix = function() {
  function multiply7(a, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k = 0; k < 4; k++) {
          result[i][j] += b[i][k] * a[k][j];
        }
      }
    }
    return result;
  }
  function is2D(m) {
    return m[0][2] == 0 && m[0][3] == 0 && m[1][2] == 0 && m[1][3] == 0 && m[2][0] == 0 && m[2][1] == 0 && m[2][2] == 1 && m[2][3] == 0 && m[3][2] == 0 && m[3][3] == 1;
  }
  function composeMatrix2(translate3, scale8, skew, quat2, perspective2) {
    var matrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i = 0; i < 4; i++) {
      matrix[i][3] = perspective2[i];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix[3][_i] += translate3[j] * matrix[j][_i];
      }
    }
    var x = quat2[0], y = quat2[1], z = quat2[2], w = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y * y + z * z);
    rotMatrix[0][1] = 2 * (x * y - z * w);
    rotMatrix[0][2] = 2 * (x * z + y * w);
    rotMatrix[1][0] = 2 * (x * y + z * w);
    rotMatrix[1][1] = 1 - 2 * (x * x + z * z);
    rotMatrix[1][2] = 2 * (y * z - x * w);
    rotMatrix[2][0] = 2 * (x * z - y * w);
    rotMatrix[2][1] = 2 * (y * z + x * w);
    rotMatrix[2][2] = 1 - 2 * (x * x + y * y);
    matrix = multiply7(matrix, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew[2]) {
      temp[2][1] = skew[2];
      matrix = multiply7(matrix, temp);
    }
    if (skew[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew[0];
      matrix = multiply7(matrix, temp);
    }
    if (skew[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew[0];
      matrix = multiply7(matrix, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix[_i2][_j] *= scale8[_i2];
      }
    }
    if (is2D(matrix)) {
      return [matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1], matrix[3][0], matrix[3][1]];
    }
    return matrix[0].concat(matrix[1], matrix[2], matrix[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x) {
  return x.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left, right) {
  var leftArgs;
  var rightArgs;
  if (left.decompositionPair !== right) {
    left.decompositionPair = right;
    leftArgs = makeMatrixDecomposition(left);
  }
  if (right.decompositionPair !== left) {
    right.decompositionPair = left;
    rightArgs = makeMatrixDecomposition(right);
  }
  if (leftArgs[0] === null || rightArgs[0] === null)
    return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x) {
        return x ? right[0].d : left[0].d;
      }
    ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result = 0;
  for (var i = 0; i < v1.length; i++) {
    result += v1[i] * v2[i];
  }
  return result;
}
function quat(fromQ, toQ, f) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[xy]/, "");
}
function typeTo3D(type) {
  return type.replace(/(x|y|z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left, right, target) {
  var flipResults = false;
  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }
    var _loop = function _loop2(i2) {
      var _left$i = left[i2], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i = 0; i < left.length; i++) {
      _loop(i);
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left.length !== right.length) {
    var merged = mergeMatrices(left, right);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left.length; _i3++) {
      var leftType = left[_i3].t;
      var rightType = right[_i3].t;
      var leftArgs = left[_i3].d;
      var rightArgs = right[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left, right);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list) {
    return list.map(function(args, i2) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i2][1][j2](arg);
      }).join(",");
      if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i2][0] = "matrix3d";
      }
      if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i2][0] = "matrix";
      }
      return types[i2][0] + "(" + stringifiedArgs + ")";
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize(function(value) {
  if (is_string_default(value)) {
    if (value === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values = value.split(" ");
    if (values.length === 1) {
      if (values[0] === "top" || values[0] === "bottom") {
        values[1] = values[0];
        values[0] = "center";
      } else {
        values[1] = "center";
      }
    }
    if (values.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
  } else {
    return [getOrCreateUnitValue(value[0] || 0, "px"), getOrCreateUnitValue(value[1] || 0, "px")];
  }
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  } else if (keyword === "left" || keyword === "top") {
    return "0";
  } else if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var CSSPropertyAngle = function() {
  function CSSPropertyAngle2() {
    this.parser = parseAngle;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyAngle2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    return convertAngleUnit(parsed);
  };
  return CSSPropertyAngle2;
}();
var CSSPropertyClipPath = function() {
  function CSSPropertyClipPath2() {
  }
  var _proto = CSSPropertyClipPath2.prototype;
  _proto.calculator = function calculator(name, oldPath, newPath, object) {
    if (newPath instanceof CSSKeywordValue) {
      newPath = null;
    }
    runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
    if (name === "clipPath") {
      object.forEach(function(leaf) {
        if (leaf.childNodes.length === 0) {
          runtime.sceneGraphService.dirtifyToRoot(leaf);
        }
      });
    }
    return newPath;
  };
  return CSSPropertyClipPath2;
}();
var CSSPropertyColor = function() {
  function CSSPropertyColor2() {
    this.parser = parseColor;
    this.parserWithCSSDisabled = parseColor;
    this.mixer = mergeColors;
  }
  var _proto = CSSPropertyColor2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      return parsed.value === "none" ? noneColor : transparentColor;
    }
    return parsed;
  };
  return CSSPropertyColor2;
}();
var CSSPropertyFilter = function() {
  function CSSPropertyFilter2() {
    this.parser = parseFilter;
  }
  var _proto = CSSPropertyFilter2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  return CSSPropertyFilter2;
}();
function getFontSize(object) {
  var fontSize = object.parsedStyle.fontSize;
  return is_nil_default(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = function() {
  function CSSPropertyLengthOrPercentage2() {
    this.parser = parseLengthOrPercentage;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyLengthOrPercentage2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed, object, registry) {
    if (is_number_default(computed)) {
      return computed;
    }
    if (CSSUnitValue.isRelativeUnit(computed.unit)) {
      if (computed.unit === UnitType.kPercentage) {
        return 0;
      } else if (computed.unit === UnitType.kEms) {
        if (object.parentNode) {
          var fontSize = getFontSize(object.parentNode);
          if (fontSize) {
            fontSize *= computed.value;
            return fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      } else if (computed.unit === UnitType.kRems) {
        var _object$ownerDocument;
        if (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.documentElement) {
          var _fontSize = getFontSize(object.ownerDocument.documentElement);
          if (_fontSize) {
            _fontSize *= computed.value;
            return _fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      }
    } else {
      return computed.value;
    }
  };
  return CSSPropertyLengthOrPercentage2;
}();
var CSSPropertyLengthOrPercentage12 = function() {
  function CSSPropertyLengthOrPercentage122() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage122.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
    var formatted;
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0]];
    } else {
      formatted = [parsed[0], parsed[1]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function(c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage122;
}();
var CSSPropertyLengthOrPercentage14 = function() {
  function CSSPropertyLengthOrPercentage142() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage142.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
    var formatted;
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function(c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage142;
}();
var CSSPropertyLocalPosition = function(_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyLocalPosition2, _CSSPropertyLengthOrP);
  function CSSPropertyLocalPosition2() {
    return _CSSPropertyLengthOrP.apply(this, arguments) || this;
  }
  var _proto = CSSPropertyLocalPosition2.prototype;
  _proto.postProcessor = function postProcessor(object, attributes) {
    var x;
    var y;
    var z;
    switch (object.nodeName) {
      case Shape.CIRCLE:
      case Shape.ELLIPSE:
        var _object$parsedStyle = object.parsedStyle, cx = _object$parsedStyle.cx, cy = _object$parsedStyle.cy;
        if (!is_nil_default(cx)) {
          x = cx;
        }
        if (!is_nil_default(cy)) {
          y = cy;
        }
        break;
      case Shape.LINE:
        var _object$parsedStyle2 = object.parsedStyle, x1 = _object$parsedStyle2.x1, x2 = _object$parsedStyle2.x2, y1 = _object$parsedStyle2.y1, y2 = _object$parsedStyle2.y2;
        var minX = Math.min(x1, x2);
        var minY = Math.min(y1, y2);
        x = minX;
        y = minY;
        z = 0;
        break;
      case Shape.RECT:
      case Shape.IMAGE:
      case Shape.GROUP:
      case Shape.HTML:
      case Shape.TEXT:
      case Shape.MESH:
        if (!is_nil_default(object.parsedStyle.x)) {
          x = object.parsedStyle.x;
        }
        if (!is_nil_default(object.parsedStyle.y)) {
          y = object.parsedStyle.y;
        }
        break;
    }
    if (object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE && object.nodeName !== Shape.POLYGON) {
      object.parsedStyle.defX = x || 0;
      object.parsedStyle.defY = y || 0;
    }
    var needResetLocalPosition = !is_nil_default(x) || !is_nil_default(y) || !is_nil_default(z);
    if (needResetLocalPosition && attributes.indexOf("transform") === -1) {
      var transform = object.parsedStyle.transform;
      if (transform && transform.length) {
        parsedTransformToMat4(transform, object);
      } else {
        var _object$getLocalPosit = object.getLocalPosition(), ox = _object$getLocalPosit[0], oy = _object$getLocalPosit[1], oz = _object$getLocalPosit[2];
        object.setLocalPosition(is_nil_default(x) ? ox : x, is_nil_default(y) ? oy : y, is_nil_default(z) ? oz : z);
      }
    }
  };
  return CSSPropertyLocalPosition2;
}(CSSPropertyLengthOrPercentage);
var CSSPropertyMarker = function() {
  function CSSPropertyMarker2() {
  }
  var _proto = CSSPropertyMarker2.prototype;
  _proto.calculator = function calculator(name, oldMarker, newMarker, object) {
    var _newMarker;
    if (newMarker instanceof CSSKeywordValue) {
      newMarker = null;
    }
    var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
    if (cloned) {
      cloned.style.isMarker = true;
    }
    return cloned;
  };
  return CSSPropertyMarker2;
}();
var CSSPropertyNumber = function() {
  function CSSPropertyNumber2() {
    this.mixer = mergeNumbers;
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
  }
  var _proto = CSSPropertyNumber2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyNumber2;
}();
var CSSPropertyOffsetDistance = function() {
  function CSSPropertyOffsetDistance2() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOffsetDistance2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
    if (!offsetPath) {
      return;
    }
    var nodeName = offsetPath.nodeName;
    if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
      var point = offsetPath.getPoint(offsetDistance);
      if (point) {
        object.parsedStyle.defX = point.x;
        object.parsedStyle.defY = point.y;
        object.setLocalPosition(point.x, point.y);
      }
    }
  };
  return CSSPropertyOffsetDistance2;
}();
var CSSPropertyOpacity = function() {
  function CSSPropertyOpacity2() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOpacity2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyOpacity2;
}();
var CSSPropertyPath = function() {
  function CSSPropertyPath2() {
    this.parser = parsePath;
    this.parserWithCSSDisabled = parsePath;
    this.mixer = mergePaths;
  }
  var _proto = CSSPropertyPath2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: new Rectangle(0, 0, 0, 0)
      };
    }
    return parsed;
  };
  _proto.postProcessor = function postProcessor(object, attributes) {
    if (object.nodeName === Shape.PATH && attributes.indexOf("transform") === -1) {
      var _object$parsedStyle = object.parsedStyle, _object$parsedStyle$d = _object$parsedStyle.defX, defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d, _object$parsedStyle$d2 = _object$parsedStyle.defY, defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPath2;
}();
var CSSPropertyPoints = function() {
  function CSSPropertyPoints2() {
    this.parser = parsePoints;
  }
  var _proto = CSSPropertyPoints2.prototype;
  _proto.postProcessor = function postProcessor(object, attributes) {
    if ((object.nodeName === Shape.POLYGON || object.nodeName === Shape.POLYLINE) && attributes.indexOf("transform") === -1) {
      var _object$parsedStyle = object.parsedStyle, defX = _object$parsedStyle.defX, defY = _object$parsedStyle.defY;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPoints2;
}();
var CSSPropertyShadowBlur = function(_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  function CSSPropertyShadowBlur2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _CSSPropertyLengthOrP.call.apply(_CSSPropertyLengthOrP, [this].concat(args)) || this;
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  return CSSPropertyShadowBlur2;
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = function() {
  function CSSPropertyText2() {
  }
  var _proto = CSSPropertyText2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      if (parsed.value === "unset") {
        return "";
      } else {
        return parsed.value;
      }
    }
    return "" + parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    object.nodeValue = "" + object.parsedStyle.text || "";
  };
  return CSSPropertyText2;
}();
var CSSPropertyTextTransform = function() {
  function CSSPropertyTextTransform2() {
  }
  var _proto = CSSPropertyTextTransform2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    var rawText = object.getAttribute("text");
    if (rawText) {
      var transformedText = rawText;
      if (parsed.value === "capitalize") {
        transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
      } else if (parsed.value === "lowercase") {
        transformedText = rawText.toLowerCase();
      } else if (parsed.value === "uppercase") {
        transformedText = rawText.toUpperCase();
      }
      object.parsedStyle.text = transformedText;
    }
    return parsed.value;
  };
  return CSSPropertyTextTransform2;
}();
var CSSPropertyTransform = function() {
  function CSSPropertyTransform2() {
    this.parser = parseTransform;
    this.parserWithCSSDisabled = parseTransform;
    this.mixer = mergeTransforms;
  }
  var _proto = CSSPropertyTransform2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    var transform = object.parsedStyle.transform;
    parsedTransformToMat4(transform, object);
  };
  return CSSPropertyTransform2;
}();
var CSSPropertyTransformOrigin = function CSSPropertyTransformOrigin2() {
  this.parser = parseTransformOrigin;
};
var CSSPropertyZIndex = function() {
  function CSSPropertyZIndex2() {
    this.parser = parseNumber;
  }
  var _proto = CSSPropertyZIndex2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed, object) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    if (object.parentNode) {
      var parentEntity = object.parentNode;
      var parentRenderable = parentEntity.renderable;
      var parentSortable = parentEntity.sortable;
      if (parentRenderable) {
        parentRenderable.dirty = true;
      }
      if (parentSortable) {
        parentSortable.dirty = true;
      }
    }
  };
  return CSSPropertyZIndex2;
}();
var CustomElementRegistry = function() {
  function CustomElementRegistry2() {
    this.registry = {};
    this.define(Shape.CIRCLE, Circle);
    this.define(Shape.ELLIPSE, Ellipse);
    this.define(Shape.RECT, Rect);
    this.define(Shape.IMAGE, Image);
    this.define(Shape.LINE, Line);
    this.define(Shape.GROUP, Group);
    this.define(Shape.PATH, Path);
    this.define(Shape.POLYGON, Polygon);
    this.define(Shape.POLYLINE, Polyline);
    this.define(Shape.TEXT, Text);
    this.define(Shape.HTML, HTML);
  }
  var _proto = CustomElementRegistry2.prototype;
  _proto.define = function define2(name, constructor) {
    this.registry[name] = constructor;
  };
  _proto.get = function get(name) {
    return this.registry[name];
  };
  return CustomElementRegistry2;
}();
function isFederatedEvent(value) {
  return !!value.type;
}
var FederatedEvent = function() {
  function FederatedEvent2(manager) {
    this.type = void 0;
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.target = void 0;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.currentTarget = void 0;
    this.defaultPrevented = false;
    this.timeStamp = void 0;
    this.nativeEvent = void 0;
    this.originalEvent = void 0;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.manager = void 0;
    this.detail = void 0;
    this.layer = new Point();
    this.page = new Point();
    this.canvas = new Point();
    this.viewport = new Point();
    this.path = void 0;
    this.view = void 0;
    this.which = void 0;
    this.returnValue = void 0;
    this.srcElement = void 0;
    this.composed = false;
    this.isTrusted = void 0;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  var _proto = FederatedEvent2.prototype;
  _proto.composedPath = function composedPath() {
    if (this.manager && (!this.path || this.path[0] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  };
  _proto.preventDefault = function preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  };
  _proto.stopImmediatePropagation = function stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  };
  _proto.stopPropagation = function stopPropagation() {
    this.propagationStopped = true;
  };
  _proto.initEvent = function initEvent() {
  };
  _proto.initUIEvent = function initUIEvent() {
  };
  _proto.clone = function clone7() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get() {
        return this.type;
      }
    )
    /**
     * The propagation phase.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
     */
  }, {
    key: "layerX",
    get: function get() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get() {
      return this.layer.y;
    }
    /**
     * The coordinates of the event relative to the DOM document.
     * This is a non-standard property.
     * relative to the DOM document.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX
     */
  }, {
    key: "pageX",
    get: function get() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get() {
      return this.page.y;
    }
    /**
     * relative to Canvas, origin is left-top
     */
  }, {
    key: "x",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get() {
      return this.canvas.y;
    }
    /**
     * relative to Viewport, account for Camera
     */
  }, {
    key: "viewportX",
    get: function get() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get() {
      return this.viewport.y;
    }
  }, {
    key: "propagationPath",
    get: function get() {
      return this.composedPath();
    }
  }]);
  return FederatedEvent2;
}();
var CustomEvent = function(_FederatedEvent) {
  _inheritsLoose(CustomEvent2, _FederatedEvent);
  function CustomEvent2(eventName, object) {
    var _this2;
    _this2 = _FederatedEvent.call(this, null) || this;
    _this2.type = eventName;
    _this2.detail = object;
    Object.assign(_assertThisInitialized(_this2), object);
    return _this2;
  }
  return CustomEvent2;
}(FederatedEvent);
var DELEGATION_SPLITTER = ":";
var EventTarget = function() {
  function EventTarget2() {
    this.emitter = new import_eventemitter3.default();
  }
  var _proto = EventTarget2.prototype;
  _proto.on = function on(type, listener, options) {
    this.addEventListener(type, listener, options);
    return this;
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
    var once = is_object_default(options) && options.once;
    var context = isFunction(listener) ? void 0 : listener;
    var useDelegatedName = false;
    var delegatedName = "";
    if (type.indexOf(DELEGATION_SPLITTER) > -1) {
      var _type$split = type.split(DELEGATION_SPLITTER), name = _type$split[0], eventType = _type$split[1];
      type = eventType;
      delegatedName = name;
      useDelegatedName = true;
    }
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : listener.handleEvent;
    if (useDelegatedName) {
      var originListener = listener;
      listener = function listener2() {
        var _args$0$target;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (((_args$0$target = args[0].target) === null || _args$0$target === void 0 ? void 0 : _args$0$target.name) !== delegatedName) {
          return;
        }
        originListener.apply(void 0, args);
      };
    }
    if (once) {
      this.emitter.once(type, listener, context);
    } else {
      this.emitter.on(type, listener, context);
    }
    return this;
  };
  _proto.off = function off(type, listener, options) {
    if (type) {
      this.removeEventListener(type, listener, options);
    } else {
      this.removeAllEventListeners();
    }
    return this;
  };
  _proto.removeAllEventListeners = function removeAllEventListeners() {
    this.emitter.removeAllListeners();
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    var _listener;
    var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
    var context = isFunction(listener) ? void 0 : listener;
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
    this.emitter.off(type, listener, context);
    return this;
  };
  _proto.emit = function emit(eventName, object) {
    this.dispatchEvent(new CustomEvent(eventName, object));
  };
  _proto.dispatchEvent = function dispatchEvent(e2, skipPropagate) {
    if (skipPropagate === void 0) {
      skipPropagate = false;
    }
    if (!isFederatedEvent(e2)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    var canvas;
    if (this.document) {
      canvas = this;
    } else if (this.defaultView) {
      canvas = this.defaultView;
    } else {
      var _this$ownerDocument;
      canvas = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView;
    }
    if (canvas) {
      var _e$manager;
      e2.manager = canvas.getEventService() || null;
      if (!e2.manager) {
        return false;
      }
      e2.defaultPrevented = false;
      e2.path = [];
      if (!skipPropagate) {
        e2.target = this;
      }
      (_e$manager = e2.manager) === null || _e$manager === void 0 ? void 0 : _e$manager.dispatchEvent(e2, e2.type, skipPropagate);
    }
    return !e2.defaultPrevented;
  };
  return EventTarget2;
}();
var Node2 = function(_EventTarget) {
  _inheritsLoose(Node3, _EventTarget);
  function Node3() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.parentNode = null;
    return _this2;
  }
  Node3.isNode = function isNode(target) {
    return !!target.childNodes;
  };
  var _proto = Node3.prototype;
  _proto.getRootNode = function getRootNode(opts) {
    if (opts === void 0) {
      opts = {};
    }
    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }
    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }
    return this;
  };
  _proto.hasChildNodes = function hasChildNodes() {
    return this.childNodes.length > 0;
  };
  _proto.isDefaultNamespace = function isDefaultNamespace(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupNamespaceURI = function lookupNamespaceURI(prefix) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupPrefix = function lookupPrefix(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.normalize = function normalize6() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.isEqualNode = function isEqualNode(otherNode) {
    return this === otherNode;
  };
  _proto.isSameNode = function isSameNode(otherNode) {
    return this.isEqualNode(otherNode);
  };
  _proto.compareDocumentPosition = function compareDocumentPosition(other) {
    if (other === this) {
      return 0;
    }
    if (!(other instanceof Node3)) {
      throw new TypeError("Node.compareDocumentPosition: Argument 1 does not implement interface Node.");
    }
    var node1Root = other;
    var node2Root = this;
    var node1Hierarchy = [node1Root];
    var node2Hierarchy = [node2Root];
    while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
      var _node1Root$parentNode;
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    }
    if (node1Root !== node2Root) {
      return Node3.DOCUMENT_POSITION_DISCONNECTED | Node3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node3.DOCUMENT_POSITION_PRECEDING;
    }
    var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ? (
        // other is a child of this
        Node3.DOCUMENT_POSITION_CONTAINED_BY | Node3.DOCUMENT_POSITION_FOLLOWING
      ) : (
        // this is a child of other
        Node3.DOCUMENT_POSITION_CONTAINS | Node3.DOCUMENT_POSITION_PRECEDING
      );
    }
    var longerStart = longerHierarchy.length - shorterHierarchy.length;
    for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
      var shorterHierarchyNode = shorterHierarchy[i];
      var longerHierarchyNode = longerHierarchy[longerStart + i];
      if (longerHierarchyNode !== shorterHierarchyNode) {
        var siblings = shorterHierarchyNode.parentNode.childNodes;
        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          if (shorterHierarchy === node1Hierarchy) {
            return Node3.DOCUMENT_POSITION_PRECEDING;
          } else {
            return Node3.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          if (longerHierarchy === node1Hierarchy) {
            return Node3.DOCUMENT_POSITION_PRECEDING;
          } else {
            return Node3.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    return Node3.DOCUMENT_POSITION_FOLLOWING;
  };
  _proto.contain = function contain(other) {
    return this.contains(other);
  };
  _proto.contains = function contains(other) {
    var tmp2 = other;
    while (tmp2 && this !== tmp2) {
      tmp2 = tmp2.parentNode;
    }
    return !!tmp2;
  };
  _proto.getAncestor = function getAncestor(n) {
    var temp = this;
    while (n > 0 && temp) {
      temp = temp.parentNode;
      n--;
    }
    return temp;
  };
  _proto.forEach = function forEach4(callback, assigned) {
    if (assigned === void 0) {
      assigned = false;
    }
    if (!callback(this)) {
      (assigned ? this.childNodes.slice() : this.childNodes).forEach(function(child) {
        child.forEach(callback);
      });
    }
  };
  _createClass(Node3, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        for (var _iterator = _createForOfIteratorHelperLoose(this.childNodes), _step; !(_step = _iterator()).done; ) {
          var child = _step.value;
          if (child.nodeName === Shape.TEXT) {
            out += child.nodeValue;
          } else {
            out += child.textContent;
          }
        }
        return out;
      }
    ),
    set: function set7(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "" + content;
      }
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
  }]);
  return Node3;
}(EventTarget);
Node2.DOCUMENT_POSITION_DISCONNECTED = 1;
Node2.DOCUMENT_POSITION_PRECEDING = 2;
Node2.DOCUMENT_POSITION_FOLLOWING = 4;
Node2.DOCUMENT_POSITION_CONTAINS = 8;
Node2.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var Document = function(_Node) {
  _inheritsLoose(Document2, _Node);
  function Document2() {
    var _this2;
    _this2 = _Node.call(this) || this;
    _this2.defaultView = null;
    _this2.documentElement = void 0;
    _this2.timeline = void 0;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_assertThisInitialized(_this2));
    } catch (e2) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n = _ref.n, inh = _ref.inh, d4 = _ref.d;
      if (inh && d4) {
        initialStyle[n] = isFunction(d4) ? d4(Shape.GROUP) : d4;
      }
    });
    _this2.documentElement = new Group({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _assertThisInitialized(_this2);
    _this2.documentElement.parentNode = _assertThisInitialized(_this2);
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  var _proto = Document2.prototype;
  _proto.createElement = function createElement2(tagName, options) {
    if (tagName === "svg") {
      return this.documentElement;
    }
    var clazz = this.defaultView.customElements.get(tagName);
    if (!clazz) {
      console.warn("Unsupported tagName: ", tagName);
      clazz = tagName === "tspan" ? Text : Group;
    }
    var shape = new clazz(options);
    shape.ownerDocument = this;
    return shape;
  };
  _proto.createElementNS = function createElementNS(namespaceURI, tagName, options) {
    return this.createElement(tagName, options);
  };
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.destroy = function destroy() {
    try {
      this.documentElement.destroyChildren();
      this.timeline.destroy();
    } catch (e2) {
    }
  };
  _proto.elementsFromBBox = function elementsFromBBox(minX, minY, maxX, maxY) {
    var rBush = this.defaultView.context.rBushRoot;
    var rBushNodes = rBush.search({
      minX,
      minY,
      maxX,
      maxY
    });
    var hitTestList = [];
    rBushNodes.forEach(function(_ref2) {
      var id2 = _ref2.id;
      var displayObject = runtime.displayObjectPool.getByEntity(id2);
      var pointerEvents = displayObject.parsedStyle.pointerEvents;
      var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
      if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
        hitTestList.push(displayObject);
      }
    });
    hitTestList.sort(function(a, b) {
      return b.sortable.renderOrder - a.sortable.renderOrder;
    });
    return hitTestList;
  };
  _proto.elementFromPointSync = function elementFromPointSync(x, y) {
    var _this$defaultView$can = this.defaultView.canvas2Viewport({
      x,
      y
    }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
    var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return null;
    }
    var _this$defaultView$vie = this.defaultView.viewport2Client({
      x: viewportX,
      y: viewportY
    }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
    var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
      topmost: true,
      position: {
        x,
        y,
        viewportX,
        viewportY,
        clientX,
        clientY
      },
      picked: []
    }), picked = _this$defaultView$get2.picked;
    return picked && picked[0] || this.documentElement;
  };
  _proto.elementFromPoint = function() {
    var _elementFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x, y) {
      var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x,
                y
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", null);
            case 4:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x,
                  y,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function elementFromPoint(_x, _x2) {
      return _elementFromPoint.apply(this, arguments);
    }
    return elementFromPoint;
  }();
  _proto.elementsFromPointSync = function elementsFromPointSync(x, y) {
    var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
      x,
      y
    }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
    var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return [];
    }
    var _this$defaultView$vie3 = this.defaultView.viewport2Client({
      x: viewportX,
      y: viewportY
    }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
    var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
      topmost: false,
      position: {
        x,
        y,
        viewportX,
        viewportY,
        clientX,
        clientY
      },
      picked: []
    }), picked = _this$defaultView$get5.picked;
    if (picked[picked.length - 1] !== this.documentElement) {
      picked.push(this.documentElement);
    }
    return picked;
  };
  _proto.elementsFromPoint = function() {
    var _elementsFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(x, y) {
      var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x,
                y
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", []);
            case 4:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x,
                  y,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function elementsFromPoint(_x3, _x4) {
      return _elementsFromPoint.apply(this, arguments);
    }
    return elementsFromPoint;
  }();
  _proto.appendChild = function appendChild(newChild, index) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.removeChild = function removeChild(oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.append = function append() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.prepend = function prepend() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.getElementById = function getElementById(id2) {
    return this.documentElement.getElementById(id2);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return this.documentElement.getElementsByName(name);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return this.documentElement.getElementsByTagName(tagName);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return this.documentElement.getElementsByClassName(className);
  };
  _proto.querySelector = function querySelector(selectors) {
    return this.documentElement.querySelector(selectors);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return this.documentElement.querySelectorAll(selectors);
  };
  _proto.find = function find3(filter) {
    return this.documentElement.find(filter);
  };
  _proto.findAll = function findAll(filter) {
    return this.documentElement.findAll(filter);
  };
  _createClass(Document2, [{
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
    /**
     * only document has defaultView, points to canvas,
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView
     */
  }]);
  return Document2;
}(Node2);
var Strategy;
(function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
})(Strategy || (Strategy = {}));
var ElementEvent;
(function(ElementEvent2) {
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["RENDER_ORDER_CHANGED"] = "render-order-changed";
  ElementEvent2["CULLED"] = "culled";
})(ElementEvent || (ElementEvent = {}));
var MutationEvent = function(_FederatedEvent) {
  _inheritsLoose(MutationEvent2, _FederatedEvent);
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _this2 = _FederatedEvent.call(this, null) || this;
    _this2.relatedNode = void 0;
    _this2.prevValue = void 0;
    _this2.newValue = void 0;
    _this2.attrName = void 0;
    _this2.attrChange = void 0;
    _this2.prevParsedValue = void 0;
    _this2.newParsedValue = void 0;
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  return MutationEvent2;
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = function(_Node) {
  _inheritsLoose(Element3, _Node);
  function Element3() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _Node.call.apply(_Node, [this].concat(args)) || this;
    _this2.entity = entityCounter++;
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false,
      proxyNodeName: void 0
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      frozen: false,
      // localPosition: vec3.fromValues(0, 0, 0),
      // localRotation: quat.fromValues(0, 0, 0, 1),
      // localScale: vec3.fromValues(1, 1, 1),
      // localTransform: mat4.create(),
      // localSkew: vec2.fromValues(0, 0),
      // position: vec3.fromValues(0, 0, 0),
      // rotation: quat.fromValues(0, 0, 0, 1),
      // scaling: vec3.fromValues(1, 1, 1),
      // worldTransform: mat4.create(),
      // origin: vec3.fromValues(0, 0, 0),
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: mat4_exports.create(),
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: mat4_exports.create(),
      origin: [0, 0, 0]
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      lastSortedIndex: void 0,
      renderOrder: 0
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0
    };
    _this2.rBushNode = {
      aabb: void 0
    };
    _this2.id = void 0;
    _this2.name = void 0;
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.destroyed = false;
    _this2.style = {};
    _this2.computedStyle = runtime.enableCSSParsing ? {
      anchor: unsetKeywordValue,
      opacity: unsetKeywordValue,
      fillOpacity: unsetKeywordValue,
      strokeOpacity: unsetKeywordValue,
      fill: unsetKeywordValue,
      stroke: unsetKeywordValue,
      transform: unsetKeywordValue,
      transformOrigin: unsetKeywordValue,
      visibility: unsetKeywordValue,
      pointerEvents: unsetKeywordValue,
      lineWidth: unsetKeywordValue,
      lineCap: unsetKeywordValue,
      lineJoin: unsetKeywordValue,
      increasedLineWidthForHitTesting: unsetKeywordValue,
      fontSize: unsetKeywordValue,
      fontFamily: unsetKeywordValue,
      fontStyle: unsetKeywordValue,
      fontWeight: unsetKeywordValue,
      fontVariant: unsetKeywordValue,
      textAlign: unsetKeywordValue,
      textBaseline: unsetKeywordValue,
      textTransform: unsetKeywordValue,
      zIndex: unsetKeywordValue,
      filter: unsetKeywordValue,
      shadowType: unsetKeywordValue
    } : null;
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  Element3.isElement = function isElement(target) {
    return !!target.getAttribute;
  };
  var _proto = Element3.prototype;
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.appendChild = function appendChild(child, index) {
    var _this$ownerDocument;
    if (child.destroyed) {
      throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
    }
    runtime.sceneGraphService.attach(child, this, index);
    if ((_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView) {
      this.ownerDocument.defaultView.mountChildren(child);
    }
    insertedEvent.relatedNode = this;
    child.dispatchEvent(insertedEvent);
    return child;
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    if (!refChild) {
      this.appendChild(newChild);
    } else {
      var index = this.childNodes.indexOf(refChild);
      this.appendChild(newChild, index - 1);
    }
    return newChild;
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild) {
    var index = this.childNodes.indexOf(oldChild);
    this.removeChild(oldChild);
    this.appendChild(newChild, index);
    return oldChild;
  };
  _proto.removeChild = function removeChild(child) {
    var _child$ownerDocument;
    removedEvent.relatedNode = this;
    child.dispatchEvent(removedEvent);
    if ((_child$ownerDocument = child.ownerDocument) === null || _child$ownerDocument === void 0 ? void 0 : _child$ownerDocument.defaultView) {
      child.ownerDocument.defaultView.unmountChildren(child);
    }
    runtime.sceneGraphService.detach(child);
    return child;
  };
  _proto.removeChildren = function removeChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      this.removeChild(child);
    }
  };
  _proto.destroyChildren = function destroyChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      if (child.childNodes.length) {
        child.destroyChildren();
      }
      child.destroy();
    }
  };
  _proto.matches = function matches(selector) {
    return runtime.sceneGraphService.matches(selector, this);
  };
  _proto.getElementById = function getElementById(id2) {
    return runtime.sceneGraphService.querySelector("#" + id2, this);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return runtime.sceneGraphService.querySelectorAll('[name="' + name + '"]', this);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return runtime.sceneGraphService.querySelectorAll("." + className, this);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return runtime.sceneGraphService.querySelectorAll(tagName, this);
  };
  _proto.querySelector = function querySelector(selectors) {
    return runtime.sceneGraphService.querySelector(selectors, this);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return runtime.sceneGraphService.querySelectorAll(selectors, this);
  };
  _proto.closest = function closest(selectors) {
    var el = this;
    do {
      if (runtime.sceneGraphService.matches(selectors, el))
        return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  };
  _proto.find = function find3(filter) {
    var _this2 = this;
    var target = null;
    this.forEach(function(object) {
      if (object !== _this2 && filter(object)) {
        target = object;
        return true;
      }
      return false;
    });
    return target;
  };
  _proto.findAll = function findAll(filter) {
    var _this3 = this;
    var objects = [];
    this.forEach(function(object) {
      if (object !== _this3 && filter(object)) {
        objects.push(object);
      }
    });
    return objects;
  };
  _proto.after = function after() {
    var _this4 = this;
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nodes[_key2] = arguments[_key2];
      }
      nodes.forEach(function(node, i) {
        var _this4$parentNode;
        return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index + i + 1);
      });
    }
  };
  _proto.before = function before() {
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nodes[_key3] = arguments[_key3];
      }
      var first = nodes[0], rest = nodes.slice(1);
      this.parentNode.appendChild(first, index);
      first.after.apply(first, rest);
    }
  };
  _proto.replaceWith = function replaceWith() {
    this.after.apply(this, arguments);
    this.remove();
  };
  _proto.append = function append() {
    var _this5 = this;
    for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      nodes[_key4] = arguments[_key4];
    }
    nodes.forEach(function(node) {
      return _this5.appendChild(node);
    });
  };
  _proto.prepend = function prepend() {
    var _this6 = this;
    for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      nodes[_key5] = arguments[_key5];
    }
    nodes.forEach(function(node, i) {
      return _this6.appendChild(node, i);
    });
  };
  _proto.replaceChildren = function replaceChildren() {
    while (this.childNodes.length && this.firstChild) {
      this.removeChild(this.firstChild);
    }
    this.append.apply(this, arguments);
  };
  _proto.remove = function remove() {
    if (this.parentNode) {
      return this.parentNode.removeChild(this);
    }
    return this;
  };
  _proto.destroy = function destroy() {
    this.dispatchEvent(destroyEvent);
    this.remove();
    this.emitter.removeAllListeners();
    this.destroyed = true;
  };
  _proto.getGeometryBounds = function getGeometryBounds() {
    return runtime.sceneGraphService.getGeometryBounds(this);
  };
  _proto.getRenderBounds = function getRenderBounds() {
    return runtime.sceneGraphService.getBounds(this, true);
  };
  _proto.getBounds = function getBounds() {
    return runtime.sceneGraphService.getBounds(this);
  };
  _proto.getLocalBounds = function getLocalBounds() {
    return runtime.sceneGraphService.getLocalBounds(this);
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return runtime.sceneGraphService.getBoundingClientRect(this);
  };
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  };
  _proto.computedStyleMap = function computedStyleMap() {
    return new Map(Object.entries(this.computedStyle));
  };
  _proto.getAttributeNames = function getAttributeNames() {
    return Object.keys(this.attributes);
  };
  _proto.getAttribute = function getAttribute(name) {
    if (isSymbol(name)) {
      return runtime.enableCSSParsing ? null : void 0;
    }
    var value = this.attributes[name];
    if (value === void 0) {
      var attributeName = formatAttributeName(name);
      value = this.attributes[attributeName];
      return runtime.enableCSSParsing ? is_nil_default(value) ? null : value : value;
    } else {
      return value;
    }
  };
  _proto.hasAttribute = function hasAttribute(qualifiedName) {
    return this.getAttributeNames().includes(qualifiedName);
  };
  _proto.hasAttributes = function hasAttributes() {
    return !!this.getAttributeNames().length;
  };
  _proto.removeAttribute = function removeAttribute(attributeName) {
    this.setAttribute(attributeName, null);
    delete this.attributes[attributeName];
  };
  _proto.setAttribute = function setAttribute(attributeName, value, force) {
    this.attributes[attributeName] = value;
  };
  _proto.getAttributeNS = function getAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNode = function getAttributeNode(qualifiedName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNodeNS = function getAttributeNodeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.hasAttributeNS = function hasAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNS = function removeAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNode = function removeAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNS = function setAttributeNS(namespace, qualifiedName, value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNode = function setAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNodeNS = function setAttributeNodeNS(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.toggleAttribute = function toggleAttribute(qualifiedName, force) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(Element3, [{
    key: "className",
    get: (
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set7(className) {
      this.setAttribute("class", className);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get() {
        return this.className.split(" ").filter(function(c) {
          return c !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index - 1] || null;
      }
      return null;
    }
  }]);
  return Element3;
}(Node2);
var FederatedMouseEvent = function(_FederatedEvent) {
  _inheritsLoose(FederatedMouseEvent2, _FederatedEvent);
  function FederatedMouseEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedEvent.call.apply(_FederatedEvent, [this].concat(args)) || this;
    _this2.altKey = void 0;
    _this2.button = void 0;
    _this2.buttons = void 0;
    _this2.ctrlKey = void 0;
    _this2.metaKey = void 0;
    _this2.relatedTarget = void 0;
    _this2.shiftKey = void 0;
    _this2.client = new Point();
    _this2.movement = new Point();
    _this2.offset = new Point();
    _this2.global = new Point();
    _this2.screen = new Point();
    return _this2;
  }
  var _proto = FederatedMouseEvent2.prototype;
  _proto.getModifierState = function getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  };
  _proto.initMouseEvent = function initMouseEvent() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get() {
      return this.client.y;
    }
    /**
     * The movement in this pointer relative to the last `mousemove` event.
     */
  }, {
    key: "movementX",
    get: function get() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get() {
      return this.movement.y;
    }
    /**
     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
     * not supported at the moment.
     */
  }, {
    key: "offsetX",
    get: function get() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get() {
      return this.offset.y;
    }
    /**
     * The pointer coordinates in world space.
     */
  }, {
    key: "globalX",
    get: function get() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get() {
      return this.global.y;
    }
    /**
     * The pointer coordinates in sceen space.
     */
  }, {
    key: "screenX",
    get: function get() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get() {
      return this.screen.y;
    }
  }]);
  return FederatedMouseEvent2;
}(FederatedEvent);
var FederatedPointerEvent = function(_FederatedMouseEvent) {
  _inheritsLoose(FederatedPointerEvent2, _FederatedMouseEvent);
  function FederatedPointerEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this2.pointerId = void 0;
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    _this2.pointerType = void 0;
    _this2.pressure = void 0;
    _this2.tangentialPressure = void 0;
    _this2.tiltX = void 0;
    _this2.tiltY = void 0;
    _this2.twist = void 0;
    return _this2;
  }
  var _proto = FederatedPointerEvent2.prototype;
  _proto.getCoalescedEvents = function getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  };
  _proto.getPredictedEvents = function getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  };
  _proto.clone = function clone7() {
    return this.manager.clonePointerEvent(this);
  };
  return FederatedPointerEvent2;
}(FederatedMouseEvent);
var FederatedWheelEvent = function(_FederatedMouseEvent) {
  _inheritsLoose(FederatedWheelEvent2, _FederatedMouseEvent);
  function FederatedWheelEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this2.deltaMode = void 0;
    _this2.deltaX = void 0;
    _this2.deltaY = void 0;
    _this2.deltaZ = void 0;
    _this2.DOM_DELTA_LINE = 0;
    _this2.DOM_DELTA_PAGE = 1;
    _this2.DOM_DELTA_PIXEL = 2;
    return _this2;
  }
  var _proto = FederatedWheelEvent2.prototype;
  _proto.clone = function clone7() {
    return this.manager.cloneWheelEvent(this);
  };
  return FederatedWheelEvent2;
}(FederatedMouseEvent);
function isDisplayObject(value) {
  return !!(value === null || value === void 0 ? void 0 : value.nodeName);
}
var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var DEFAULT_STYLE_PROPS = {
  anchor: "",
  opacity: "",
  fillOpacity: "",
  strokeOpacity: "",
  fill: "",
  stroke: "",
  transform: "",
  transformOrigin: "",
  visibility: "",
  pointerEvents: "",
  lineWidth: "",
  lineCap: "",
  lineJoin: "",
  increasedLineWidthForHitTesting: "",
  fontSize: "",
  fontFamily: "",
  fontStyle: "",
  fontWeight: "",
  fontVariant: "",
  textAlign: "",
  textBaseline: "",
  textTransform: "",
  zIndex: "",
  filter: "",
  shadowType: ""
};
var DEFAULT_PARSED_STYLE_PROPS = {
  anchor: [0, 0],
  fill: noneColor,
  stroke: noneColor,
  transform: [],
  zIndex: 0,
  filter: [],
  shadowType: "outer",
  miterLimit: 10
};
var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = _extends({}, DEFAULT_PARSED_STYLE_PROPS, {
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  visibility: "visible",
  pointerEvents: "auto",
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  increasedLineWidthForHitTesting: 0,
  fillRule: "nonzero"
  // TODO: transformOrigin
});
var INHERITABLE_BASE_STYLE_PROPS = ["opacity", "fillOpacity", "strokeOpacity", "transformOrigin", "visibility", "pointerEvents", "lineWidth", "lineCap", "lineJoin", "increasedLineWidthForHitTesting"];
var INHERITABLE_STYLE_PROPS = [].concat(INHERITABLE_BASE_STYLE_PROPS, ["fontSize", "fontFamily", "fontStyle", "fontWeight", "fontVariant", "textAlign", "textBaseline", "textTransform"]);
var DATASET_PREFIX = "data-";
var DisplayObject = function(_Element) {
  _inheritsLoose(DisplayObject2, _Element);
  function DisplayObject2(config) {
    var _this$config$capture;
    var _this2;
    _this2 = _Element.call(this) || this;
    _this2.config = void 0;
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.dataset = void 0;
    _this2.getClip = function() {
      return this.style.clipPath || null;
    };
    _this2.config = config;
    _this2.config.interactive = (_this$config$capture = _this2.config.capture) !== null && _this$config$capture !== void 0 ? _this$config$capture : _this2.config.interactive;
    _this2.id = _this2.config.id || "";
    _this2.name = _this2.config.name || "";
    if (_this2.config.className || _this2.config.class) {
      _this2.className = _this2.config.className || _this2.config.class;
    }
    _this2.nodeName = _this2.config.type || Shape.GROUP;
    _this2.config.style = _this2.config.style || _this2.config.attrs || {};
    Object.assign(_this2.config.style, _this2.config.attrs);
    if (_this2.config.visible != null) {
      _this2.config.style.visibility = _this2.config.visible === false ? "hidden" : "visible";
    }
    if (_this2.config.interactive != null) {
      _this2.config.style.pointerEvents = _this2.config.interactive === false ? "none" : "auto";
    }
    Object.assign(_this2.parsedStyle, runtime.enableCSSParsing ? DEFAULT_PARSED_STYLE_PROPS : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this2.config.initialParsedStyle);
    if (runtime.enableCSSParsing) {
      Object.assign(_this2.attributes, DEFAULT_STYLE_PROPS);
    }
    _this2.initAttributes(_this2.config.style);
    _this2.dataset = new Proxy({}, {
      get: function get(target, name) {
        var formattedName = "" + DATASET_PREFIX + kebabize(name);
        if (target[formattedName] !== void 0) {
          return target[formattedName];
        }
        return _this2.getAttribute(formattedName);
      },
      set: function set7(_2, prop, value) {
        _this2.setAttribute("" + DATASET_PREFIX + kebabize(prop), value);
        return true;
      }
    });
    _this2.style = new Proxy(
      // @ts-ignore
      {
        // ...this.attributes,
        setProperty: function setProperty(propertyName, value) {
          _this2.setAttribute(propertyName, value);
        },
        getPropertyValue: function getPropertyValue(propertyName) {
          return _this2.getAttribute(propertyName);
        },
        removeProperty: function removeProperty(propertyName) {
          _this2.removeAttribute(propertyName);
        },
        item: function item() {
          return "";
        }
      },
      {
        get: function get(target, name) {
          if (target[name] !== void 0) {
            return target[name];
          }
          return _this2.getAttribute(name);
        },
        set: function set7(_2, prop, value) {
          _this2.setAttribute(prop, value);
          return true;
        }
      }
    );
    runtime.displayObjectPool.add(_this2.entity, _assertThisInitialized(_this2));
    return _this2;
  }
  var _proto = DisplayObject2.prototype;
  _proto.destroy = function destroy() {
    _Element.prototype.destroy.call(this);
    runtime.displayObjectPool.remove(this.entity);
    this.getAnimations().forEach(function(animation) {
      animation.cancel();
    });
  };
  _proto.cloneNode = function cloneNode(deep, customCloneFunc) {
    var clonedStyle = _extends({}, this.attributes);
    for (var attributeName in clonedStyle) {
      var attribute = clonedStyle[attributeName];
      if (isDisplayObject(attribute) && // share the same clipPath if possible
      attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
        clonedStyle[attributeName] = attribute.cloneNode(deep);
      }
      if (customCloneFunc) {
        clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
      }
    }
    var cloned = new this.constructor({
      // copy id & name
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
      id: this.id,
      name: this.name,
      className: this.name,
      interactive: this.interactive,
      style: clonedStyle
    });
    cloned.setLocalTransform(this.getLocalTransform());
    if (deep) {
      this.children.forEach(function(child) {
        if (!child.style.isMarker) {
          var clonedChild = child.cloneNode(deep);
          cloned.appendChild(clonedChild);
        }
      });
    }
    return cloned;
  };
  _proto.initAttributes = function initAttributes(attributes) {
    if (attributes === void 0) {
      attributes = {};
    }
    var renderable = this.renderable;
    var options = {
      forceUpdateGeometry: true
      // usedAttributes:
      //   // only Group / Text should account for text relative props
      //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
      //     ? INHERITABLE_STYLE_PROPS
      //     : INHERITABLE_BASE_STYLE_PROPS,
    };
    if (runtime.enableCSSParsing) {
      options.usedAttributes = INHERITABLE_STYLE_PROPS;
    }
    runtime.styleValueRegistry.processProperties(this, attributes, options);
    renderable.dirty = true;
  };
  _proto.setAttribute = function setAttribute(name, value, force) {
    if (force === void 0) {
      force = false;
    }
    var attributeName = formatAttributeName(name);
    if (is_undefined_default(value)) {
      return;
    }
    if (force || value !== this.attributes[attributeName]) {
      this.internalSetAttribute(attributeName, value);
      _Element.prototype.setAttribute.call(this, attributeName, value);
    }
  };
  _proto.internalSetAttribute = function internalSetAttribute(name, value, parseOptions) {
    var _runtime$styleValueRe;
    if (parseOptions === void 0) {
      parseOptions = {};
    }
    var renderable = this.renderable;
    var oldValue = this.attributes[name];
    var oldParsedValue = this.parsedStyle[name];
    runtime.styleValueRegistry.processProperties(this, (_runtime$styleValueRe = {}, _runtime$styleValueRe[name] = value, _runtime$styleValueRe), parseOptions);
    renderable.dirty = true;
    var newParsedValue = this.parsedStyle[name];
    if (this.isConnected) {
      mutationEvent.relatedNode = this;
      mutationEvent.prevValue = oldValue;
      mutationEvent.newValue = value;
      mutationEvent.attrName = name;
      mutationEvent.prevParsedValue = oldParsedValue;
      mutationEvent.newParsedValue = newParsedValue;
      if (this.isMutationObserved) {
        this.dispatchEvent(mutationEvent);
      } else {
        mutationEvent.target = this;
        this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
      }
    }
    if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
      this.attributeChangedCallback(name, oldValue, value, oldParsedValue, newParsedValue);
    }
  };
  _proto.getBBox = function getBBox() {
    var aabb = this.getBounds();
    var _aabb$getMin = aabb.getMin(), left = _aabb$getMin[0], top = _aabb$getMin[1];
    var _aabb$getMax = aabb.getMax(), right = _aabb$getMax[0], bottom = _aabb$getMax[1];
    return new Rectangle(left, top, right - left, bottom - top);
  };
  _proto.setOrigin = function setOrigin(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z));
    return this;
  };
  _proto.getOrigin = function getOrigin() {
    return runtime.sceneGraphService.getOrigin(this);
  };
  _proto.setPosition = function setPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setPosition(this, createVec3(position, y, z));
    return this;
  };
  _proto.setLocalPosition = function setLocalPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z));
    return this;
  };
  _proto.translate = function translate3(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translate(this, createVec3(position, y, z));
    return this;
  };
  _proto.translateLocal = function translateLocal(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z));
    return this;
  };
  _proto.getPosition = function getPosition2() {
    return runtime.sceneGraphService.getPosition(this);
  };
  _proto.getLocalPosition = function getLocalPosition() {
    return runtime.sceneGraphService.getLocalPosition(this);
  };
  _proto.scale = function scale8(scaling, y, z) {
    return this.scaleLocal(scaling, y, z);
  };
  _proto.scaleLocal = function scaleLocal(scaling, y, z) {
    if (typeof scaling === "number") {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.scaleLocal(this, scaling);
    return this;
  };
  _proto.setLocalScale = function setLocalScale(scaling, y, z) {
    if (typeof scaling === "number") {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.setLocalScale(this, scaling);
    return this;
  };
  _proto.getLocalScale = function getLocalScale() {
    return runtime.sceneGraphService.getLocalScale(this);
  };
  _proto.getScale = function getScale() {
    return runtime.sceneGraphService.getScale(this);
  };
  _proto.getEulerAngles = function getEulerAngles() {
    var _getEuler = getEuler(vec3_exports.create(), runtime.sceneGraphService.getWorldTransform(this)), ez = _getEuler[2];
    return rad2deg2(ez);
  };
  _proto.getLocalEulerAngles = function getLocalEulerAngles() {
    var _getEuler2 = getEuler(vec3_exports.create(), runtime.sceneGraphService.getLocalRotation(this)), ez = _getEuler2[2];
    return rad2deg2(ez);
  };
  _proto.setEulerAngles = function setEulerAngles(z) {
    runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
    return this;
  };
  _proto.setLocalEulerAngles = function setLocalEulerAngles(z) {
    runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
    return this;
  };
  _proto.rotateLocal = function rotateLocal(x, y, z) {
    if (is_nil_default(y) && is_nil_default(z)) {
      runtime.sceneGraphService.rotateLocal(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotateLocal(this, x, y, z);
    }
    return this;
  };
  _proto.rotate = function rotate5(x, y, z) {
    if (is_nil_default(y) && is_nil_default(z)) {
      runtime.sceneGraphService.rotate(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotate(this, x, y, z);
    }
    return this;
  };
  _proto.setRotation = function setRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalRotation = function setLocalRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalSkew = function setLocalSkew(skew, y) {
    runtime.sceneGraphService.setLocalSkew(this, skew, y);
    return this;
  };
  _proto.getRotation = function getRotation2() {
    return runtime.sceneGraphService.getRotation(this);
  };
  _proto.getLocalRotation = function getLocalRotation() {
    return runtime.sceneGraphService.getLocalRotation(this);
  };
  _proto.getLocalSkew = function getLocalSkew() {
    return runtime.sceneGraphService.getLocalSkew(this);
  };
  _proto.getLocalTransform = function getLocalTransform() {
    return runtime.sceneGraphService.getLocalTransform(this);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return runtime.sceneGraphService.getWorldTransform(this);
  };
  _proto.setLocalTransform = function setLocalTransform(transform) {
    runtime.sceneGraphService.setLocalTransform(this, transform);
    return this;
  };
  _proto.resetLocalTransform = function resetLocalTransform() {
    runtime.sceneGraphService.resetLocalTransform(this);
  };
  _proto.getAnimations = function getAnimations() {
    return this.activeAnimations;
  };
  _proto.animate = function animate(keyframes, options) {
    var _this$ownerDocument;
    var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
    if (timeline) {
      return timeline.play(this, keyframes, options);
    }
    return null;
  };
  _proto.isVisible = function isVisible() {
    var _this$parsedStyle;
    return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) === "visible";
  };
  _proto.isInteractive = function isInteractive() {
    var _this$parsedStyle2;
    return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
  };
  _proto.isCulled = function isCulled() {
    return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
  };
  _proto.toFront = function toFront() {
    if (this.parentNode) {
      this.style.zIndex = Math.max.apply(Math, this.parentNode.children.map(function(child) {
        return Number(child.style.zIndex);
      })) + 1;
    }
    return this;
  };
  _proto.toBack = function toBack() {
    if (this.parentNode) {
      this.style.zIndex = Math.min.apply(Math, this.parentNode.children.map(function(child) {
        return Number(child.style.zIndex);
      })) - 1;
    }
    return this;
  };
  _proto.getConfig = function getConfig() {
    return this.config;
  };
  _proto.attr = function attr() {
    var _this2 = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var name = args[0], value = args[1];
    if (!name) {
      return this.attributes;
    }
    if (is_object_default(name)) {
      Object.keys(name).forEach(function(key) {
        _this2.setAttribute(key, name[key]);
      });
      return this;
    }
    if (args.length === 2) {
      this.setAttribute(name, value);
      return this;
    }
    return this.attributes[name];
  };
  _proto.getMatrix = function getMatrix(transformMat44) {
    var transform = transformMat44 || this.getWorldTransform();
    var _mat4$getTranslation = mat4_exports.getTranslation(vec3_exports.create(), transform), tx = _mat4$getTranslation[0], ty = _mat4$getTranslation[1];
    var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), transform), sx = _mat4$getScaling[0], sy = _mat4$getScaling[1];
    var rotation = mat4_exports.getRotation(quat_exports.create(), transform);
    var _getEuler3 = getEuler(vec3_exports.create(), rotation), eux = _getEuler3[0], euz = _getEuler3[2];
    return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
  };
  _proto.getLocalMatrix = function getLocalMatrix() {
    return this.getMatrix(this.getLocalTransform());
  };
  _proto.setMatrix = function setMatrix(mat) {
    var _decompose = decompose(mat), tx = _decompose[0], ty = _decompose[1], scalingX = _decompose[2], scalingY = _decompose[3], angle3 = _decompose[4];
    this.setEulerAngles(angle3).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
  };
  _proto.setLocalMatrix = function setLocalMatrix(mat) {
    var _decompose2 = decompose(mat), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle3 = _decompose2[4];
    this.setLocalEulerAngles(angle3).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
  };
  _proto.show = function show() {
    this.style.visibility = "visible";
  };
  _proto.hide = function hide() {
    this.style.visibility = "hidden";
  };
  _proto.getCount = function getCount() {
    return this.childElementCount;
  };
  _proto.getParent = function getParent() {
    return this.parentElement;
  };
  _proto.getChildren = function getChildren() {
    return this.children;
  };
  _proto.getFirst = function getFirst() {
    return this.firstElementChild;
  };
  _proto.getLast = function getLast() {
    return this.lastElementChild;
  };
  _proto.getChildByIndex = function getChildByIndex(index) {
    return this.children[index] || null;
  };
  _proto.add = function add7(child, index) {
    return this.appendChild(child, index);
  };
  _proto.setClip = function setClip(clipPath) {
    this.style.clipPath = clipPath;
  };
  _proto.set = function set7(name, value) {
    this.config[name] = value;
  };
  _proto.get = function get(name) {
    return this.config[name];
  };
  _proto.moveTo = function moveTo(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  };
  _proto.move = function move(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  };
  _proto.setZIndex = function setZIndex(zIndex) {
    this.style.zIndex = zIndex;
    return this;
  };
  _createClass(DisplayObject2, [{
    key: "interactive",
    get: function get() {
      return this.isInteractive();
    },
    set: function set7(b) {
      this.style.pointerEvents = b ? "auto" : "none";
    }
  }]);
  return DisplayObject2;
}(Element2);
var _excluded = ["style"];
var Circle = function(_DisplayObject) {
  _inheritsLoose(Circle2, _DisplayObject);
  function Circle2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _DisplayObject.call(this, _extends({
      type: Shape.CIRCLE,
      style: runtime.enableCSSParsing ? _extends({
        cx: "",
        cy: "",
        r: ""
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, "%"), getOrCreateUnitValue(50, "%")]
      }
    }, rest)) || this;
  }
  return Circle2;
}(DisplayObject);
var _excluded$1 = ["style"];
var CustomElement = function(_DisplayObject) {
  _inheritsLoose(CustomElement2, _DisplayObject);
  function CustomElement2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    _this2 = _DisplayObject.call(this, _extends({
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this2.isCustomElement = true;
    return _this2;
  }
  return CustomElement2;
}(DisplayObject);
var pool = {};
var htmlPool = [];
var DisplayObjectPool = function() {
  function DisplayObjectPool2() {
  }
  var _proto = DisplayObjectPool2.prototype;
  _proto.getByEntity = function getByEntity(entity) {
    return pool[entity];
  };
  _proto.getAll = function getAll() {
    return Object.keys(pool).map(function(entity) {
      return pool[entity];
    });
  };
  _proto.add = function add7(entity, groupOrShape) {
    pool[entity] = groupOrShape;
    if (groupOrShape.nodeName === Shape.HTML) {
      htmlPool.push(groupOrShape);
    }
  };
  _proto.remove = function remove(entity) {
    var existed = pool[entity];
    if (existed) {
      delete pool[entity];
      if (existed.nodeName === Shape.HTML) {
        var index = htmlPool.indexOf(existed);
        htmlPool.splice(index, 1);
      }
    }
  };
  _proto.getHTMLs = function getHTMLs() {
    return htmlPool;
  };
  return DisplayObjectPool2;
}();
var _excluded$2 = ["style"];
var Ellipse = function(_DisplayObject) {
  _inheritsLoose(Ellipse2, _DisplayObject);
  function Ellipse2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    return _DisplayObject.call(this, _extends({
      type: Shape.ELLIPSE,
      style: runtime.enableCSSParsing ? _extends({
        cx: "",
        cy: "",
        rx: "",
        ry: ""
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, "%"), getOrCreateUnitValue(50, "%")]
      }
    }, rest)) || this;
  }
  return Ellipse2;
}(DisplayObject);
var _excluded$3 = ["style"];
var Group = function(_DisplayObject) {
  _inheritsLoose(Group2, _DisplayObject);
  function Group2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
    return _DisplayObject.call(this, _extends({
      type: Shape.GROUP,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "",
        height: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Group2;
}(DisplayObject);
var _excluded$4 = ["style"];
var HTML = function(_DisplayObject) {
  _inheritsLoose(HTML2, _DisplayObject);
  function HTML2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.HTML,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "auto",
        height: "auto",
        innerHTML: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this2.cullable.enable = false;
    return _this2;
  }
  var _proto = HTML2.prototype;
  _proto.getDomElement = function getDomElement() {
    return this.parsedStyle.$el;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return this.parsedStyle.$el.getBoundingClientRect();
  };
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  };
  _proto.getBounds = function getBounds() {
    var _this$ownerDocument, _this$ownerDocument$d;
    var clientRect = this.getBoundingClientRect();
    var canvasRect = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : (_this$ownerDocument$d = _this$ownerDocument.defaultView) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.getContextService().getBoundingClientRect();
    if (canvasRect) {
      var minX = clientRect.left - canvasRect.left;
      var minY = clientRect.top - canvasRect.top;
      var aabb = new AABB();
      aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
      return aabb;
    }
    return null;
  };
  _proto.getLocalBounds = function getLocalBounds() {
    if (this.parentNode) {
      var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
      var bounds = this.getBounds();
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds();
  };
  return HTML2;
}(DisplayObject);
var _excluded$5 = ["style"];
var Image = function(_DisplayObject) {
  _inheritsLoose(Image2, _DisplayObject);
  function Image2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$5);
    return _DisplayObject.call(this, _extends({
      type: Shape.IMAGE,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        img: "",
        width: "",
        height: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Image2;
}(DisplayObject);
var _excluded$6 = ["style"];
var Line = function(_DisplayObject) {
  _inheritsLoose(Line2, _DisplayObject);
  function Line2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$6);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.LINE,
      style: _extends({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0,
        isBillboard: false
      }, style)
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Line2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x2 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y2 = _this$parsedStyle2.y2, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      ox = x1 - defX;
      oy = y1 - defY;
      x = x2 - x1;
      y = y2 - y1;
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      ox = x2 - defX;
      oy = y2 - defY;
      x = x1 - x2;
      y = y1 - y2;
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x2 = _this$parsedStyle3.x2, y2 = _this$parsedStyle3.y2, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    var _LineUtil$pointAt = line.pointAt(x1, y1, x2, y2, ratio), x = _LineUtil$pointAt.x, y = _LineUtil$pointAt.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getPointAtLength = function getPointAtLength2(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
  };
  _proto.getTotalLength = function getTotalLength2() {
    var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x2 = _this$parsedStyle4.x2, y2 = _this$parsedStyle4.y2;
    return line.length(x1, y1, x2, y2);
  };
  return Line2;
}(DisplayObject);
var _excluded$7 = ["style"];
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var Path = function(_DisplayObject) {
  _inheritsLoose(Path2, _DisplayObject);
  function Path2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$7);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.PATH,
      style: runtime.enableCSSParsing ? _extends({
        path: "",
        miterLimit: ""
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        miterLimit: 4,
        path: _extends({}, EMPTY_PARSED_PATH)
      }
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Path2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "path") {
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === "markerMid") {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      var _this$getStartTangent = this.getStartTangent(), p1 = _this$getStartTangent[0], p2 = _this$getStartTangent[1];
      ox = p2[0] - defX;
      oy = p2[1] - defY;
      x = p1[0] - p2[0];
      y = p1[1] - p2[1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var _this$getEndTangent = this.getEndTangent(), _p = _this$getEndTangent[0], _p2 = _this$getEndTangent[1];
      ox = _p2[0] - defX;
      oy = _p2[1] - defY;
      x = _p[0] - _p2[0];
      y = _p[1] - _p2[1];
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle, segments = _this$parsedStyle3.path.segments, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    this.markerMidList.forEach(function(marker2) {
      marker2.remove();
    });
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < segments.length - 1; i++) {
        var _segments$i$currentPo = segments[i].currentPoint, ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox - defX, oy - defY);
      }
    }
  };
  _proto.getTotalLength = function getTotalLength2() {
    return getOrCalculatePathTotalLength(this);
  };
  _proto.getPointAtLength = function getPointAtLength$1(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle4 = this.parsedStyle, defX = _this$parsedStyle4.defX, defY = _this$parsedStyle4.defY, absolutePath = _this$parsedStyle4.path.absolutePath;
    var _getPointAtLength2 = getPointAtLength(absolutePath, distance6), x = _getPointAtLength2.x, y = _getPointAtLength2.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
  };
  _proto.getStartTangent = function getStartTangent() {
    var segments = this.parsedStyle.path.segments;
    var result = [];
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  _proto.getEndTangent = function getEndTangent() {
    var segments = this.parsedStyle.path.segments;
    var length14 = segments.length;
    var result = [];
    if (length14 > 1) {
      var startPoint = segments[length14 - 2].currentPoint;
      var endPoint = segments[length14 - 1].currentPoint;
      var tangent = segments[length14 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path2;
}(DisplayObject);
var _excluded$8 = ["style"];
var Polygon = function(_DisplayObject) {
  _inheritsLoose(Polygon2, _DisplayObject);
  function Polygon2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$8);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.POLYGON,
      style: runtime.enableCSSParsing ? _extends({
        points: "",
        miterLimit: "",
        isClosed: true
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Polygon2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "points") {
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === "markerMid") {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, points = _this$parsedStyle2.points.points, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    ox = points[0][0] - defX;
    oy = points[0][1] - defY;
    if (isStart) {
      x = points[1][0] - points[0][0];
      y = points[1][1] - points[0][1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var length14 = points.length;
      if (!this.parsedStyle.isClosed) {
        ox = points[length14 - 1][0] - defX;
        oy = points[length14 - 1][1] - defY;
        x = points[length14 - 2][0] - points[length14 - 1][0];
        y = points[length14 - 2][1] - points[length14 - 1][1];
      } else {
        x = points[length14 - 1][0] - points[0][0];
        y = points[length14 - 1][1] - points[0][1];
      }
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle, points = _this$parsedStyle3.points.points, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    this.markerMidList.forEach(function(marker2) {
      marker2.remove();
    });
    this.markerMidList = [];
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
        var ox = points[i][0] - defX;
        var oy = points[i][1] - defY;
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox, oy);
      }
    }
  };
  return Polygon2;
}(DisplayObject);
var _excluded$9 = ["style"];
var Polyline = function(_Polygon) {
  _inheritsLoose(Polyline2, _Polygon);
  function Polyline2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$9);
    return _Polygon.call(this, _extends({
      type: Shape.POLYLINE,
      style: runtime.enableCSSParsing ? _extends({
        points: "",
        miterLimit: "",
        isClosed: false
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)) || this;
  }
  var _proto = Polyline2.prototype;
  _proto.getTotalLength = function getTotalLength2() {
    return this.parsedStyle.points.totalLength;
  };
  _proto.getPointAtLength = function getPointAtLength2(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle = this.parsedStyle, defX = _this$parsedStyle.defX, defY = _this$parsedStyle.defY, _this$parsedStyle$poi = _this$parsedStyle.points, points = _this$parsedStyle$poi.points, segments = _this$parsedStyle$poi.segments;
    var subt = 0;
    var index = 0;
    segments.forEach(function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var _LineUtil$pointAt = line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt), x = _LineUtil$pointAt.x, y = _LineUtil$pointAt.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getStartTangent = function getStartTangent() {
    var points = this.parsedStyle.points.points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  _proto.getEndTangent = function getEndTangent() {
    var points = this.parsedStyle.points.points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return Polyline2;
}(Polygon);
var _excluded$a = ["style"];
var Rect = function(_DisplayObject) {
  _inheritsLoose(Rect2, _DisplayObject);
  function Rect2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$a);
    return _DisplayObject.call(this, _extends({
      type: Shape.RECT,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "",
        height: "",
        radius: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Rect2;
}(DisplayObject);
var _excluded$b = ["style"];
var Text = function(_DisplayObject) {
  _inheritsLoose(Text2, _DisplayObject);
  function Text2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$b);
    return _DisplayObject.call(this, _extends({
      type: Shape.TEXT,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        text: "",
        fontSize: "",
        fontFamily: "",
        fontStyle: "",
        fontWeight: "",
        fontVariant: "",
        textAlign: "",
        textBaseline: "",
        textTransform: "",
        fill: "black",
        letterSpacing: "",
        lineHeight: "",
        miterLimit: "",
        // whiteSpace: 'pre',
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: "",
        dy: ""
      }, style) : _extends({
        fill: "black"
      }, style),
      initialParsedStyle: runtime.enableCSSParsing ? {} : {
        x: 0,
        y: 0,
        fontSize: 16,
        fontFamily: "sans-serif",
        fontStyle: "normal",
        fontWeight: "normal",
        fontVariant: "normal",
        lineHeight: 0,
        letterSpacing: 0,
        textBaseline: "alphabetic",
        textAlign: "start",
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: 0,
        dy: 0
      }
    }, rest)) || this;
  }
  var _proto = Text2.prototype;
  _proto.getComputedTextLength = function getComputedTextLength() {
    var _this$parsedStyle$met;
    return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
  };
  _proto.getLineBoundingRects = function getLineBoundingRects() {
    var _this$parsedStyle$met2;
    return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
  };
  _proto.isOverflowing = function isOverflowing() {
    return !!this.parsedStyle.isOverflowing;
  };
  return Text2;
}(DisplayObject);
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    int: true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    int: true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    int: true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    int: true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    int: true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    int: true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    int: true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    // int: true,
    d: function d(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "center";
      }
      if (nodeName === Shape.TEXT) {
        return "text-anchor";
      }
      return "left top";
    },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "anchor",
    p: 99,
    d: function d2(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "0.5 0.5";
      }
      return "0 0";
    },
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  // <circle> & <ellipse>
  {
    n: "cx",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "path",
    int: true,
    l: true,
    d: "",
    a: ["d"],
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    int: true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d3(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  }
];
var propertyMetadataCache = {};
var unresolvedProperties = /* @__PURE__ */ new WeakMap();
var isPropertyResolved = function isPropertyResolved2(object, name) {
  var properties = unresolvedProperties.get(object);
  if (!properties || properties.length === 0) {
    return true;
  }
  return properties.includes(name);
};
var DefaultStyleValueRegistry = function() {
  function DefaultStyleValueRegistry2() {
    var _this2 = this;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  var _proto = DefaultStyleValueRegistry2.prototype;
  _proto.registerMetadata = function registerMetadata(metadata) {
    [metadata.n].concat(metadata.a || []).forEach(function(name) {
      propertyMetadataCache[name] = metadata;
    });
  };
  _proto.unregisterMetadata = function unregisterMetadata(name) {
    delete propertyMetadataCache[name];
  };
  _proto.getPropertySyntax = function getPropertySyntax(syntax) {
    return runtime.CSSPropertySyntaxFactory[syntax];
  };
  _proto.processProperties = function processProperties(object, attributes, options) {
    var _this2 = this;
    if (options === void 0) {
      options = {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: []
      };
    }
    if (!runtime.enableCSSParsing) {
      if (attributes.src) {
        attributes.img = attributes.src;
      }
      if (attributes.d) {
        attributes.path = attributes.d;
      }
      if (attributes.strokeDasharray) {
        attributes.lineDash = attributes.strokeDasharray;
      }
      if (attributes.strokeWidth) {
        attributes.lineWidth = attributes.strokeWidth;
      }
      if (attributes.textAnchor) {
        attributes.textAlign = attributes.textAnchor;
      }
      Object.assign(object.attributes, attributes);
      var _attributeNames = Object.keys(attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      object.parsedStyle = Object.assign(object.parsedStyle, attributes);
      if (attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (!is_nil_default(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (!is_nil_default(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
      }
      if (attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points, object);
      }
      if (attributes.path === "") {
        object.parsedStyle.path = _extends({}, EMPTY_PARSED_PATH);
      }
      if (attributes.path) {
        object.parsedStyle.path = parsePath(
          // @ts-ignore
          attributes.path,
          object
        );
      }
      if (attributes.textTransform) {
        runtime.CSSPropertySyntaxFactory["<text-transform>"].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (attributes.clipPath) {
        runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("clipPath", oldClipPath, attributes.clipPath, object, this);
      }
      if (attributes.offsetPath) {
        runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this);
      }
      if (attributes.anchor) {
        object.parsedStyle.anchor = parseDimensionArrayFormat(
          // @ts-ignorex
          attributes.anchor,
          2
        );
      }
      if (attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (attributes.markerStart) {
        object.parsedStyle.markerStart = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (attributes.markerEnd) {
        object.parsedStyle.markerEnd = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (attributes.markerMid) {
        object.parsedStyle.markerMid = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (
        // Circle & Ellipse
        (object.nodeName === Shape.CIRCLE || object.nodeName === Shape.ELLIPSE) && // @ts-ignore
        (!is_nil_default(attributes.cx) || // @ts-ignore
        !is_nil_default(attributes.cy)) || (object.nodeName === Shape.RECT || object.nodeName === Shape.IMAGE || object.nodeName === Shape.GROUP || object.nodeName === Shape.HTML || object.nodeName === Shape.TEXT || object.nodeName === Shape.MESH) && // @ts-ignore
        (!is_nil_default(attributes.x) || // @ts-ignore
        !is_nil_default(attributes.y) || // @ts-ignore
        !is_nil_default(attributes.z)) || // Line
        object.nodeName === Shape.LINE && // @ts-ignore
        (!is_nil_default(attributes.x1) || // @ts-ignore
        !is_nil_default(attributes.y1) || // @ts-ignore
        !is_nil_default(attributes.z1) || // @ts-ignore
        !is_nil_default(attributes.x2) || // @ts-ignore
        !is_nil_default(attributes.y2) || // @ts-ignore
        !is_nil_default(attributes.z2))
      ) {
        runtime.CSSPropertySyntaxFactory["<coordinate>"].postProcessor(object, _attributeNames);
      }
      if (!is_nil_default(attributes.zIndex)) {
        runtime.CSSPropertySyntaxFactory["<z-index>"].postProcessor(object, _attributeNames);
      }
      if (attributes.path) {
        runtime.CSSPropertySyntaxFactory["<path>"].postProcessor(object, _attributeNames);
      }
      if (attributes.points) {
        runtime.CSSPropertySyntaxFactory["<list-of-points>"].postProcessor(object, _attributeNames);
      }
      if (!is_nil_default(attributes.offsetDistance)) {
        runtime.CSSPropertySyntaxFactory["<offset-distance>"].postProcessor(object, _attributeNames);
      }
      if (attributes.transform) {
        runtime.CSSPropertySyntaxFactory["<transform>"].postProcessor(object, _attributeNames);
      }
      this.updateGeometry(object);
      return;
    }
    var _options = options, skipUpdateAttribute = _options.skipUpdateAttribute, skipParse = _options.skipParse, forceUpdateGeometry = _options.forceUpdateGeometry, usedAttributes = _options.usedAttributes;
    var needUpdateGeometry = forceUpdateGeometry;
    var attributeNames = Object.keys(attributes);
    attributeNames.forEach(function(attributeName) {
      var _propertyMetadataCach;
      var name = formatAttributeName(attributeName);
      if (!skipUpdateAttribute) {
        object.attributes[name] = attributes[attributeName];
      }
      if (!needUpdateGeometry && ((_propertyMetadataCach = propertyMetadataCache[name]) === null || _propertyMetadataCach === void 0 ? void 0 : _propertyMetadataCach.l)) {
        needUpdateGeometry = true;
      }
    });
    if (!skipParse) {
      attributeNames.forEach(function(name) {
        object.computedStyle[name] = _this2.parseProperty(name, object.attributes[name], object);
      });
    }
    if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
      attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
    }
    attributeNames.forEach(function(name) {
      if (name in object.computedStyle) {
        object.parsedStyle[name] = _this2.computeProperty(name, object.computedStyle[name], object);
      }
    });
    if (needUpdateGeometry) {
      this.updateGeometry(object);
    }
    attributeNames.forEach(function(name) {
      if (name in object.parsedStyle) {
        _this2.postProcessProperty(name, object, attributeNames);
      }
    });
    if (runtime.enableCSSParsing && object.children.length) {
      attributeNames.forEach(function(name) {
        if (name in object.parsedStyle && _this2.isPropertyInheritable(name)) {
          object.children.forEach(function(child) {
            child.internalSetAttribute(name, null, {
              skipUpdateAttribute: true,
              skipParse: true
            });
          });
        }
      });
    }
  };
  _proto.parseProperty = function parseProperty(name, value, object) {
    var metadata = propertyMetadataCache[name];
    var computed = value;
    if (value === "" || is_nil_default(value)) {
      value = "unset";
    }
    if (value === "unset" || value === "initial" || value === "inherit") {
      computed = getOrCreateKeyword(value);
    } else {
      if (metadata) {
        var keywords = metadata.k, syntax = metadata.syntax;
        var handler = syntax && this.getPropertySyntax(syntax);
        if (keywords && keywords.indexOf(value) > -1) {
          computed = getOrCreateKeyword(value);
        } else if (handler && handler.parser) {
          computed = handler.parser(value, object);
        }
      }
    }
    return computed;
  };
  _proto.computeProperty = function computeProperty(name, computed, object) {
    var metadata = propertyMetadataCache[name];
    var isDocumentElement = object.id === "g-root";
    var used = computed;
    if (metadata) {
      var syntax = metadata.syntax, inherited = metadata.inh, defaultValue = metadata.d;
      if (computed instanceof CSSKeywordValue) {
        var value = computed.value;
        if (value === "unset") {
          if (inherited && !isDocumentElement) {
            value = "inherit";
          } else {
            value = "initial";
          }
        }
        if (value === "initial") {
          if (!is_nil_default(defaultValue)) {
            computed = this.parseProperty(name, isFunction(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object);
          }
        } else if (value === "inherit") {
          var resolved = this.tryToResolveProperty(object, name, {
            inherited: true
          });
          if (!is_nil_default(resolved)) {
            return resolved;
          } else {
            this.addUnresolveProperty(object, name);
            return;
          }
        }
      }
      var handler = syntax && this.getPropertySyntax(syntax);
      if (handler && handler.calculator) {
        var oldParsedValue = object.parsedStyle[name];
        used = handler.calculator(name, oldParsedValue, computed, object, this);
      } else if (computed instanceof CSSKeywordValue) {
        used = computed.value;
      } else {
        used = computed;
      }
    }
    return used;
  };
  _proto.postProcessProperty = function postProcessProperty(name, object, attributes) {
    var metadata = propertyMetadataCache[name];
    if (metadata && metadata.syntax) {
      var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
      var propertyHandler = handler;
      if (propertyHandler && propertyHandler.postProcessor) {
        propertyHandler.postProcessor(object, attributes);
      }
    }
  };
  _proto.addUnresolveProperty = function addUnresolveProperty(object, name) {
    var properties = unresolvedProperties.get(object);
    if (!properties) {
      unresolvedProperties.set(object, []);
      properties = unresolvedProperties.get(object);
    }
    if (properties.indexOf(name) === -1) {
      properties.push(name);
    }
  };
  _proto.tryToResolveProperty = function tryToResolveProperty(object, name, options) {
    if (options === void 0) {
      options = {};
    }
    var _options2 = options, inherited = _options2.inherited;
    if (inherited) {
      if (object.parentElement && isPropertyResolved(object.parentElement, name)) {
        var usedValue = object.parentElement.parsedStyle[name];
        if (
          // usedValue instanceof CSSKeywordValue &&
          usedValue === "unset" || usedValue === "initial" || usedValue === "inherit"
        ) {
          return;
        }
        return usedValue;
      }
    }
    return;
  };
  _proto.recalc = function recalc(object) {
    var properties = unresolvedProperties.get(object);
    if (properties && properties.length) {
      var attributes = {};
      properties.forEach(function(property) {
        attributes[property] = object.attributes[property];
      });
      this.processProperties(object, attributes);
      unresolvedProperties.delete(object);
    }
  };
  _proto.updateGeometry = function updateGeometry(object) {
    var geometryUpdater = runtime.geometryUpdaterFactory[object.nodeName];
    if (geometryUpdater) {
      var geometry = object.geometry;
      if (!geometry.contentBounds) {
        geometry.contentBounds = new AABB();
      }
      if (!geometry.renderBounds) {
        geometry.renderBounds = new AABB();
      }
      var parsedStyle = object.parsedStyle;
      var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), width = _geometryUpdater$upda.width, height = _geometryUpdater$upda.height, _geometryUpdater$upda2 = _geometryUpdater$upda.depth, depth = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.offsetX, offsetX = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.offsetY, offsetY = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.offsetZ, offsetZ = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5;
      var flipY = width < 0;
      var flipX = height < 0;
      var halfExtents = [Math.abs(width) / 2, Math.abs(height) / 2, depth / 2];
      var stroke = parsedStyle.stroke, lineWidth = parsedStyle.lineWidth, increasedLineWidthForHitTesting = parsedStyle.increasedLineWidthForHitTesting, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
      var anchor = parsedStyle.anchor;
      if (object.nodeName === Shape.TEXT) {
        delete parsedStyle.anchor;
      }
      var center = [(1 - (anchor && anchor[0] || 0) * 2) * width / 2 + offsetX, (1 - (anchor && anchor[1] || 0) * 2) * height / 2 + offsetY, (1 - (anchor && anchor[2] || 0) * 2) * halfExtents[2] + offsetZ];
      geometry.contentBounds.update(center, halfExtents);
      var expansion = object.nodeName === Shape.POLYLINE || object.nodeName === Shape.POLYGON || object.nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
      var hasStroke = stroke && !stroke.isNone;
      if (hasStroke) {
        var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
        halfExtents[0] += halfLineWidth;
        halfExtents[1] += halfLineWidth;
      }
      geometry.renderBounds.update(center, halfExtents);
      if (shadowColor && shadowType && shadowType !== "inner") {
        var _geometry$renderBound = geometry.renderBounds, min4 = _geometry$renderBound.min, max4 = _geometry$renderBound.max;
        var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
        var shadowBlurInPixels = shadowBlur || 0;
        var shadowOffsetXInPixels = shadowOffsetX || 0;
        var shadowOffsetYInPixels = shadowOffsetY || 0;
        var shadowLeft = min4[0] - shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowRight = max4[0] + shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowTop = min4[1] - shadowBlurInPixels + shadowOffsetYInPixels;
        var shadowBottom = max4[1] + shadowBlurInPixels + shadowOffsetYInPixels;
        min4[0] = Math.min(min4[0], shadowLeft);
        max4[0] = Math.max(max4[0], shadowRight);
        min4[1] = Math.min(min4[1], shadowTop);
        max4[1] = Math.max(max4[1], shadowBottom);
        geometry.renderBounds.setMinMax(min4, max4);
      }
      filter.forEach(function(_ref) {
        var name = _ref.name, params = _ref.params;
        if (name === "blur") {
          var blurRadius = params[0].value;
          geometry.renderBounds.update(geometry.renderBounds.center, addVec3(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
        } else if (name === "drop-shadow") {
          var _shadowOffsetX = params[0].value;
          var _shadowOffsetY = params[1].value;
          var _shadowBlur = params[2].value;
          var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
          var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
          var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
          var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
          var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
          _min[0] = Math.min(_min[0], _shadowLeft);
          _max[0] = Math.max(_max[0], _shadowRight);
          _min[1] = Math.min(_min[1], _shadowTop);
          _max[1] = Math.max(_max[1], _shadowBottom);
          geometry.renderBounds.setMinMax(_min, _max);
        }
      });
      anchor = parsedStyle.anchor;
      var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object) : 0);
      var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object) : 0);
      usedOriginXValue = usedOriginXValue - (flipY ? -1 : 1) * (anchor && anchor[0] || 0) * geometry.contentBounds.halfExtents[0] * 2;
      usedOriginYValue = usedOriginYValue - (flipX ? -1 : 1) * (anchor && anchor[1] || 0) * geometry.contentBounds.halfExtents[1] * 2;
      object.setOrigin(usedOriginXValue, usedOriginYValue);
      runtime.sceneGraphService.dirtifyToRoot(object);
    }
  };
  _proto.isPropertyInheritable = function isPropertyInheritable(name) {
    var metadata = propertyMetadataCache[name];
    if (!metadata) {
      return false;
    }
    return metadata.inh;
  };
  return DefaultStyleValueRegistry2;
}();
var CameraType;
(function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
})(CameraType || (CameraType = {}));
var CameraTrackingMode;
(function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
})(CameraTrackingMode || (CameraTrackingMode = {}));
var CameraProjectionMode;
(function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
})(CameraProjectionMode || (CameraProjectionMode = {}));
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = function() {
  function Camera2() {
    this.canvas = void 0;
    this.eventEmitter = new import_eventemitter3.default();
    this.matrix = mat4_exports.create();
    this.right = vec3_exports.fromValues(1, 0, 0);
    this.up = vec3_exports.fromValues(0, 1, 0);
    this.forward = vec3_exports.fromValues(0, 0, 1);
    this.position = vec3_exports.fromValues(0, 0, 1);
    this.focalPoint = vec3_exports.fromValues(0, 0, 0);
    this.distanceVector = vec3_exports.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.left = void 0;
    this.rright = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.projectionMatrix = mat4_exports.create();
    this.projectionMatrixInverse = mat4_exports.create();
    this.jitteredProjectionMatrix = void 0;
    this.view = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = mat4_exports.create();
  }
  var _proto = Camera2.prototype;
  _proto.isOrtho = function isOrtho() {
    return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
  };
  _proto.getProjectionMode = function getProjectionMode() {
    return this.projectionMode;
  };
  _proto.getPerspective = function getPerspective() {
    return this.jitteredProjectionMatrix || this.projectionMatrix;
  };
  _proto.getPerspectiveInverse = function getPerspectiveInverse() {
    return this.projectionMatrixInverse;
  };
  _proto.getFrustum = function getFrustum() {
    return this.frustum;
  };
  _proto.getPosition = function getPosition2() {
    return this.position;
  };
  _proto.getFocalPoint = function getFocalPoint() {
    return this.focalPoint;
  };
  _proto.getDollyingStep = function getDollyingStep() {
    return this.dollyingStep;
  };
  _proto.getNear = function getNear() {
    return this.near;
  };
  _proto.getFar = function getFar() {
    return this.far;
  };
  _proto.getZoom = function getZoom() {
    return this.zoom;
  };
  _proto.getOrthoMatrix = function getOrthoMatrix() {
    return this.orthoMatrix;
  };
  _proto.getView = function getView() {
    return this.view;
  };
  _proto.setEnableUpdate = function setEnableUpdate(enabled) {
    this.enableUpdate = enabled;
  };
  _proto.setType = function setType(type, trackingMode) {
    this.type = type;
    if (this.type === CameraType.EXPLORING) {
      this.setWorldRotation(true);
    } else {
      this.setWorldRotation(false);
    }
    this._getAngles();
    if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
      this.setTrackingMode(trackingMode);
    }
    return this;
  };
  _proto.setProjectionMode = function setProjectionMode(projectionMode) {
    this.projectionMode = projectionMode;
    return this;
  };
  _proto.setTrackingMode = function setTrackingMode(trackingMode) {
    if (this.type !== CameraType.TRACKING) {
      throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
    }
    this.trackingMode = trackingMode;
    return this;
  };
  _proto.setWorldRotation = function setWorldRotation(flag) {
    this.rotateWorld = flag;
    this._getAngles();
    return this;
  };
  _proto.getViewTransform = function getViewTransform() {
    return mat4_exports.invert(mat4_exports.create(), this.matrix);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return this.matrix;
  };
  _proto.jitterProjectionMatrix = function jitterProjectionMatrix(x, y) {
    var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x, y, 0]);
    this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
  };
  _proto.clearJitterProjectionMatrix = function clearJitterProjectionMatrix() {
    this.jitteredProjectionMatrix = void 0;
  };
  _proto.setMatrix = function setMatrix(matrix) {
    this.matrix = matrix;
    this._update();
    return this;
  };
  _proto.setFov = function setFov(fov) {
    this.setPerspective(this.near, this.far, fov, this.aspect);
    return this;
  };
  _proto.setAspect = function setAspect(aspect) {
    this.setPerspective(this.near, this.far, this.fov, aspect);
    return this;
  };
  _proto.setNear = function setNear(near) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
    }
    return this;
  };
  _proto.setFar = function setFar(far) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
    }
    return this;
  };
  _proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === void 0) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.clearViewOffset = function clearViewOffset() {
    if (this.view !== void 0) {
      this.view.enabled = false;
    }
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.setZoom = function setZoom(zoom) {
    this.zoom = zoom;
    if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    }
    return this;
  };
  _proto.setZoomByViewportPoint = function setZoomByViewportPoint(zoom, viewportPoint) {
    var _this$canvas$viewport = this.canvas.viewport2Canvas({
      x: viewportPoint[0],
      y: viewportPoint[1]
    }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
    var roll = this.roll;
    this.rotate(0, 0, -roll);
    this.setPosition(ox, oy);
    this.setFocalPoint(ox, oy);
    this.setZoom(zoom);
    this.rotate(0, 0, roll);
    var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
      x: viewportPoint[0],
      y: viewportPoint[1]
    }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
    var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
    var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
    var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
    this.pan(-dx, -dy);
    return this;
  };
  _proto.setPerspective = function setPerspective(near, far, fov, aspect) {
    var _this$view;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.aspect = aspect;
    var top = this.near * Math.tan(deg2rad2(0.5 * this.fov)) / this.zoom;
    var height = 2 * top;
    var width = this.aspect * height;
    var left = -0.5 * width;
    if ((_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.enabled) {
      var fullWidth = this.view.fullWidth;
      var fullHeight = this.view.fullHeight;
      left += this.view.offsetX * width / fullWidth;
      top -= this.view.offsetY * height / fullHeight;
      width *= this.view.width / fullWidth;
      height *= this.view.height / fullHeight;
    }
    makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far);
    mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
    mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this.triggerUpdate();
    return this;
  };
  _proto.setOrthographic = function setOrthographic(l, r, t, b, near, far) {
    var _this$view2;
    this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
    this.rright = r;
    this.left = l;
    this.top = t;
    this.bottom = b;
    this.near = near;
    this.far = far;
    var dx = (this.rright - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.rright + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.enabled) {
      var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
      var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    mat4_exports.ortho(this.projectionMatrix, left, right, bottom, top, near, far);
    mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
    mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this._getOrthoMatrix();
    this.triggerUpdate();
    return this;
  };
  _proto.setPosition = function setPosition(x, y, z) {
    if (y === void 0) {
      y = this.position[1];
    }
    if (z === void 0) {
      z = this.position[2];
    }
    var position = createVec3(x, y, z);
    this._setPosition(position);
    this.setFocalPoint(this.focalPoint);
    this.triggerUpdate();
    return this;
  };
  _proto.setFocalPoint = function setFocalPoint(x, y, z) {
    if (y === void 0) {
      y = this.focalPoint[1];
    }
    if (z === void 0) {
      z = this.focalPoint[2];
    }
    var up = vec3_exports.fromValues(0, 1, 0);
    this.focalPoint = createVec3(x, y, z);
    if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
      var d4 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      x = d4[0];
      y = d4[1];
      z = d4[2];
      var r = vec3_exports.length(d4);
      var el = rad2deg2(Math.asin(y / r));
      var az = 90 + rad2deg2(Math.atan2(z, x));
      var m = mat4_exports.create();
      mat4_exports.rotateY(m, m, deg2rad2(az));
      mat4_exports.rotateX(m, m, deg2rad2(el));
      up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m);
    }
    mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
    this._getAxes();
    this._getDistance();
    this._getAngles();
    this.triggerUpdate();
    return this;
  };
  _proto.getDistance = function getDistance() {
    return this.distance;
  };
  _proto.getDistanceVector = function getDistanceVector() {
    return this.distanceVector;
  };
  _proto.setDistance = function setDistance(d4) {
    if (this.distance === d4 || d4 < 0) {
      return this;
    }
    this.distance = d4;
    if (this.distance < MIN_DISTANCE) {
      this.distance = MIN_DISTANCE;
    }
    this.dollyingStep = this.distance / 100;
    var pos2 = vec3_exports.create();
    d4 = this.distance;
    var n = this.forward;
    var f = this.focalPoint;
    pos2[0] = d4 * n[0] + f[0];
    pos2[1] = d4 * n[1] + f[1];
    pos2[2] = d4 * n[2] + f[2];
    this._setPosition(pos2);
    this.triggerUpdate();
    return this;
  };
  _proto.setMaxDistance = function setMaxDistance(d4) {
    this.maxDistance = d4;
    return this;
  };
  _proto.setMinDistance = function setMinDistance(d4) {
    this.minDistance = d4;
    return this;
  };
  _proto.setAzimuth = function setAzimuth(az) {
    this.azimuth = getAngle3(az);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getAzimuth = function getAzimuth() {
    return this.azimuth;
  };
  _proto.setElevation = function setElevation(el) {
    this.elevation = getAngle3(el);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getElevation = function getElevation() {
    return this.elevation;
  };
  _proto.setRoll = function setRoll(angle3) {
    this.roll = getAngle3(angle3);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getRoll = function getRoll() {
    return this.roll;
  };
  _proto._update = function _update() {
    this._getAxes();
    this._getPosition();
    this._getDistance();
    this._getAngles();
    this._getOrthoMatrix();
    this.triggerUpdate();
  };
  _proto.computeMatrix = function computeMatrix() {
    var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad2(this.roll));
    mat4_exports.identity(this.matrix);
    var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
    var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
    var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
    rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
    var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
      mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
    } else if (this.type === CameraType.TRACKING) {
      mat4_exports.translate(this.matrix, this.matrix, this.position);
      mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
    }
  };
  _proto._setPosition = function _setPosition(x, y, z) {
    this.position = createVec3(x, y, z);
    var m = this.matrix;
    m[12] = this.position[0];
    m[13] = this.position[1];
    m[14] = this.position[2];
    m[15] = 1;
    this._getOrthoMatrix();
  };
  _proto._getAxes = function _getAxes() {
    vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
    vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
    vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
    vec3_exports.normalize(this.right, this.right);
    vec3_exports.normalize(this.up, this.up);
    vec3_exports.normalize(this.forward, this.forward);
  };
  _proto._getAngles = function _getAngles() {
    var x = this.distanceVector[0];
    var y = this.distanceVector[1];
    var z = this.distanceVector[2];
    var r = vec3_exports.length(this.distanceVector);
    if (r === 0) {
      this.elevation = 0;
      this.azimuth = 0;
      return;
    }
    if (this.type === CameraType.TRACKING) {
      this.elevation = rad2deg2(Math.asin(y / r));
      this.azimuth = rad2deg2(Math.atan2(-x, -z));
    } else {
      if (this.rotateWorld) {
        this.elevation = rad2deg2(Math.asin(y / r));
        this.azimuth = rad2deg2(Math.atan2(-x, -z));
      } else {
        this.elevation = -rad2deg2(Math.asin(y / r));
        this.azimuth = -rad2deg2(Math.atan2(-x, -z));
      }
    }
  };
  _proto._getPosition = function _getPosition() {
    vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
    this._getDistance();
  };
  _proto._getFocalPoint = function _getFocalPoint() {
    vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
    vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
    this._getDistance();
  };
  _proto._getDistance = function _getDistance() {
    this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
    this.distance = vec3_exports.length(this.distanceVector);
    this.dollyingStep = this.distance / 100;
  };
  _proto._getOrthoMatrix = function _getOrthoMatrix() {
    if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
      return;
    }
    var position = this.position;
    var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
    mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
  };
  _proto.triggerUpdate = function triggerUpdate() {
    if (this.enableUpdate) {
      var viewMatrix = this.getViewTransform();
      var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
      this.getFrustum().extractFromVPMatrix(vpMatrix);
      this.eventEmitter.emit(CameraEvent.UPDATED);
    }
  };
  _proto.rotate = function rotate5(azimuth, elevation, roll) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.pan = function pan(tx, ty) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.dolly = function dolly(value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.createLandmark = function createLandmark(name, params) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.gotoLandmark = function gotoLandmark(name, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  return Camera2;
}();
var CircleUpdater = function() {
  function CircleUpdater2() {
  }
  var _proto = CircleUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var r = parsedStyle.r;
    var width = r * 2;
    var height = r * 2;
    return {
      width,
      height
    };
  };
  return CircleUpdater2;
}();
var EllipseUpdater = function() {
  function EllipseUpdater2() {
  }
  var _proto = EllipseUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var rx = parsedStyle.rx, ry = parsedStyle.ry;
    var width = rx * 2;
    var height = ry * 2;
    return {
      width,
      height
    };
  };
  return EllipseUpdater2;
}();
var LineUpdater = function() {
  function LineUpdater2() {
  }
  var _proto = LineUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width,
      height
    };
  };
  return LineUpdater2;
}();
var PathUpdater = function() {
  function PathUpdater2() {
  }
  var _proto = PathUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var path = parsedStyle.path;
    var _path$rect = path.rect, width = _path$rect.width, height = _path$rect.height;
    return {
      width,
      height
    };
  };
  return PathUpdater2;
}();
var PolylineUpdater = function() {
  function PolylineUpdater2() {
  }
  var _proto = PolylineUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var points = parsedStyle.points.points;
    var minX = Math.min.apply(Math, points.map(function(point) {
      return point[0];
    }));
    var maxX = Math.max.apply(Math, points.map(function(point) {
      return point[0];
    }));
    var minY = Math.min.apply(Math, points.map(function(point) {
      return point[1];
    }));
    var maxY = Math.max.apply(Math, points.map(function(point) {
      return point[1];
    }));
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width,
      height
    };
  };
  return PolylineUpdater2;
}();
var RectUpdater = function() {
  function RectUpdater2() {
  }
  var _proto = RectUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var img = parsedStyle.img, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
    var contentWidth = width;
    var contentHeight = height;
    if (img && !is_string_default(img)) {
      if (!contentWidth) {
        contentWidth = img.width;
        parsedStyle.width = contentWidth;
      }
      if (!contentHeight) {
        contentHeight = img.height;
        parsedStyle.height = contentHeight;
      }
    }
    return {
      width: contentWidth,
      height: contentHeight
    };
  };
  return RectUpdater2;
}();
var TextUpdater = function() {
  function TextUpdater2(globalRuntime) {
    this.globalRuntime = void 0;
    this.globalRuntime = globalRuntime;
  }
  var _proto = TextUpdater2.prototype;
  _proto.isReadyToMeasure = function isReadyToMeasure(parsedStyle, object) {
    var text = parsedStyle.text, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, fontSize = parsedStyle.fontSize, fontStyle = parsedStyle.fontStyle, fontWeight = parsedStyle.fontWeight, fontVariant = parsedStyle.fontVariant, lineWidth = parsedStyle.lineWidth;
    return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !is_nil_default(lineWidth);
  };
  _proto.update = function update(parsedStyle, object) {
    var _object$ownerDocument, _object$ownerDocument2;
    var text = parsedStyle.text, textAlign = parsedStyle.textAlign, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, dx = parsedStyle.dx, dy = parsedStyle.dy;
    var _ref = (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : (_object$ownerDocument2 = _object$ownerDocument.defaultView) === null || _object$ownerDocument2 === void 0 ? void 0 : _object$ownerDocument2.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
    if (!this.isReadyToMeasure(parsedStyle, object)) {
      parsedStyle.metrics = {
        font: "",
        width: 0,
        height: 0,
        lines: [],
        lineWidths: [],
        lineHeight: 0,
        maxLineWidth: 0,
        fontProperties: {
          ascent: 0,
          descent: 0,
          fontSize: 0
        },
        lineMetrics: []
      };
      return {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0
      };
    }
    var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
    parsedStyle.metrics = metrics;
    var width = metrics.width, height = metrics.height, lineHeight = metrics.lineHeight, fontProperties = metrics.fontProperties;
    var halfExtents = [width / 2, height / 2, 0];
    var anchor = [0, 1];
    var lineXOffset = 0;
    if (textAlign === "center" || textAlign === "middle") {
      lineXOffset = lineWidth / 2;
      anchor = [0.5, 1];
    } else if (textAlign === "right" || textAlign === "end") {
      lineXOffset = lineWidth;
      anchor = [1, 1];
    }
    var lineYOffset = 0;
    if (textBaseline === "middle") {
      lineYOffset = halfExtents[1];
    } else if (textBaseline === "top" || textBaseline === "hanging") {
      lineYOffset = halfExtents[1] * 2;
    } else if (textBaseline === "alphabetic") {
      lineYOffset = lineHeight - fontProperties.ascent;
    } else if (textBaseline === "bottom" || textBaseline === "ideographic") {
      lineYOffset = 0;
    }
    if (dx) {
      lineXOffset += dx;
    }
    if (dy) {
      lineYOffset += dy;
    }
    parsedStyle.anchor = [anchor[0], anchor[1], 0];
    return {
      width: halfExtents[0] * 2,
      height: halfExtents[1] * 2,
      offsetX: lineXOffset,
      offsetY: lineYOffset
    };
  };
  return TextUpdater2;
}();
var PROPAGATION_LIMIT = 2048;
var EventService = function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    this.globalRuntime = void 0;
    this.context = void 0;
    this.rootTarget = void 0;
    this.emitter = new import_eventemitter3.default();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.pickHandler = void 0;
    this.tmpMatrix = mat4_exports.create();
    this.tmpVec3 = vec3_exports.create();
    this.onPointerDown = function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(from) {
        var e2, isRightButton, trackingData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.createPointerEvent(from);
              case 2:
                e2 = _context.sent;
                _this2.dispatchEvent(e2, "pointerdown");
                if (e2.pointerType === "touch") {
                  _this2.dispatchEvent(e2, "touchstart");
                } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                  isRightButton = e2.button === 2;
                  _this2.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
                }
                trackingData = _this2.trackingData(from.pointerId);
                trackingData.pressTargetsByButton[from.button] = e2.composedPath();
                _this2.freeEvent(e2);
              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    this.onPointerUp = function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(from) {
        var now, e2, isRightButton, trackingData, pressTarget, clickTarget, currentTarget, _isRightButton, _e$detail, clickEvent, clickHistory;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                now = performance.now();
                _context2.next = 3;
                return _this2.createPointerEvent(from);
              case 3:
                e2 = _context2.sent;
                _this2.dispatchEvent(e2, "pointerup");
                if (e2.pointerType === "touch") {
                  _this2.dispatchEvent(e2, "touchend");
                } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                  isRightButton = e2.button === 2;
                  _this2.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
                }
                trackingData = _this2.trackingData(from.pointerId);
                pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                clickTarget = pressTarget;
                if (pressTarget && !e2.composedPath().includes(pressTarget)) {
                  currentTarget = pressTarget;
                  while (currentTarget && !e2.composedPath().includes(currentTarget)) {
                    e2.currentTarget = currentTarget;
                    _this2.notifyTarget(e2, "pointerupoutside");
                    if (e2.pointerType === "touch") {
                      _this2.notifyTarget(e2, "touchendoutside");
                    } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                      _isRightButton = e2.button === 2;
                      _this2.notifyTarget(e2, _isRightButton ? "rightupoutside" : "mouseupoutside");
                    }
                    if (Node2.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                  clickTarget = currentTarget;
                }
                if (clickTarget) {
                  clickEvent = _this2.clonePointerEvent(e2, "click");
                  clickEvent.target = clickTarget;
                  clickEvent.path = [];
                  if (!trackingData.clicksByButton[from.button]) {
                    trackingData.clicksByButton[from.button] = {
                      clickCount: 0,
                      target: clickEvent.target,
                      timeStamp: now
                    };
                  }
                  clickHistory = trackingData.clicksByButton[from.button];
                  if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                    ++clickHistory.clickCount;
                  } else {
                    clickHistory.clickCount = 1;
                  }
                  clickHistory.target = clickEvent.target;
                  clickHistory.timeStamp = now;
                  clickEvent.detail = clickHistory.clickCount;
                  if (!((_e$detail = e2.detail) === null || _e$detail === void 0 ? void 0 : _e$detail.preventClick)) {
                    if (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch") {
                      _this2.dispatchEvent(clickEvent, "click");
                    }
                    _this2.dispatchEvent(clickEvent, "pointertap");
                  }
                  _this2.freeEvent(clickEvent);
                }
                _this2.freeEvent(e2);
              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    this.onPointerMove = function() {
      var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(from) {
        var e2, isMouse, trackingData, outTarget, outType, outEvent, leaveEvent, overType, overEvent, overTargetAncestor, didPointerEnter, enterEvent;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this2.createPointerEvent(from);
              case 2:
                e2 = _context3.sent;
                isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
                trackingData = _this2.trackingData(from.pointerId);
                outTarget = _this2.findMountedTarget(trackingData.overTargets);
                if (!(trackingData.overTargets && outTarget !== e2.target)) {
                  _context3.next = 21;
                  break;
                }
                outType = from.type === "mousemove" ? "mouseout" : "pointerout";
                _context3.next = 10;
                return _this2.createPointerEvent(from, outType, outTarget || void 0);
              case 10:
                outEvent = _context3.sent;
                _this2.dispatchEvent(outEvent, "pointerout");
                if (isMouse)
                  _this2.dispatchEvent(outEvent, "mouseout");
                if (e2.composedPath().includes(outTarget)) {
                  _context3.next = 20;
                  break;
                }
                _context3.next = 16;
                return _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
              case 16:
                leaveEvent = _context3.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this2.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this2.notifyTarget(leaveEvent, "mouseleave");
                  }
                  if (Node2.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                _this2.freeEvent(leaveEvent);
              case 20:
                _this2.freeEvent(outEvent);
              case 21:
                if (!(outTarget !== e2.target)) {
                  _context3.next = 36;
                  break;
                }
                overType = from.type === "mousemove" ? "mouseover" : "pointerover";
                overEvent = _this2.clonePointerEvent(e2, overType);
                _this2.dispatchEvent(overEvent, "pointerover");
                if (isMouse)
                  _this2.dispatchEvent(overEvent, "mouseover");
                overTargetAncestor = outTarget && Node2.isNode(outTarget) && outTarget.parentNode;
              case 27:
                if (!(overTargetAncestor && overTargetAncestor !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode))) {
                  _context3.next = 33;
                  break;
                }
                if (!(overTargetAncestor === e2.target)) {
                  _context3.next = 30;
                  break;
                }
                return _context3.abrupt("break", 33);
              case 30:
                overTargetAncestor = overTargetAncestor.parentNode;
                _context3.next = 27;
                break;
              case 33:
                didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
                if (didPointerEnter) {
                  enterEvent = _this2.clonePointerEvent(e2, "pointerenter");
                  enterEvent.eventPhase = enterEvent.AT_TARGET;
                  while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                    enterEvent.currentTarget = enterEvent.target;
                    _this2.notifyTarget(enterEvent);
                    if (isMouse)
                      _this2.notifyTarget(enterEvent, "mouseenter");
                    if (Node2.isNode(enterEvent.target)) {
                      enterEvent.target = enterEvent.target.parentNode;
                    }
                  }
                  _this2.freeEvent(enterEvent);
                }
                _this2.freeEvent(overEvent);
              case 36:
                _this2.dispatchEvent(e2, "pointermove");
                if (e2.pointerType === "touch")
                  _this2.dispatchEvent(e2, "touchmove");
                if (isMouse) {
                  _this2.dispatchEvent(e2, "mousemove");
                  _this2.cursor = _this2.getCursor(e2.target);
                }
                trackingData.overTargets = e2.composedPath();
                _this2.freeEvent(e2);
              case 41:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function(_x3) {
        return _ref3.apply(this, arguments);
      };
    }();
    this.onPointerOut = function() {
      var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(from) {
        var trackingData, isMouse, outTarget, outEvent, leaveEvent;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                if (!trackingData.overTargets) {
                  _context4.next = 17;
                  break;
                }
                isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
                outTarget = _this2.findMountedTarget(trackingData.overTargets);
                _context4.next = 6;
                return _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
              case 6:
                outEvent = _context4.sent;
                _this2.dispatchEvent(outEvent);
                if (isMouse)
                  _this2.dispatchEvent(outEvent, "mouseout");
                _context4.next = 11;
                return _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
              case 11:
                leaveEvent = _context4.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && leaveEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this2.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this2.notifyTarget(leaveEvent, "mouseleave");
                  }
                  if (Node2.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = null;
                _this2.freeEvent(outEvent);
                _this2.freeEvent(leaveEvent);
              case 17:
                _this2.cursor = null;
              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return function(_x4) {
        return _ref4.apply(this, arguments);
      };
    }();
    this.onPointerOver = function() {
      var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(from) {
        var trackingData, e2, isMouse, enterEvent;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                _context5.next = 3;
                return _this2.createPointerEvent(from);
              case 3:
                e2 = _context5.sent;
                isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
                _this2.dispatchEvent(e2, "pointerover");
                if (isMouse)
                  _this2.dispatchEvent(e2, "mouseover");
                if (e2.pointerType === "mouse")
                  _this2.cursor = _this2.getCursor(e2.target);
                enterEvent = _this2.clonePointerEvent(e2, "pointerenter");
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while (enterEvent.target && enterEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                  enterEvent.currentTarget = enterEvent.target;
                  _this2.notifyTarget(enterEvent);
                  if (isMouse) {
                    _this2.notifyTarget(enterEvent, "mouseenter");
                  }
                  if (Node2.isNode(enterEvent.target)) {
                    enterEvent.target = enterEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = e2.composedPath();
                _this2.freeEvent(e2);
                _this2.freeEvent(enterEvent);
              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return function(_x5) {
        return _ref5.apply(this, arguments);
      };
    }();
    this.onPointerUpOutside = function() {
      var _ref6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(from) {
        var trackingData, pressTarget, e2, currentTarget;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                _context6.next = 4;
                return _this2.createPointerEvent(from);
              case 4:
                e2 = _context6.sent;
                if (pressTarget) {
                  currentTarget = pressTarget;
                  while (currentTarget) {
                    e2.currentTarget = currentTarget;
                    _this2.notifyTarget(e2, "pointerupoutside");
                    if (e2.pointerType === "touch")
                      ;
                    else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                      _this2.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
                    }
                    if (Node2.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                }
                _this2.freeEvent(e2);
              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return function(_x6) {
        return _ref6.apply(this, arguments);
      };
    }();
    this.onWheel = function() {
      var _ref7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7(from) {
        var wheelEvent;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this2.createWheelEvent(from);
              case 2:
                wheelEvent = _context7.sent;
                _this2.dispatchEvent(wheelEvent);
                _this2.freeEvent(wheelEvent);
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      return function(_x7) {
        return _ref7.apply(this, arguments);
      };
    }();
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = EventService2.prototype;
  _proto.init = function init() {
    this.rootTarget = this.context.renderingContext.root.parentNode;
    this.addEventMapping("pointerdown", this.onPointerDown);
    this.addEventMapping("pointerup", this.onPointerUp);
    this.addEventMapping("pointermove", this.onPointerMove);
    this.addEventMapping("pointerout", this.onPointerOut);
    this.addEventMapping("pointerleave", this.onPointerOut);
    this.addEventMapping("pointerover", this.onPointerOver);
    this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
    this.addEventMapping("wheel", this.onWheel);
  };
  _proto.destroy = function destroy() {
    this.emitter.removeAllListeners();
    this.mappingTable = {};
    this.mappingState = {};
    this.eventPool.clear();
  };
  _proto.client2Viewport = function client2Viewport(client) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Canvas = function viewport2Canvas(_ref8) {
    var x = _ref8.x, y = _ref8.y;
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
    var projectionMatrixInverse = camera.getPerspectiveInverse();
    var worldMatrix = camera.getWorldTransform();
    var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
    var viewport = vec3_exports.set(this.tmpVec3, x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);
    vec3_exports.transformMat4(viewport, viewport, vpMatrix);
    return new Point(viewport[0], viewport[1]);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvasP) {
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var projectionMatrix = camera.getPerspective();
    var viewMatrix = camera.getViewTransform();
    var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
    var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
    vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
    var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
    return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
  };
  _proto.setPickHandler = function setPickHandler(pickHandler) {
    this.pickHandler = pickHandler;
  };
  _proto.addEventMapping = function addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort(function(a, b) {
      return a.priority - b.priority;
    });
  };
  _proto.mapEvent = function mapEvent(e2) {
    if (!this.rootTarget) {
      return;
    }
    var mappers = this.mappingTable[e2.type];
    if (mappers) {
      for (var i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e2);
      }
    } else {
      console.warn("[EventService]: Event mapping not defined for " + e2.type);
    }
  };
  _proto.dispatchEvent = function dispatchEvent(e2, type, skipPropagate) {
    if (!skipPropagate) {
      e2.propagationStopped = false;
      e2.propagationImmediatelyStopped = false;
      this.propagate(e2, type);
    } else {
      e2.eventPhase = e2.AT_TARGET;
      var canvas = this.rootTarget.defaultView || null;
      e2.currentTarget = canvas;
      this.notifyListeners(e2, type);
    }
    this.emitter.emit(type || e2.type, e2);
  };
  _proto.propagate = function propagate(e2, type) {
    if (!e2.target) {
      return;
    }
    var composedPath = e2.composedPath();
    e2.eventPhase = e2.CAPTURING_PHASE;
    for (var i = composedPath.length - 1; i >= 1; i--) {
      e2.currentTarget = composedPath[i];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
    e2.eventPhase = e2.AT_TARGET;
    e2.currentTarget = e2.target;
    this.notifyTarget(e2, type);
    if (e2.propagationStopped || e2.propagationImmediatelyStopped)
      return;
    var index = composedPath.indexOf(e2.currentTarget);
    e2.eventPhase = e2.BUBBLING_PHASE;
    for (var _i = index + 1; _i < composedPath.length; _i++) {
      e2.currentTarget = composedPath[_i];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
  };
  _proto.propagationPath = function propagationPath(target) {
    var propagationPath2 = [target];
    var canvas = this.rootTarget.defaultView || null;
    if (canvas && canvas === target) {
      propagationPath2.unshift(canvas.document);
      return propagationPath2;
    }
    for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (Node2.isNode(target) && target.parentNode) {
        propagationPath2.push(target.parentNode);
        target = target.parentNode;
      }
    }
    if (canvas) {
      propagationPath2.push(canvas);
    }
    return propagationPath2;
  };
  _proto.hitTest = function() {
    var _hitTest = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(position) {
      var viewportX, viewportY, _this$context$config3, width, height;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              viewportX = position.viewportX, viewportY = position.viewportY;
              _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context8.next = 4;
                break;
              }
              return _context8.abrupt("return", null);
            case 4:
              _context8.next = 6;
              return this.pickHandler(position);
            case 6:
              _context8.t1 = _context8.sent;
              if (_context8.t1) {
                _context8.next = 9;
                break;
              }
              _context8.t1 = this.rootTarget;
            case 9:
              _context8.t0 = _context8.t1;
              if (_context8.t0) {
                _context8.next = 12;
                break;
              }
              _context8.t0 = // return Document
              null;
            case 12:
              return _context8.abrupt("return", _context8.t0);
            case 13:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));
    function hitTest(_x8) {
      return _hitTest.apply(this, arguments);
    }
    return hitTest;
  }();
  _proto.isNativeEventFromCanvas = function isNativeEventFromCanvas(event) {
    var _event$nativeEvent;
    var $el = this.context.contextService.getDomElement();
    var target = (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.target;
    if (target) {
      if (target === $el) {
        return true;
      }
      if ($el && $el.contains) {
        return $el.contains(target);
      }
    }
    if (event.nativeEvent.composedPath) {
      return event.nativeEvent.composedPath().indexOf($el) > -1;
    }
    return false;
  };
  _proto.getExistedHTML = function getExistedHTML(event) {
    if (event.nativeEvent.composedPath) {
      var htmls = this.globalRuntime.displayObjectPool.getHTMLs();
      for (var _iterator = _createForOfIteratorHelperLoose(htmls), _step; !(_step = _iterator()).done; ) {
        var html = _step.value;
        if (event.nativeEvent.composedPath().indexOf(html) > -1) {
          return html;
        }
      }
    }
    return null;
  };
  _proto.pickTarget = function() {
    var _pickTarget = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(event) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", this.hitTest({
                clientX: event.clientX,
                clientY: event.clientY,
                viewportX: event.viewportX,
                viewportY: event.viewportY,
                x: event.canvasX,
                y: event.canvasY
              }));
            case 1:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));
    function pickTarget(_x9) {
      return _pickTarget.apply(this, arguments);
    }
    return pickTarget;
  }();
  _proto.createPointerEvent = function() {
    var _createPointerEvent = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(from, type, target) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              event = this.allocateEvent(FederatedPointerEvent);
              this.copyPointerData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              if (!(target !== null && target !== void 0)) {
                _context10.next = 11;
                break;
              }
              _context10.t0 = target;
              _context10.next = 20;
              break;
            case 11:
              _context10.t1 = existedHTML;
              if (_context10.t1) {
                _context10.next = 19;
                break;
              }
              _context10.t2 = this.isNativeEventFromCanvas(event);
              if (!_context10.t2) {
                _context10.next = 18;
                break;
              }
              _context10.next = 17;
              return this.pickTarget(event);
            case 17:
              _context10.t2 = _context10.sent;
            case 18:
              _context10.t1 = _context10.t2;
            case 19:
              _context10.t0 = _context10.t1;
            case 20:
              event.target = _context10.t0;
              if (typeof type === "string") {
                event.type = type;
              }
              return _context10.abrupt("return", event);
            case 23:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));
    function createPointerEvent(_x10, _x11, _x12) {
      return _createPointerEvent.apply(this, arguments);
    }
    return createPointerEvent;
  }();
  _proto.createWheelEvent = function() {
    var _createWheelEvent = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(from) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              event = this.allocateEvent(FederatedWheelEvent);
              this.copyWheelData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              _context11.t0 = existedHTML;
              if (_context11.t0) {
                _context11.next = 15;
                break;
              }
              _context11.t1 = this.isNativeEventFromCanvas(event);
              if (!_context11.t1) {
                _context11.next = 14;
                break;
              }
              _context11.next = 13;
              return this.pickTarget(event);
            case 13:
              _context11.t1 = _context11.sent;
            case 14:
              _context11.t0 = _context11.t1;
            case 15:
              event.target = _context11.t0;
              return _context11.abrupt("return", event);
            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));
    function createWheelEvent(_x13) {
      return _createWheelEvent.apply(this, arguments);
    }
    return createWheelEvent;
  }();
  _proto.trackingData = function trackingData(id2) {
    if (!this.mappingState.trackingData[id2]) {
      this.mappingState.trackingData[id2] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id2];
  };
  _proto.cloneWheelEvent = function cloneWheelEvent(from) {
    var event = this.allocateEvent(FederatedWheelEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = from.type;
    return event;
  };
  _proto.clonePointerEvent = function clonePointerEvent(from, type) {
    var event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type !== null && type !== void 0 ? type : event.type;
    return event;
  };
  _proto.copyPointerData = function copyPointerData(from, to) {
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  };
  _proto.copyMouseData = function copyMouseData(from, to) {
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.shiftKey = from.shiftKey;
    to.client.copyFrom(from.client);
    to.movement.copyFrom(from.movement);
    to.canvas.copyFrom(from.canvas);
    to.screen.copyFrom(from.screen);
    to.global.copyFrom(from.global);
    to.offset.copyFrom(from.offset);
  };
  _proto.copyWheelData = function copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  };
  _proto.copyData = function copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.page.copyFrom(from.page);
    to.viewport.copyFrom(from.viewport);
  };
  _proto.allocateEvent = function allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    var event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = [];
    event.target = null;
    return event;
  };
  _proto.freeEvent = function freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    var constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  };
  _proto.notifyTarget = function notifyTarget(e2, type) {
    var _type;
    type = (_type = type) !== null && _type !== void 0 ? _type : e2.type;
    var key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? type + "capture" : type;
    this.notifyListeners(e2, key);
    if (e2.eventPhase === e2.AT_TARGET) {
      this.notifyListeners(e2, type);
    }
  };
  _proto.notifyListeners = function notifyListeners(e2, type) {
    var emitter = e2.currentTarget.emitter;
    var listeners = emitter._events[type];
    if (!listeners)
      return;
    if ("fn" in listeners) {
      if (listeners.once) {
        emitter.removeListener(type, listeners.fn, void 0, true);
      }
      listeners.fn.call(e2.currentTarget || listeners.context, e2);
    } else {
      for (var i = 0; i < listeners.length && !e2.propagationImmediatelyStopped; i++) {
        if (listeners[i].once) {
          emitter.removeListener(type, listeners[i].fn, void 0, true);
        }
        listeners[i].fn.call(e2.currentTarget || listeners[i].context, e2);
      }
    }
  };
  _proto.findMountedTarget = function findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    var currentTarget = propagationPath[propagationPath.length - 1];
    for (var i = propagationPath.length - 2; i >= 0; i--) {
      var target = propagationPath[i];
      if (target === this.rootTarget || Node2.isNode(target) && target.parentNode === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  };
  _proto.getCursor = function getCursor(target) {
    var tmp2 = target;
    while (tmp2) {
      var cursor = Element2.isElement(tmp2) && tmp2.getAttribute("cursor");
      if (cursor) {
        return cursor;
      }
      tmp2 = Node2.isNode(tmp2) && tmp2.parentNode;
    }
  };
  return EventService2;
}();
var OffscreenCanvasCreator = function() {
  function OffscreenCanvasCreator2() {
    this.canvas = void 0;
    this.context = void 0;
  }
  var _proto = OffscreenCanvasCreator2.prototype;
  _proto.getOrCreateCanvas = function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
    if (this.canvas) {
      return this.canvas;
    }
    if (offscreenCanvas) {
      this.canvas = offscreenCanvas;
      this.context = this.canvas.getContext("2d", contextAttributes);
    } else {
      try {
        this.canvas = new window.OffscreenCanvas(0, 0);
        this.context = this.canvas.getContext("2d", contextAttributes);
        if (!this.context || !this.context.measureText) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d");
        }
      } catch (ex) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d", contextAttributes);
      }
    }
    this.canvas.width = 10;
    this.canvas.height = 10;
    return this.canvas;
  };
  _proto.getOrCreateContext = function getOrCreateContext(offscreenCanvas, contextAttributes) {
    if (this.context) {
      return this.context;
    }
    this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
    return this.context;
  };
  return OffscreenCanvasCreator2;
}();
var RenderReason;
(function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
})(RenderReason || (RenderReason = {}));
var RenderingService = function() {
  function RenderingService2(globalRuntime, context) {
    this.globalRuntime = void 0;
    this.context = void 0;
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.renderOrderChangedEvent = new CustomEvent(ElementEvent.RENDER_ORDER_CHANGED);
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(["object"]),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(["object", "camera"]),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook([]),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(["objectToRender"]),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(["objectToRender"]),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(["objectToRender"]),
      endFrame: new SyncHook([]),
      destroy: new SyncHook([]),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(["result"]),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(["result"]),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(["event"]),
      pointerUp: new SyncHook(["event"]),
      pointerMove: new SyncHook(["event"]),
      pointerOut: new SyncHook(["event"]),
      pointerOver: new SyncHook(["event"]),
      pointerWheel: new SyncHook(["event"]),
      pointerCancel: new SyncHook(["event"])
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = RenderingService2.prototype;
  _proto.init = function() {
    var _init = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      var context;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _extends({}, this.globalRuntime, this.context);
              this.context.renderingPlugins.forEach(function(plugin) {
                plugin.apply(context, runtime);
              });
              _context.next = 4;
              return this.hooks.init.promise();
            case 4:
              this.inited = true;
            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function init() {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.getStats = function getStats() {
    return this.stats;
  };
  _proto.disableDirtyRectangleRendering = function disableDirtyRectangleRendering() {
    var renderer = this.context.config.renderer;
    var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
    return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
  };
  _proto.render = function render3(canvasConfig, rerenderCallback) {
    var _this2 = this;
    this.stats.total = 0;
    this.stats.rendered = 0;
    this.zIndexCounter = 0;
    var renderingContext = this.context.renderingContext;
    this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
    this.globalRuntime.sceneGraphService.triggerPendingEvents();
    if (renderingContext.renderReasons.size && this.inited) {
      this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
      this.hooks.beginFrame.call();
      renderingContext.renderListCurrentFrame.forEach(function(object) {
        _this2.hooks.beforeRender.call(object);
        _this2.hooks.render.call(object);
        _this2.hooks.afterRender.call(object);
      });
      this.hooks.endFrame.call();
      renderingContext.renderListCurrentFrame = [];
      renderingContext.renderReasons.clear();
      rerenderCallback();
    }
  };
  _proto.renderDisplayObject = function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
    var _this2 = this;
    var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
    if (this.globalRuntime.enableCSSParsing) {
      this.globalRuntime.styleValueRegistry.recalc(displayObject);
    }
    var objectChanged = enableDirtyCheck ? this.hooks.dirtycheck.call(displayObject) : displayObject;
    if (objectChanged) {
      var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
      if (objectToRender) {
        this.stats.rendered++;
        renderingContext.renderListCurrentFrame.push(objectToRender);
      }
    }
    displayObject.renderable.dirty = false;
    displayObject.sortable.renderOrder = this.zIndexCounter++;
    this.stats.total++;
    var sortable = displayObject.sortable;
    var renderOrderChanged = false;
    if (sortable.dirty) {
      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      renderOrderChanged = true;
      sortable.dirty = false;
    }
    (sortable.sorted || displayObject.childNodes).forEach(function(child) {
      _this2.renderDisplayObject(child, canvasConfig, renderingContext);
    });
    if (renderOrderChanged) {
      displayObject.forEach(function(child) {
        _this2.renderOrderChangedEvent.target = child;
        _this2.renderOrderChangedEvent.detail = {
          renderOrder: child.sortable.renderOrder
        };
        child.ownerDocument.defaultView.dispatchEvent(_this2.renderOrderChangedEvent, true);
      });
    }
  };
  _proto.destroy = function destroy() {
    this.inited = false;
    this.hooks.destroy.call();
    this.globalRuntime.sceneGraphService.clearPendingEvents();
  };
  _proto.dirtify = function dirtify() {
    this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
  };
  return RenderingService2;
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = function() {
  function DefaultSceneGraphSelector2() {
  }
  var _proto = DefaultSceneGraphSelector2.prototype;
  _proto.selectOne = function selectOne(query, root2) {
    var _this2 = this;
    if (query.startsWith(".")) {
      return root2.find(function(node) {
        return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith("#")) {
      return root2.find(function(node) {
        return node.id === _this2.getIdOrClassname(query);
      });
    } else if (query.startsWith("[")) {
      var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
      if (name) {
        return root2.find(function(node) {
          return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
        });
      } else {
        return null;
      }
    } else {
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  };
  _proto.selectAll = function selectAll(query, root2) {
    var _this2 = this;
    if (query.startsWith(".")) {
      return root2.findAll(function(node) {
        return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith("#")) {
      return root2.findAll(function(node) {
        return root2 !== node && node.id === _this2.getIdOrClassname(query);
      });
    } else if (query.startsWith("[")) {
      var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
      if (name) {
        return root2.findAll(function(node) {
          return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
        });
      } else {
        return [];
      }
    } else {
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  };
  _proto.is = function is(query, node) {
    if (query.startsWith(".")) {
      return node.className === this.getIdOrClassname(query);
    } else if (query.startsWith("#")) {
      return node.id === this.getIdOrClassname(query);
    } else if (query.startsWith("[")) {
      var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
      return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
    } else {
      return node.nodeName === query;
    }
  };
  _proto.getIdOrClassname = function getIdOrClassname(query) {
    return query.substring(1);
  };
  _proto.getAttribute = function getAttribute(query) {
    var matches = query.match(ATTRIBUTE_REGEXP);
    var name = "";
    var value = "";
    if (matches && matches.length > 2) {
      name = matches[1].replace(/"/g, "");
      value = matches[2].replace(/"/g, "");
    }
    return {
      name,
      value
    };
  };
  _proto.attributeToString = function attributeToString(node, name) {
    if (!node.getAttribute) {
      return "";
    }
    var value = node.getAttribute(name);
    if (is_nil_default(value)) {
      return "";
    }
    if (value.toString) {
      return value.toString();
    }
    return "";
  };
  return DefaultSceneGraphSelector2;
}();
function markRenderableDirty(e2) {
  var renderable = e2.renderable;
  if (renderable) {
    renderable.renderBoundsDirty = true;
    renderable.boundsDirty = true;
  }
}
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var DefaultSceneGraphService = function() {
  function DefaultSceneGraphService2(runtime2) {
    var _this2 = this;
    this.runtime = void 0;
    this.pendingEvents = [];
    this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
    this.rotate = function() {
      var parentInvertRotation = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.rotateLocal(element, degrees);
        } else {
          var rotation = quat_exports.create();
          quat_exports.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
          var rot = _this2.getRotation(element);
          var parentRot = _this2.getRotation(element.parentNode);
          quat_exports.copy(parentInvertRotation, parentRot);
          quat_exports.invert(parentInvertRotation, parentInvertRotation);
          quat_exports.multiply(rotation, parentInvertRotation, rotation);
          quat_exports.multiply(transform.localRotation, rotation, rot);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          _this2.dirtifyLocal(element, transform);
        }
      };
    }();
    this.rotateLocal = function() {
      var rotation = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        quat_exports.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        quat_exports.mul(transform.localRotation, transform.localRotation, rotation);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setEulerAngles = function() {
      var invParentRot = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.setLocalEulerAngles(element, degrees);
        } else {
          quat_exports.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
          var parentRotation = _this2.getRotation(element.parentNode);
          quat_exports.copy(invParentRot, quat_exports.invert(quat_exports.create(), parentRotation));
          quat_exports.mul(transform.localRotation, transform.localRotation, invParentRot);
          _this2.dirtifyLocal(element, transform);
        }
      };
    }();
    this.translateLocal = function() {
      return function(element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === "number") {
          translation = vec3_exports.fromValues(translation, y, z);
        }
        var transform = element.transformable;
        if (vec3_exports.equals(translation, vec3_exports.create())) {
          return;
        }
        vec3_exports.transformQuat(translation, translation, transform.localRotation);
        vec3_exports.add(transform.localPosition, transform.localPosition, translation);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setPosition = function() {
      var parentInvertMatrix = mat4_exports.create();
      var tmpPosition = vec3_exports.create();
      return function(element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (vec3_exports.equals(_this2.getPosition(element), tmpPosition)) {
          return;
        }
        vec3_exports.copy(transform.position, tmpPosition);
        if (element.parentNode === null || !element.parentNode.transformable) {
          vec3_exports.copy(transform.localPosition, tmpPosition);
        } else {
          var parentTransform = element.parentNode.transformable;
          mat4_exports.copy(parentInvertMatrix, parentTransform.worldTransform);
          mat4_exports.invert(parentInvertMatrix, parentInvertMatrix);
          vec3_exports.transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
        }
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setLocalPosition = function() {
      var tmpPosition = vec3_exports.create();
      return function(element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (vec3_exports.equals(transform.localPosition, tmpPosition)) {
          return;
        }
        vec3_exports.copy(transform.localPosition, tmpPosition);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.translate = function() {
      var zeroVec3 = vec3_exports.create();
      var tmpVec3 = vec3_exports.create();
      var tr = vec3_exports.create();
      return function(element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === "number") {
          translation = vec3_exports.set(tmpVec3, translation, y, z);
        }
        if (vec3_exports.equals(translation, zeroVec3)) {
          return;
        }
        vec3_exports.add(tr, _this2.getPosition(element), translation);
        _this2.setPosition(element, tr);
      };
    }();
    this.setRotation = function() {
      var parentInvertRotation = quat_exports.create();
      return function(element, rotation, y, z, w) {
        var transform = element.transformable;
        if (typeof rotation === "number") {
          rotation = quat_exports.fromValues(rotation, y, z, w);
        }
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.setLocalRotation(element, rotation);
        } else {
          var parentRot = _this2.getRotation(element.parentNode);
          quat_exports.copy(parentInvertRotation, parentRot);
          quat_exports.invert(parentInvertRotation, parentInvertRotation);
          quat_exports.multiply(transform.localRotation, parentInvertRotation, rotation);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          _this2.dirtifyLocal(element, transform);
        }
      };
    };
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.calcLocalTransform = function() {
      var tmpMat = mat4_exports.create();
      var tmpPosition = vec3_exports.create();
      var tmpQuat = quat_exports.fromValues(0, 0, 0, 1);
      return function(transform) {
        var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
        if (hasSkew) {
          mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, vec3_exports.fromValues(1, 1, 1), transform.origin);
          if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
            var tmpMat43 = mat4_exports.identity(tmpMat);
            tmpMat43[4] = Math.tan(transform.localSkew[0]);
            tmpMat43[1] = Math.tan(transform.localSkew[1]);
            mat4_exports.multiply(transform.localTransform, transform.localTransform, tmpMat43);
          }
          var scaling = mat4_exports.fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
          mat4_exports.multiply(transform.localTransform, transform.localTransform, scaling);
        } else {
          mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
        }
      };
    }();
    this.runtime = runtime2;
  }
  var _proto = DefaultSceneGraphService2.prototype;
  _proto.matches = function matches(query, root2) {
    return this.runtime.sceneGraphSelector.is(query, root2);
  };
  _proto.querySelector = function querySelector(query, root2) {
    return this.runtime.sceneGraphSelector.selectOne(query, root2);
  };
  _proto.querySelectorAll = function querySelectorAll(query, root2) {
    return this.runtime.sceneGraphSelector.selectAll(query, root2);
  };
  _proto.attach = function attach(child, parent, index) {
    var _sortable$sorted, _child$style;
    var detached = false;
    if (child.parentNode) {
      detached = child.parentNode !== parent;
      this.detach(child);
    }
    child.parentNode = parent;
    if (!is_nil_default(index)) {
      child.parentNode.childNodes.splice(index, 0, child);
    } else {
      child.parentNode.childNodes.push(child);
    }
    var sortable = parent.sortable;
    if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) || ((_child$style = child.style) === null || _child$style === void 0 ? void 0 : _child$style.zIndex)) {
      sortable.dirty = true;
    }
    var transform = child.transformable;
    if (transform) {
      this.dirtifyWorld(child, transform);
    }
    if (transform.frozen) {
      this.unfreezeParentToRoot(child);
    }
    if (detached) {
      child.dispatchEvent(reparentEvent);
    }
  };
  _proto.detach = function detach(child) {
    if (child.parentNode) {
      var _sortable$sorted2, _child$style2;
      var transform = child.transformable;
      var sortable = child.parentNode.sortable;
      if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) || ((_child$style2 = child.style) === null || _child$style2 === void 0 ? void 0 : _child$style2.zIndex)) {
        sortable.dirty = true;
      }
      var index = child.parentNode.childNodes.indexOf(child);
      if (index > -1) {
        child.parentNode.childNodes.splice(index, 1);
      }
      if (transform) {
        this.dirtifyWorld(child, transform);
      }
      child.parentNode = null;
    }
  };
  _proto.getOrigin = function getOrigin(element) {
    return element.transformable.origin;
  };
  _proto.setOrigin = function setOrigin(element, origin, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof origin === "number") {
      origin = vec3_exports.fromValues(origin, y, z);
    }
    var transform = element.transformable;
    if (vec3_exports.equals(origin, transform.origin)) {
      return;
    }
    var originVec = transform.origin;
    originVec[0] = origin[0];
    originVec[1] = origin[1];
    originVec[2] = origin[2] || 0;
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalEulerAngles = function setLocalEulerAngles(element, degrees, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof degrees === "number") {
      degrees = vec3_exports.fromValues(degrees, y, z);
    }
    var transform = element.transformable;
    quat_exports.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
    this.dirtifyLocal(element, transform);
  };
  _proto.scaleLocal = function scaleLocal(element, scaling) {
    var transform = element.transformable;
    vec3_exports.multiply(transform.localScale, transform.localScale, vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || 1));
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalScale = function setLocalScale(element, scaling) {
    var transform = element.transformable;
    var updatedScaling = vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
    if (vec3_exports.equals(updatedScaling, transform.localScale)) {
      return;
    }
    vec3_exports.copy(transform.localScale, updatedScaling);
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalRotation = function setLocalRotation(element, rotation, y, z, w) {
    if (typeof rotation === "number") {
      rotation = quat_exports.fromValues(rotation, y, z, w);
    }
    var transform = element.transformable;
    quat_exports.copy(transform.localRotation, rotation);
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalSkew = function setLocalSkew(element, skew, y) {
    if (typeof skew === "number") {
      skew = vec2_exports.fromValues(skew, y);
    }
    var transform = element.transformable;
    vec2_exports.copy(transform.localSkew, skew);
    this.dirtifyLocal(element, transform);
  };
  _proto.dirtifyLocal = function dirtifyLocal(element, transform) {
    if (!transform.localDirtyFlag) {
      transform.localDirtyFlag = true;
      if (!transform.dirtyFlag) {
        this.dirtifyWorld(element, transform);
      }
    }
  };
  _proto.dirtifyWorld = function dirtifyWorld(element, transform) {
    if (!transform.dirtyFlag) {
      this.unfreezeParentToRoot(element);
    }
    this.dirtifyWorldInternal(element, transform);
    this.dirtifyToRoot(element, true);
  };
  _proto.triggerPendingEvents = function triggerPendingEvents() {
    var _this2 = this;
    var set7 = /* @__PURE__ */ new Set();
    var trigger = function trigger2(element, detail) {
      if (element.isConnected && !set7.has(element.entity)) {
        _this2.boundsChangedEvent.detail = detail;
        _this2.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this2.boundsChangedEvent);
        } else {
          element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
        }
        set7.add(element.entity);
      }
    };
    this.pendingEvents.forEach(function(_ref) {
      var element = _ref[0], detail = _ref[1];
      if (detail.affectChildren) {
        element.forEach(function(e2) {
          trigger(e2, detail);
        });
      } else {
        trigger(element, detail);
      }
    });
    this.clearPendingEvents();
    set7.clear();
  };
  _proto.clearPendingEvents = function clearPendingEvents() {
    this.pendingEvents = [];
  };
  _proto.dirtifyToRoot = function dirtifyToRoot(element, affectChildren) {
    if (affectChildren === void 0) {
      affectChildren = false;
    }
    var p = element;
    if (p.renderable) {
      p.renderable.dirty = true;
    }
    while (p) {
      markRenderableDirty(p);
      p = p.parentNode;
    }
    if (affectChildren) {
      element.forEach(function(e2) {
        markRenderableDirty(e2);
      });
    }
    this.informDependentDisplayObjects(element);
    this.pendingEvents.push([element, {
      affectChildren
    }]);
  };
  _proto.updateDisplayObjectDependency = function updateDisplayObjectDependency(name, oldPath, newPath, object) {
    if (oldPath && oldPath !== newPath) {
      var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
      if (oldDependencyMap && oldDependencyMap[name]) {
        var index = oldDependencyMap[name].indexOf(object);
        oldDependencyMap[name].splice(index, 1);
      }
    }
    if (newPath) {
      var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      if (!newDependencyMap) {
        this.displayObjectDependencyMap.set(newPath, {});
        newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      }
      if (!newDependencyMap[name]) {
        newDependencyMap[name] = [];
      }
      newDependencyMap[name].push(object);
    }
  };
  _proto.informDependentDisplayObjects = function informDependentDisplayObjects(object) {
    var _this3 = this;
    var dependencyMap = this.displayObjectDependencyMap.get(object);
    if (dependencyMap) {
      Object.keys(dependencyMap).forEach(function(name) {
        dependencyMap[name].forEach(function(target) {
          _this3.dirtifyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this3, _this3, name, MutationEvent.MODIFICATION, _this3, _this3));
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name, _this3, _this3);
            }
          }
        });
      });
    }
  };
  _proto.getPosition = function getPosition2(element) {
    var transform = element.transformable;
    return mat4_exports.getTranslation(transform.position, this.getWorldTransform(element, transform));
  };
  _proto.getRotation = function getRotation2(element) {
    var transform = element.transformable;
    return mat4_exports.getRotation(transform.rotation, this.getWorldTransform(element, transform));
  };
  _proto.getScale = function getScale(element) {
    var transform = element.transformable;
    return mat4_exports.getScaling(transform.scaling, this.getWorldTransform(element, transform));
  };
  _proto.getWorldTransform = function getWorldTransform(element, transform) {
    if (transform === void 0) {
      transform = element.transformable;
    }
    if (!transform.localDirtyFlag && !transform.dirtyFlag) {
      return transform.worldTransform;
    }
    if (element.parentNode && element.parentNode.transformable) {
      this.getWorldTransform(element.parentNode);
    }
    this.sync(element, transform);
    return transform.worldTransform;
  };
  _proto.getLocalPosition = function getLocalPosition(element) {
    return element.transformable.localPosition;
  };
  _proto.getLocalRotation = function getLocalRotation(element) {
    return element.transformable.localRotation;
  };
  _proto.getLocalScale = function getLocalScale(element) {
    return element.transformable.localScale;
  };
  _proto.getLocalSkew = function getLocalSkew(element) {
    return element.transformable.localSkew;
  };
  _proto.getLocalTransform = function getLocalTransform(element) {
    var transform = element.transformable;
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    return transform.localTransform;
  };
  _proto.setLocalTransform = function setLocalTransform(element, transform) {
    var t = mat4_exports.getTranslation(vec3_exports.create(), transform);
    var r = mat4_exports.getRotation(quat_exports.create(), transform);
    var s2 = mat4_exports.getScaling(vec3_exports.create(), transform);
    this.setLocalScale(element, s2);
    this.setLocalPosition(element, t);
    this.setLocalRotation(element, r);
  };
  _proto.resetLocalTransform = function resetLocalTransform(element) {
    this.setLocalScale(element, [1, 1, 1]);
    this.setLocalPosition(element, [0, 0, 0]);
    this.setLocalEulerAngles(element, [0, 0, 0]);
    this.setLocalSkew(element, [0, 0]);
  };
  _proto.getTransformedGeometryBounds = function getTransformedGeometryBounds(element, render3, existedAABB) {
    if (render3 === void 0) {
      render3 = false;
    }
    var bounds = this.getGeometryBounds(element, render3);
    if (!AABB.isEmpty(bounds)) {
      var aabb = existedAABB || new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      return aabb;
    } else {
      return null;
    }
  };
  _proto.getGeometryBounds = function getGeometryBounds(element, render3) {
    if (render3 === void 0) {
      render3 = false;
    }
    var geometry = element.geometry;
    var bounds = render3 ? geometry.renderBounds : geometry.contentBounds || null;
    return bounds || new AABB();
  };
  _proto.getBounds = function getBounds(element, render3) {
    var _this4 = this;
    if (render3 === void 0) {
      render3 = false;
    }
    var renderable = element.renderable;
    if (!renderable.boundsDirty && !render3 && renderable.bounds) {
      return renderable.bounds;
    }
    if (!renderable.renderBoundsDirty && render3 && renderable.renderBounds) {
      return renderable.renderBounds;
    }
    var existedAABB = render3 ? renderable.renderBounds : renderable.bounds;
    var aabb = this.getTransformedGeometryBounds(element, render3, existedAABB);
    var children = element.childNodes;
    children.forEach(function(child) {
      var childBounds = _this4.getBounds(child, render3);
      if (childBounds) {
        if (!aabb) {
          aabb = existedAABB || new AABB();
          aabb.update(childBounds.center, childBounds.halfExtents);
        } else {
          aabb.add(childBounds);
        }
      }
    });
    if (render3) {
      var clipped = findClosestClipPathTarget(element);
      if (clipped) {
        var clipPathBounds = clipped.style.clipPath.getBounds(render3);
        if (!aabb) {
          aabb = clipPathBounds;
        } else if (clipPathBounds) {
          aabb = clipPathBounds.intersection(aabb);
        }
      }
    }
    if (!aabb) {
      aabb = new AABB();
    }
    if (aabb) {
      if (render3) {
        renderable.renderBounds = aabb;
      } else {
        renderable.bounds = aabb;
      }
    }
    if (render3) {
      renderable.renderBoundsDirty = false;
    } else {
      renderable.boundsDirty = false;
    }
    return aabb;
  };
  _proto.getLocalBounds = function getLocalBounds(element) {
    if (element.parentNode) {
      var parentInvert = mat4_exports.create();
      if (element.parentNode.transformable) {
        parentInvert = mat4_exports.invert(mat4_exports.create(), this.getWorldTransform(element.parentNode));
      }
      var bounds = this.getBounds(element);
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds(element);
  };
  _proto.getBoundingClientRect = function getBoundingClientRect(element) {
    var _element$ownerDocumen, _element$ownerDocumen2;
    var aabb;
    var bounds = this.getGeometryBounds(element);
    if (!AABB.isEmpty(bounds)) {
      aabb = new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
    }
    var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : (_element$ownerDocumen2 = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.getContextService().getBoundingClientRect();
    if (aabb) {
      var _aabb$getMin = aabb.getMin(), left = _aabb$getMin[0], top = _aabb$getMin[1];
      var _aabb$getMax = aabb.getMax(), right = _aabb$getMax[0], bottom = _aabb$getMax[1];
      return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
    }
    return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
  };
  _proto.dirtifyWorldInternal = function dirtifyWorldInternal(element, transform) {
    var _this5 = this;
    if (!transform.dirtyFlag) {
      transform.dirtyFlag = true;
      transform.frozen = false;
      element.childNodes.forEach(function(child) {
        var childTransform = child.transformable;
        if (!childTransform.dirtyFlag) {
          _this5.dirtifyWorldInternal(child, childTransform);
        }
      });
      var renderable = element.renderable;
      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }
    }
  };
  _proto.syncHierarchy = function syncHierarchy(element) {
    var transform = element.transformable;
    if (transform.frozen) {
      return;
    }
    transform.frozen = true;
    if (transform.localDirtyFlag || transform.dirtyFlag) {
      this.sync(element, transform);
    }
    var children = element.childNodes;
    for (var i = 0; i < children.length; i++) {
      this.syncHierarchy(children[i]);
    }
  };
  _proto.sync = function sync(element, transform) {
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    if (transform.dirtyFlag) {
      var parent = element.parentNode;
      var parentTransform = parent && parent.transformable;
      if (parent === null || !parentTransform) {
        mat4_exports.copy(transform.worldTransform, transform.localTransform);
      } else {
        mat4_exports.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
      }
      transform.dirtyFlag = false;
    }
  };
  _proto.unfreezeParentToRoot = function unfreezeParentToRoot(child) {
    var p = child.parentNode;
    while (p) {
      var transform = p.transformable;
      if (transform) {
        transform.frozen = false;
      }
      p = p.parentNode;
    }
  };
  return DefaultSceneGraphService2;
}();
var TEXT_METRICS = {
  MetricsString: "|q",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}'""]/;
var regexCannotEndZhCn = /[$('"]/;
var regexCannotStartZhTw = /[!),.:;?\]}'""]/;
var regexCannotEndZhTw = /[([{'"]/;
var regexCannotStartJaJp = /[)\]'"?!:;,.]/;
var regexCannotEndJaJp = /[(['"...]/;
var regexCannotStartKoKr = /[!%),.:;?\]}'"]/;
var regexCannotEndKoKr = /[$([{'"#]/;
var regexCannotStart = new RegExp(regexCannotStartZhCn.source + "|" + regexCannotStartZhTw.source + "|" + regexCannotStartJaJp.source + "|" + regexCannotStartKoKr.source);
var regexCannotEnd = new RegExp(regexCannotEndZhCn.source + "|" + regexCannotEndZhTw.source + "|" + regexCannotEndJaJp.source + "|" + regexCannotEndKoKr.source);
var TextService = function() {
  function TextService2(runtime2) {
    var _this2 = this;
    this.runtime = void 0;
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(char, nextChar) {
      if (_this2.isBreakingSpace(nextChar))
        return false;
      if (char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = [].concat(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
  }
  var _proto = TextService2.prototype;
  _proto.measureFont = function measureFont(font, offscreenCanvas) {
    if (this.fontMetricsCache[font]) {
      return this.fontMetricsCache[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas = this.runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
    var width = Math.ceil(context.measureText(metricsString).width);
    var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
    var height = TEXT_METRICS.HeightMultiplier * baseline;
    baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
    var pixels = imagedata.length;
    var line3 = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; ++i) {
      for (var j = 0; j < line3; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line3;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line3;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (var _j = 0; _j < line3; _j += 4) {
        if (imagedata[idx + _j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line3;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    this.fontMetricsCache[font] = properties;
    return properties;
  };
  _proto.measureText = function measureText2(text, parsedStyle, offscreenCanvas) {
    var fontSize = parsedStyle.fontSize, wordWrap = parsedStyle.wordWrap, strokeHeight = parsedStyle.lineHeight, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, textAlign = parsedStyle.textAlign, letterSpacing = parsedStyle.letterSpacing, textPath = parsedStyle.textPath, textPathSide = parsedStyle.textPathSide, textPathStartOffset = parsedStyle.textPathStartOffset, _parsedStyle$leading = parsedStyle.leading, leading2 = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
    var font = toFontString(parsedStyle);
    var fontProperties = this.measureFont(font, offscreenCanvas);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = fontSize;
      fontProperties.ascent = fontSize;
    }
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    parsedStyle.isOverflowing = false;
    var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    if (textPath) {
      var totalPathLength = textPath.getTotalLength();
      for (var i = 0; i < lines.length; i++) {
        var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
      }
    } else {
      for (var _i = 0; _i < lines.length; _i++) {
        var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
        lineWidths[_i] = _lineWidth;
        maxLineWidth = Math.max(maxLineWidth, _lineWidth);
      }
      var _width = maxLineWidth + lineWidth;
      var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
      var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading2);
      lineHeight += leading2;
      var offsetY = 0;
      if (textBaseline === "middle") {
        offsetY = -height / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        offsetY = -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        offsetY = 0;
      }
      return {
        font,
        width: _width,
        height,
        lines,
        lineWidths,
        lineHeight,
        maxLineWidth,
        fontProperties,
        lineMetrics: lineWidths.map(function(width2, i2) {
          var offsetX = 0;
          if (textAlign === "center" || textAlign === "middle") {
            offsetX -= width2 / 2;
          } else if (textAlign === "right" || textAlign === "end") {
            offsetX -= width2;
          }
          return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width2 + lineWidth, lineHeight);
        })
      };
    }
  };
  _proto.setGraphemeOnPath = function setGraphemeOnPath() {
  };
  _proto.wordWrap = function wordWrap(text, parsedStyle, offscreenCanvas) {
    var _this2 = this;
    var _parsedStyle$wordWrap = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap === void 0 ? 0 : _parsedStyle$wordWrap, letterSpacing = parsedStyle.letterSpacing, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    var maxWidth = wordWrapWidth + letterSpacing;
    var ellipsis = "";
    if (textOverflow === "ellipsis") {
      ellipsis = "...";
    } else if (textOverflow && textOverflow !== "clip") {
      ellipsis = textOverflow;
    }
    var lines = [];
    var currentIndex = 0;
    var currentWidth = 0;
    var cache = {};
    var calcWidth = function calcWidth2(char2) {
      return _this2.getFromCache(char2, letterSpacing, cache, context);
    };
    var ellipsisWidth = Array.from(ellipsis).reduce(function(prev, cur) {
      return prev + calcWidth(cur);
    }, 0);
    var chars = Array.from(text);
    for (var i = 0; i < chars.length; i++) {
      var char = chars[i];
      var prevChar = text[i - 1];
      var nextChar = text[i + 1];
      var charWidth = calcWidth(char);
      if (this.isNewline(char)) {
        currentIndex++;
        if (currentIndex >= maxLines) {
          parsedStyle.isOverflowing = true;
          break;
        }
        currentWidth = 0;
        lines[currentIndex] = "";
        continue;
      }
      if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
        if (currentIndex + 1 >= maxLines) {
          parsedStyle.isOverflowing = true;
          if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
            var currentLineLength = lines[currentIndex].length;
            var lastLineWidth = 0;
            var lastLineIndex = currentLineLength;
            for (var _i2 = 0; _i2 < currentLineLength; _i2++) {
              var width = calcWidth(lines[currentIndex][_i2]);
              if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                lastLineIndex = _i2;
                break;
              }
              lastLineWidth += width;
            }
            lines[currentIndex] = (lines[currentIndex] || "").slice(0, lastLineIndex) + ellipsis;
          }
          break;
        }
        currentIndex++;
        currentWidth = 0;
        lines[currentIndex] = "";
        if (this.isBreakingSpace(char)) {
          continue;
        }
        if (!this.canBreakInLastChar(char)) {
          lines = this.trimToBreakable(lines);
          currentWidth = this.sumTextWidthByCache(lines[currentIndex] || "", cache);
        }
        if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
          lines = this.trimByKinsokuShorui(lines);
          currentWidth += calcWidth(prevChar || "");
        }
      }
      currentWidth += charWidth;
      lines[currentIndex] = (lines[currentIndex] || "") + char;
    }
    return lines.join("\n");
  };
  _proto.isBreakingSpace = function isBreakingSpace(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.isNewline = function isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.trimToBreakable = function trimToBreakable(prev) {
    var next = [].concat(prev);
    var prevLine = next[next.length - 2];
    var index = this.findBreakableIndex(prevLine);
    if (index === -1 || !prevLine)
      return next;
    var trimmedChar = prevLine.slice(index, index + 1);
    var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
    var trimFrom = index + 1;
    var trimTo = index + (isTrimmedWithSpace ? 0 : 1);
    next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
    next[next.length - 2] = prevLine.slice(0, trimTo);
    return next;
  };
  _proto.canBreakInLastChar = function canBreakInLastChar(char) {
    if (char && LATIN_REGEX.test(char))
      return false;
    return true;
  };
  _proto.sumTextWidthByCache = function sumTextWidthByCache(text, cache) {
    return text.split("").reduce(function(sum, c) {
      if (!cache[c])
        throw Error("cannot count the word without cache");
      return sum + cache[c];
    }, 0);
  };
  _proto.findBreakableIndex = function findBreakableIndex(line3) {
    for (var i = line3.length - 1; i >= 0; i--) {
      if (!LATIN_REGEX.test(line3[i]))
        return i;
    }
    return -1;
  };
  _proto.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
    var width = cache[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  return TextService2;
}();
var _this = void 0;
var runtime = {};
var geometryUpdaterFactory = function() {
  var _ref;
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _ref[Shape.CIRCLE] = new CircleUpdater(), _ref[Shape.ELLIPSE] = new EllipseUpdater(), _ref[Shape.RECT] = rectUpdater, _ref[Shape.IMAGE] = rectUpdater, _ref[Shape.GROUP] = rectUpdater, _ref[Shape.LINE] = new LineUpdater(), _ref[Shape.TEXT] = new TextUpdater(runtime), _ref[Shape.POLYLINE] = polylineUpdater, _ref[Shape.POLYGON] = polylineUpdater, _ref[Shape.PATH] = new PathUpdater(), _ref[Shape.HTML] = null, _ref[Shape.MESH] = null, _ref;
}();
var CSSPropertySyntaxFactory = function() {
  var _ref2;
  var color2 = new CSSPropertyColor();
  var length14 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _ref2[PropertySyntax.PERCENTAGE] = null, _ref2[PropertySyntax.NUMBER] = new CSSPropertyNumber(), _ref2[PropertySyntax.ANGLE] = new CSSPropertyAngle(), _ref2[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _ref2[PropertySyntax.PAINT] = color2, _ref2[PropertySyntax.COLOR] = color2, _ref2[PropertySyntax.FILTER] = new CSSPropertyFilter(), _ref2[PropertySyntax.LENGTH] = length14, _ref2[PropertySyntax.LENGTH_PERCENTAGE] = length14, _ref2[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _ref2[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _ref2[PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(), _ref2[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _ref2[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _ref2[PropertySyntax.PATH] = new CSSPropertyPath(), _ref2[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _ref2[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _ref2[PropertySyntax.TEXT] = new CSSPropertyText(), _ref2[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _ref2[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _ref2[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _ref2[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _ref2[PropertySyntax.MARKER] = new CSSPropertyMarker(), _ref2;
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (typeof _this !== "undefined")
    return _this;
  throw new Error("Unable to locate global `this`");
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvas = new OffscreenCanvasCreator();
runtime.displayObjectPool = new DisplayObjectPool();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry();
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableCSSParsing = true;
var AbstractRendererPlugin = function() {
  function AbstractRendererPlugin2() {
    this.context = void 0;
    this.plugins = [];
  }
  var _proto = AbstractRendererPlugin2.prototype;
  _proto.addRenderingPlugin = function addRenderingPlugin(plugin) {
    this.plugins.push(plugin);
    this.context.renderingPlugins.push(plugin);
  };
  _proto.removeAllRenderingPlugins = function removeAllRenderingPlugins() {
    var _this2 = this;
    this.plugins.forEach(function(plugin) {
      var index = _this2.context.renderingPlugins.indexOf(plugin);
      if (index >= 0) {
        _this2.context.renderingPlugins.splice(index, 1);
      }
    });
  };
  return AbstractRendererPlugin2;
}();
var AbstractRenderer = function() {
  function AbstractRenderer2(config) {
    this.plugins = [];
    this.config = void 0;
    this.config = _extends({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false
    }, config);
  }
  var _proto2 = AbstractRenderer2.prototype;
  _proto2.registerPlugin = function registerPlugin(plugin) {
    var index = this.plugins.findIndex(function(p) {
      return p === plugin;
    });
    if (index === -1) {
      this.plugins.push(plugin);
    }
  };
  _proto2.unregisterPlugin = function unregisterPlugin(plugin) {
    var index = this.plugins.findIndex(function(p) {
      return p === plugin;
    });
    if (index > -1) {
      this.plugins.splice(index, 1);
    }
  };
  _proto2.getPlugins = function getPlugins() {
    return this.plugins;
  };
  _proto2.getPlugin = function getPlugin(name) {
    return this.plugins.find(function(plugin) {
      return plugin.name === name;
    });
  };
  _proto2.getConfig = function getConfig() {
    return this.config;
  };
  _proto2.setConfig = function setConfig(config) {
    Object.assign(this.config, config);
  };
  return AbstractRenderer2;
}();
var CullingPlugin = function() {
  function CullingPlugin2(strategies) {
    this.strategies = void 0;
    this.strategies = strategies;
  }
  var _proto = CullingPlugin2.prototype;
  _proto.apply = function apply(context) {
    var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
    var strategies = this.strategies;
    renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
      if (object) {
        var cullable = object.cullable;
        if (strategies.length === 0) {
          cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
        } else {
          cullable.visible = strategies.every(function(strategy) {
            return strategy.isVisible(camera, object);
          });
        }
        if (!object.isCulled() && object.isVisible()) {
          return object;
        } else {
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
        }
        return null;
      }
      return object;
    });
    renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
      object.cullable.visibilityPlaneMask = -1;
    });
  };
  return CullingPlugin2;
}();
CullingPlugin.tag = "Culling";
var DirtyCheckPlugin = function() {
  function DirtyCheckPlugin2() {
  }
  var _proto = DirtyCheckPlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService;
    renderingService.hooks.dirtycheck.tap(DirtyCheckPlugin2.tag, function(object) {
      if (object) {
        var renderable = object.renderable;
        var isDirty = renderable.dirty || renderingService.disableDirtyRectangleRendering();
        if (isDirty) {
          return object;
        } else {
          return null;
        }
      }
      return object;
    });
  };
  return DirtyCheckPlugin2;
}();
DirtyCheckPlugin.tag = "DirtyCheck";
var EventPlugin = function() {
  function EventPlugin2() {
    var _this2 = this;
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.context = void 0;
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi, _this$context$renderi2;
      var canvas = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 ? void 0 : (_this$context$renderi2 = _this$context$renderi.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator = _createForOfIteratorHelperLoose(normalizedEvents), _step; !(_step = _iterator()).done; ) {
        var normalizedEvent = _step.value;
        var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas);
        _this2.context.eventService.mapEvent(event);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  var _proto = EventPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    this.context = context;
    var renderingService = context.renderingService;
    var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
    this.context.eventService.setPickHandler(function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(position) {
        var _yield$_this2$context, picked;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.context.renderingService.hooks.pick.promise({
                  position,
                  picked: [],
                  topmost: true
                  // we only concern the topmost element
                });
              case 2:
                _yield$_this2$context = _context.sent;
                picked = _yield$_this2$context.picked;
                return _context.abrupt("return", picked[0] || null);
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }());
    renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
      var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
      _this2.context.eventService.mapEvent(wheelEvent);
    });
    renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      if (_this2.autoPreventDefault && events[0].isNormalized) {
        var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(events), _step2; !(_step2 = _iterator2()).done; ) {
        var event = _step2.value;
        var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas);
        _this2.context.eventService.mapEvent(federatedEvent);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var $element = _this2.context.contextService.getDomElement();
      var outside = "outside";
      try {
        outside = $element && nativeEvent.target && nativeEvent.target !== $element && $element.contains && !$element.contains(nativeEvent.target) ? "outside" : "";
      } catch (e2) {
      }
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator3 = _createForOfIteratorHelperLoose(normalizedEvents), _step3; !(_step3 = _iterator3()).done; ) {
        var normalizedEvent = _step3.value;
        var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas);
        event.type += outside;
        _this2.context.eventService.mapEvent(event);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
    renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
    renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
  };
  _proto.getViewportXY = function getViewportXY(nativeEvent) {
    var x;
    var y;
    var offsetX = nativeEvent.offsetX, offsetY = nativeEvent.offsetY, clientX = nativeEvent.clientX, clientY = nativeEvent.clientY;
    if (this.context.config.supportsCSSTransform && !is_nil_default(offsetX) && !is_nil_default(offsetY)) {
      x = offsetX;
      y = offsetY;
    } else {
      var point = this.context.eventService.client2Viewport(new Point(clientX, clientY));
      x = point.x;
      y = point.y;
    }
    return {
      x,
      y
    };
  };
  _proto.bootstrapEvent = function bootstrapEvent(event, nativeEvent, view) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    var _this$getViewportXY = this.getViewportXY(nativeEvent), x = _this$getViewportXY.x, y = _this$getViewportXY.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe.x, canvasY = _this$context$eventSe.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  };
  _proto.normalizeWheelEvent = function normalizeWheelEvent(nativeEvent) {
    var event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaMode = nativeEvent.deltaMode;
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    var _this$getViewportXY2 = this.getViewportXY(nativeEvent), x = _this$getViewportXY2.x, y = _this$getViewportXY2.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  };
  _proto.transferMouseData = function transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.metaKey = nativeEvent.metaKey;
    event.shiftKey = nativeEvent.shiftKey;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  };
  _proto.setCursor = function setCursor(cursor) {
    this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
  };
  _proto.normalizeToPointerEvent = function normalizeToPointerEvent(event, canvas) {
    var normalizedEvents = [];
    if (canvas.isTouchEvent(event)) {
      for (var i = 0; i < event.changedTouches.length; i++) {
        var touch = event.changedTouches[i];
        if (is_undefined_default(touch.button))
          touch.button = 0;
        if (is_undefined_default(touch.buttons))
          touch.buttons = 1;
        if (is_undefined_default(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (is_undefined_default(touch.width))
          touch.width = touch.radiusX || 1;
        if (is_undefined_default(touch.height))
          touch.height = touch.radiusY || 1;
        if (is_undefined_default(touch.tiltX))
          touch.tiltX = 0;
        if (is_undefined_default(touch.tiltY))
          touch.tiltY = 0;
        if (is_undefined_default(touch.pointerType))
          touch.pointerType = "touch";
        if (is_undefined_default(touch.pointerId))
          touch.pointerId = touch.identifier || 0;
        if (is_undefined_default(touch.pressure))
          touch.pressure = touch.force || 0.5;
        if (is_undefined_default(touch.twist))
          touch.twist = 0;
        if (is_undefined_default(touch.tangentialPressure))
          touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (canvas.isMouseEvent(event)) {
      var tempEvent = event;
      if (is_undefined_default(tempEvent.isPrimary))
        tempEvent.isPrimary = true;
      if (is_undefined_default(tempEvent.width))
        tempEvent.width = 1;
      if (is_undefined_default(tempEvent.height))
        tempEvent.height = 1;
      if (is_undefined_default(tempEvent.tiltX))
        tempEvent.tiltX = 0;
      if (is_undefined_default(tempEvent.tiltY))
        tempEvent.tiltY = 0;
      if (is_undefined_default(tempEvent.pointerType))
        tempEvent.pointerType = "mouse";
      if (is_undefined_default(tempEvent.pointerId))
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (is_undefined_default(tempEvent.pressure))
        tempEvent.pressure = 0.5;
      if (is_undefined_default(tempEvent.twist))
        tempEvent.twist = 0;
      if (is_undefined_default(tempEvent.tangentialPressure))
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  return EventPlugin2;
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = function() {
  function FrustumCullingStrategy2() {
  }
  var _proto = FrustumCullingStrategy2.prototype;
  _proto.isVisible = function isVisible(camera, object) {
    var _object$parentNode, _object$parentNode$cu;
    var cullable = object.cullable;
    if (!cullable.enable) {
      return true;
    }
    var renderBounds = object.getRenderBounds();
    if (AABB.isEmpty(renderBounds)) {
      return false;
    }
    var frustum2 = camera.getFrustum();
    var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 ? void 0 : (_object$parentNode$cu = _object$parentNode.cullable) === null || _object$parentNode$cu === void 0 ? void 0 : _object$parentNode$cu.visibilityPlaneMask;
    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
    cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
    return cullable.visible;
  };
  _proto.computeVisibilityWithPlaneMask = function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
      return parentPlaneMask;
    }
    var mask = Mask.INSIDE;
    var isShape2D = shape2D.indexOf(object.nodeName) > -1;
    for (var k = 0, len5 = planes.length; k < len5; ++k) {
      var flag = 1 << k;
      if ((parentPlaneMask & flag) === 0) {
        continue;
      }
      if (isShape2D && (k === 4 || k === 5)) {
        continue;
      }
      var _planes$k = planes[k], normal = _planes$k.normal, distance6 = _planes$k.distance;
      if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance6 < 0) {
        return Mask.OUTSIDE;
      }
      if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance6 < 0) {
        mask |= flag;
      }
    }
    return mask;
  };
  return FrustumCullingStrategy2;
}();
var PrepareRendererPlugin = function() {
  function PrepareRendererPlugin2() {
    this.rBush = void 0;
    this.toSync = /* @__PURE__ */ new Set();
  }
  var _proto = PrepareRendererPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    this.rBush = rBushRoot;
    var handleAttributeChanged = function handleAttributeChanged2(e2) {
      var object = e2.target;
      object.renderable.dirty = true;
      renderingService.dirtify();
    };
    var handleBoundsChanged = function handleBoundsChanged2(e2) {
      var affectChildren = e2.detail.affectChildren;
      var object = e2.target;
      if (affectChildren) {
        object.forEach(function(node) {
          _this2.toSync.add(node);
        });
      }
      var p = object;
      while (p) {
        if (p.renderable) {
          _this2.toSync.add(p);
        }
        p = p.parentElement;
      }
      renderingService.dirtify();
    };
    var handleMounted = function handleMounted2(e2) {
      var object = e2.target;
      if (runtime.enableCSSParsing) {
        runtime.styleValueRegistry.recalc(object);
      }
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    var handleUnmounted = function handleUnmounted2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.rBush.remove(rBushNode.aabb);
      }
      _this2.toSync.delete(object);
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    renderingService.hooks.init.tapPromise(PrepareRendererPlugin2.tag, _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
              canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
      canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
      canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      _this2.toSync.clear();
    });
    renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
      _this2.syncRTree();
    });
  };
  _proto.syncRTree = function syncRTree() {
    var _this2 = this;
    var bulk = [];
    Array.from(this.toSync).filter(function(object) {
      return object.isConnected;
    }).forEach(function(node) {
      var rBushNode = node.rBushNode;
      if (rBushNode && rBushNode.aabb) {
        _this2.rBush.remove(rBushNode.aabb);
      }
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var _renderBounds$getMin = renderBounds.getMin(), minX = _renderBounds$getMin[0], minY = _renderBounds$getMin[1];
        var _renderBounds$getMax = renderBounds.getMax(), maxX = _renderBounds$getMax[0], maxY = _renderBounds$getMax[1];
        if (!rBushNode.aabb) {
          rBushNode.aabb = {};
        }
        rBushNode.aabb.id = node.entity;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY;
      }
      if (rBushNode.aabb) {
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          bulk.push(rBushNode.aabb);
        }
      }
    });
    this.rBush.load(bulk);
    bulk.length = 0;
    this.toSync.clear();
  };
  return PrepareRendererPlugin2;
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent;
(function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
})(CanvasEvent || (CanvasEvent = {}));
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = function(_EventTarget) {
  _inheritsLoose(Canvas3, _EventTarget);
  function Canvas3(config) {
    var _this2;
    _this2 = _EventTarget.call(this) || this;
    _this2.document = void 0;
    _this2.customElements = void 0;
    _this2.requestAnimationFrame = void 0;
    _this2.cancelAnimationFrame = void 0;
    _this2.devicePixelRatio = void 0;
    _this2.supportsPointerEvents = void 0;
    _this2.supportsTouchEvents = void 0;
    _this2.isTouchEvent = void 0;
    _this2.isMouseEvent = void 0;
    _this2.Element = DisplayObject;
    _this2.frameId = void 0;
    _this2.inited = false;
    _this2.readyPromise = void 0;
    _this2.resolveReadyPromise = void 0;
    _this2.context = {};
    _this2.document = new Document();
    _this2.document.defaultView = _assertThisInitialized(_this2);
    _this2.customElements = new CustomElementRegistry();
    var container = config.container, canvas = config.canvas, offscreenCanvas = config.offscreenCanvas, width = config.width, height = config.height, devicePixelRatio = config.devicePixelRatio, renderer = config.renderer, background = config.background, cursor = config.cursor, document2 = config.document, requestAnimationFrame3 = config.requestAnimationFrame, cancelAnimationFrame3 = config.cancelAnimationFrame, createImage = config.createImage, supportsPointerEvents = config.supportsPointerEvents, supportsTouchEvents = config.supportsTouchEvents, supportsCSSTransform = config.supportsCSSTransform, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent;
    cleanExistedCanvas(container, _assertThisInitialized(_this2));
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio;
    if (canvas) {
      dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame3 !== null && requestAnimationFrame3 !== void 0 ? requestAnimationFrame3 : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame3 !== null && cancelAnimationFrame3 !== void 0 ? cancelAnimationFrame3 : caf.bind(runtime.globalThis);
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    _this2.initRenderingContext({
      container,
      canvas,
      width: canvasWidth,
      height: canvasHeight,
      renderer,
      offscreenCanvas,
      devicePixelRatio: dpr,
      cursor: cursor || "default",
      background: background || "transparent",
      createImage,
      document: document2,
      supportsCSSTransform
    });
    _this2.initDefaultCamera(canvasWidth, canvasHeight);
    _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this2.initRenderer(renderer);
            case 2:
              _this2.dispatchEvent(new CustomEvent(CanvasEvent.READY));
              if (_this2.readyPromise) {
                _this2.resolveReadyPromise();
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
    return _this2;
  }
  var _proto = Canvas3.prototype;
  _proto.initRenderingContext = function initRenderingContext(mergedConfig) {
    this.context.config = mergedConfig;
    this.context.renderingContext = {
      /**
       * the root node in scene graph
       */
      root: this.document.documentElement,
      renderListCurrentFrame: [],
      unculledEntities: [],
      renderReasons: /* @__PURE__ */ new Set(),
      force: false,
      dirty: false
    };
  };
  _proto.initDefaultCamera = function initDefaultCamera(width, height) {
    var _this2 = this;
    var camera = new runtime.CameraContribution();
    camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
    camera.canvas = this;
    camera.eventEmitter.on(CameraEvent.UPDATED, function() {
      _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    });
    this.context.camera = camera;
  };
  _proto.getConfig = function getConfig() {
    return this.context.config;
  };
  _proto.getRoot = function getRoot() {
    return this.document.documentElement;
  };
  _proto.getCamera = function getCamera() {
    return this.context.camera;
  };
  _proto.getContextService = function getContextService() {
    return this.context.contextService;
  };
  _proto.getEventService = function getEventService() {
    return this.context.eventService;
  };
  _proto.getRenderingService = function getRenderingService() {
    return this.context.renderingService;
  };
  _proto.getRenderingContext = function getRenderingContext() {
    return this.context.renderingContext;
  };
  _proto.getStats = function getStats() {
    return this.getRenderingService().getStats();
  };
  _proto.destroy = function destroy(cleanUp, skipTriggerEvent) {
    if (cleanUp === void 0) {
      cleanUp = true;
    }
    if (skipTriggerEvent === void 0) {
      skipTriggerEvent = false;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
    }
    if (this.frameId) {
      var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
      cancelRAF(this.frameId);
    }
    var root2 = this.getRoot();
    this.unmountChildren(root2);
    if (cleanUp) {
      this.document.destroy();
      this.getEventService().destroy();
    }
    this.getRenderingService().destroy();
    this.getContextService().destroy();
    if (cleanUp && this.context.rBushRoot) {
      this.context.rBushRoot.clear();
      this.context.rBushRoot = null;
      this.context.renderingContext.root = null;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
    }
  };
  _proto.changeSize = function changeSize(width, height) {
    this.resize(width, height);
  };
  _proto.resize = function resize(width, height) {
    var canvasConfig = this.context.config;
    canvasConfig.width = width;
    canvasConfig.height = height;
    this.getContextService().resize(width, height);
    var camera = this.context.camera;
    var projectionMode = camera.getProjectionMode();
    camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
    if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
    } else {
      camera.setAspect(width / height);
    }
    this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
      width,
      height
    }));
  };
  _proto.appendChild = function appendChild(child, index) {
    return this.document.documentElement.appendChild(child, index);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    return this.document.documentElement.insertBefore(newChild, refChild);
  };
  _proto.removeChild = function removeChild(child) {
    return this.document.documentElement.removeChild(child);
  };
  _proto.removeChildren = function removeChildren() {
    this.document.documentElement.removeChildren();
  };
  _proto.destroyChildren = function destroyChildren() {
    this.document.documentElement.destroyChildren();
  };
  _proto.render = function render3() {
    var _this3 = this;
    this.dispatchEvent(beforeRenderEvent);
    var renderingService = this.getRenderingService();
    renderingService.render(this.getConfig(), function() {
      _this3.dispatchEvent(rerenderEvent);
    });
    this.dispatchEvent(afterRenderEvent);
  };
  _proto.run = function run() {
    var _this4 = this;
    var tick = function tick2() {
      _this4.render();
      _this4.frameId = requestAnimationFrame(tick2);
    };
    tick();
  };
  _proto.initRenderer = function() {
    var _initRenderer = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(renderer) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (renderer) {
                _context2.next = 2;
                break;
              }
              throw new Error("Renderer is required.");
            case 2:
              this.inited = false;
              this.readyPromise = void 0;
              this.context.rBushRoot = new import_rbush.default();
              this.context.renderingPlugins = [];
              this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), new DirtyCheckPlugin(), new CullingPlugin([new FrustumCullingStrategy()]));
              this.loadRendererContainerModule(renderer);
              this.context.contextService = new this.context.ContextService(_extends({}, runtime, this.context));
              this.context.renderingService = new RenderingService(runtime, this.context);
              this.context.eventService = new EventService(runtime, this.context);
              this.context.eventService.init();
              _context2.next = 14;
              return this.context.contextService.init();
            case 14:
              _context2.next = 16;
              return this.context.renderingService.init();
            case 16:
              this.inited = true;
              this.getRoot().forEach(function(node) {
                var renderable = node.renderable;
                if (renderable) {
                  renderable.renderBoundsDirty = true;
                  renderable.boundsDirty = true;
                  renderable.dirty = true;
                }
              });
              this.mountChildren(this.getRoot());
              if (renderer.getConfig().enableAutoRendering) {
                this.run();
              }
            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function initRenderer(_x) {
      return _initRenderer.apply(this, arguments);
    }
    return initRenderer;
  }();
  _proto.loadRendererContainerModule = function loadRendererContainerModule(renderer) {
    var _this5 = this;
    var plugins = renderer.getPlugins();
    plugins.forEach(function(plugin) {
      plugin.context = _this5.context;
      plugin.init(runtime);
    });
  };
  _proto.setRenderer = function() {
    var _setRenderer = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(renderer) {
      var canvasConfig, oldRenderer;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              canvasConfig = this.getConfig();
              if (!(canvasConfig.renderer === renderer)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              oldRenderer = canvasConfig.renderer;
              canvasConfig.renderer = renderer;
              this.destroy(false, true);
              [].concat(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()).reverse().forEach(function(plugin) {
                plugin.destroy(runtime);
              });
              _context3.next = 9;
              return this.initRenderer(renderer);
            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function setRenderer(_x2) {
      return _setRenderer.apply(this, arguments);
    }
    return setRenderer;
  }();
  _proto.setCursor = function setCursor(cursor) {
    var canvasConfig = this.getConfig();
    canvasConfig.cursor = cursor;
    this.getContextService().applyCursorStyle(cursor);
  };
  _proto.unmountChildren = function unmountChildren(parent) {
    var _this6 = this;
    parent.childNodes.forEach(function(child) {
      _this6.unmountChildren(child);
    });
    if (this.inited) {
      if (parent.isMutationObserved) {
        parent.dispatchEvent(unmountedEvent);
      } else {
        unmountedEvent.target = parent;
        this.dispatchEvent(unmountedEvent, true);
      }
      if (parent !== this.document.documentElement) {
        parent.ownerDocument = null;
      }
      parent.isConnected = false;
    }
    if (parent.isCustomElement) {
      if (parent.disconnectedCallback) {
        parent.disconnectedCallback();
      }
    }
  };
  _proto.mountChildren = function mountChildren(parent) {
    var _this7 = this;
    if (this.inited) {
      if (!parent.isConnected) {
        parent.ownerDocument = this.document;
        parent.isConnected = true;
        if (parent.isMutationObserved) {
          parent.dispatchEvent(mountedEvent);
        } else {
          mountedEvent.target = parent;
          this.dispatchEvent(mountedEvent, true);
        }
      }
    } else {
      console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", parent.nodeName);
    }
    parent.childNodes.forEach(function(child) {
      _this7.mountChildren(child);
    });
    if (parent.isCustomElement) {
      if (parent.connectedCallback) {
        parent.connectedCallback();
      }
    }
  };
  _proto.client2Viewport = function client2Viewport(client) {
    return this.getEventService().client2Viewport(client);
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    return this.getEventService().viewport2Client(canvas);
  };
  _proto.viewport2Canvas = function viewport2Canvas(viewport) {
    return this.getEventService().viewport2Canvas(viewport);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvas) {
    return this.getEventService().canvas2Viewport(canvas);
  };
  _proto.getPointByClient = function getPointByClient(clientX, clientY) {
    return this.client2Viewport({
      x: clientX,
      y: clientY
    });
  };
  _proto.getClientByPoint = function getClientByPoint(x, y) {
    return this.viewport2Client({
      x,
      y
    });
  };
  _createClass(Canvas3, [{
    key: "ready",
    get: function get() {
      var _this8 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this8.resolveReadyPromise = function() {
            resolve(_this8);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
  }]);
  return Canvas3;
}(EventTarget);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/util/util.js
var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/arc.js
function computeArcSweep(startAngle, endAngle, anticlockwise) {
  if (!anticlockwise) {
    if (endAngle >= startAngle) {
      return endAngle - startAngle <= Math.PI ? 0 : 1;
    }
    return endAngle - startAngle <= -Math.PI ? 0 : 1;
  }
  if (endAngle >= startAngle) {
    return endAngle - startAngle <= Math.PI ? 1 : 0;
  }
  return endAngle - startAngle <= -Math.PI ? 1 : 0;
}
var Arc = (
  /** @class */
  function(_super) {
    __extends(Arc2, _super);
    function Arc2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Arc2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["cx", "cy", "startAngle", "endAngle", "r", "anticlockwise"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Arc2.prototype.updatePath = function() {
      var _a = this.parsedStyle, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, startAngle = _a.startAngle, endAngle = _a.endAngle, r = _a.r, anticlockwise = _a.anticlockwise;
      if (is_nil_default(startAngle) || is_nil_default(endAngle) || startAngle === endAngle || is_nil_default(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad2(startAngle), deg2rad2(endAngle), r, anticlockwise);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    Arc2.prototype.createPath = function(x, y, startAngle, endAngle, r, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var angle3 = Math.abs(endAngle - startAngle);
      if (angle3 >= Math.PI * 2 || isNumberEqual(angle3, Math.PI * 2)) {
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        return [["M", start.x, start.y], ["A", r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ["A", r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ["Z"]];
      }
      var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
      return [["M", start.x, start.y], ["A", r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
    };
    return Arc2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/marker.js
var SYMBOLS = {
  circle: function circle(x, y, r) {
    return [["M", x - r, y], ["A", r, r, 0, 1, 0, x + r, y], ["A", r, r, 0, 1, 0, x - r, y]];
  },
  square: function square(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  arrow: function arrow(x, y, r) {
    return [["M", x - r, y + 2 * r / Math.sqrt(3)], ["L", x + r, y + 2 * r / Math.sqrt(3)], ["L", x, y - 2 * r / Math.sqrt(3)], ["Z"]];
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Marker2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["x", "y", "symbol", "radius"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Marker2.prototype.updatePath = function() {
      var _a = this.parsedStyle, _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c;
      var _d = this.attributes, radius = _d.radius, symbol = _d.symbol;
      if (!symbol)
        return;
      var method = SYMBOLS[symbol];
      if (!method)
        return;
      var path = method(x, y, radius);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    return Marker2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/sector.js
var PI = Math.PI;
var PI2 = PI * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathSqrt = Math.sqrt;
var mathMax = Math.max;
var mathMin = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d22 = dx * dx + dy * dy;
  var r = radius - cr;
  var s2 = x11 * y10 - x10 * y11;
  var d4 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d22 - s2 * s2));
  var cx0 = (s2 * dy - dx * d4) / d22;
  var cy0 = (-s2 * dx - dy * d4) / d22;
  var cx1 = (s2 * dy + dx * d4) / d22;
  var cy1 = (-s2 * dx + dy * d4) / d22;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function computeArcSweep2(startAngle, endAngle, clockwise) {
  if (clockwise === void 0) {
    clockwise = true;
  }
  if (!clockwise) {
    var replaceAngle = endAngle;
    endAngle = startAngle;
    startAngle = replaceAngle;
  }
  endAngle = endAngle - startAngle < 0 ? endAngle + PI2 : endAngle;
  return Math.abs(endAngle - startAngle) % PI2 <= PI ? 0 : 1;
}
var Sector = (
  /** @class */
  function(_super) {
    __extends(Sector2, _super);
    function Sector2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Sector2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["startAngle", "endAngle", "r", "r0", "radius", "cx", "cy"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Sector2.prototype.updatePath = function() {
      var _a = this.parsedStyle, cx = _a.cx, cy = _a.cy, startAngle = _a.startAngle, endAngle = _a.endAngle, r = _a.r, r0 = _a.r0, radius = _a.radius, _b = _a.anticlockwise, anticlockwise = _b === void 0 ? false : _b;
      if (is_nil_default(startAngle) || is_nil_default(endAngle) || startAngle === endAngle || is_nil_default(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad2(startAngle), deg2rad2(endAngle), r, r0 ? r0 : 0, radius ? radius : [0, 0, 0, 0], anticlockwise);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    Sector2.prototype.createPath = function(x, y, startAngle, endAngle, r, r0, borderRadius, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var innerStart = polarToCartesian(x, y, r0, startAngle);
      var innerEnd = polarToCartesian(x, y, r0, endAngle);
      var clockwise = !anticlockwise;
      var angle3 = clockwise ? endAngle - startAngle : startAngle - endAngle;
      if (Math.abs(angle3) >= PI2 || isNumberEqual(Math.abs(angle3), PI2)) {
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        var innerMiddlePoint = polarToCartesian(x, y, r0, startAngle + Math.PI);
        var circlePathCommands = [["M", start.x, start.y], ["A", r, r, 0, 1, clockwise ? 1 : 0, middlePoint.x, middlePoint.y], ["A", r, r, 0, 1, clockwise ? 1 : 0, end.x, end.y]];
        if (r0 > 0) {
          circlePathCommands.push(["M", innerStart.x, innerStart.y]);
          circlePathCommands.push(["A", r0, r0, 0, 1, clockwise ? 0 : 1, innerMiddlePoint.x, innerMiddlePoint.y]);
          circlePathCommands.push(["A", r0, r0, 0, 1, clockwise ? 0 : 1, innerEnd.x, innerEnd.y]);
        }
        circlePathCommands.push(["M", start.x, start.y]);
        circlePathCommands.push(["Z"]);
        return circlePathCommands;
      }
      var xrs = r * mathCos(startAngle);
      var yrs = r * mathSin(startAngle);
      var xire = r0 * mathCos(endAngle);
      var yire = r0 * mathSin(endAngle);
      var xre = r * mathCos(endAngle);
      var yre = r * mathSin(endAngle);
      var xirs = r0 * mathCos(startAngle);
      var yirs = r0 * mathSin(startAngle);
      var outStartRadius = borderRadius[0], outEndRadius = borderRadius[1], innerEndRadius = borderRadius[2], innerStartRadius = borderRadius[3];
      var halfRadius = (r - r0) / 2;
      var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
      var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
      var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
      var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
      var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
      var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
      var limitedOutBorderRadiusMax = outBorderRadiusMax;
      var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
      if (outBorderRadiusMax > e || innerBorderRadiusMax > e) {
        if (angle3 < PI) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r - b) / (a + 1));
            limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b) / (a - 1));
          }
        }
      }
      var arcSweep = computeArcSweep2(startAngle, endAngle, clockwise);
      var sectorPathCommands = [];
      if (limitedOutBorderRadiusMax > e) {
        var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
        var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, r, crEnd, clockwise);
        sectorPathCommands.push(["M", x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
          var outStartBorderRadiusStartAngle = mathATan2(ct0.cy + ct0.y0, ct0.cx + ct0.x0);
          var outStartBorderRadiusEndAngle = mathATan2(ct1.cy + ct1.y0, ct1.cx + ct1.x0);
          sectorPathCommands.push(["A", limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep2(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, !clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          if (crStart > 0) {
            var outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            var outStartBorderRadiusEndPoint = polarToCartesian(x, y, r, outStartBorderRadiusEndAngle);
            sectorPathCommands.push(["A", crStart, crStart, 0, computeArcSweep2(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
          }
          var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var outRadiusEndPoint = polarToCartesian(x, y, r, outRadiusEndAngle);
          sectorPathCommands.push(["A", r, r, 1, computeArcSweep2(outRadiusStartAngle, outRadiusEndAngle, clockwise), clockwise ? 1 : 0, outRadiusEndPoint.x, outRadiusEndPoint.y]);
          if (crEnd > 0) {
            var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(["A", crEnd, crEnd, 0, computeArcSweep2(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["M", start.x, start.y]);
        sectorPathCommands.push(["A", r, r, 0, arcSweep, clockwise ? 1 : 0, end.x, end.y]);
      }
      if (r0 < e) {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
      } else if (limitedInnerBorderRadiusMax > e) {
        var crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
        var crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
        var ct0 = computeCornerTangents(0, 0, xire, yire, r0, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xirs, yirs, 0, 0, r0, -crStart, clockwise);
        sectorPathCommands.push(["L", x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && crStart === crEnd) {
          var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var innerStartBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(["A", limitedInnerBorderRadiusMax, limitedInnerBorderRadiusMax, 0, computeArcSweep2(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          if (crEnd > 0) {
            var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var innerStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            sectorPathCommands.push(["A", crEnd, crEnd, 0, computeArcSweep2(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct0.cx + ct0.x1, y + ct0.cy + ct0.y1]);
          }
          var innerRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var innerRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var innerRadiusEndPoint = polarToCartesian(x, y, r0, innerRadiusEndAngle);
          sectorPathCommands.push(["A", r0, r0, 0, computeArcSweep2(innerRadiusEndAngle, innerRadiusStartAngle, clockwise), clockwise ? 0 : 1, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
          if (crStart > 0) {
            var innerEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var innerEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(["A", crStart, crStart, 0, computeArcSweep2(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
        sectorPathCommands.push(["A", r0, r0, 0, arcSweep, clockwise ? 0 : 1, innerStart.x, innerStart.y]);
      }
      sectorPathCommands.push(["Z"]);
      return sectorPathCommands;
    };
    return Sector2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/util/smooth.js
function getPoint2(v) {
  return [v.x, v.y];
}
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min4;
  var max4;
  var point;
  var len5;
  var l;
  var i;
  if (hasConstraint) {
    min4 = [Infinity, Infinity];
    max4 = [-Infinity, -Infinity];
    for (i = 0, l = points.length; i < l; i++) {
      point = getPoint2(points[i]);
      vec2_exports.min(min4, min4, point);
      vec2_exports.max(max4, max4, point);
    }
    vec2_exports.min(min4, min4, constraint[0]);
    vec2_exports.max(max4, max4, constraint[1]);
  }
  for (i = 0, len5 = points.length; i < len5; i++) {
    point = getPoint2(points[i]);
    if (isLoop) {
      prevPoint = getPoint2(points[i ? i - 1 : len5 - 1]);
      nextPoint = getPoint2(points[(i + 1) % len5]);
    } else {
      if (i === 0 || i === len5 - 1) {
        cps.push([point[0], point[1]]);
        continue;
      } else {
        prevPoint = getPoint2(points[i - 1]);
        nextPoint = getPoint2(points[i + 1]);
      }
    }
    var v = vec2_exports.sub([], nextPoint, prevPoint);
    vec2_exports.scale(v, v, smooth);
    var d0 = vec2_exports.distance(point, prevPoint);
    var d1 = vec2_exports.distance(point, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    var v1 = vec2_exports.scale([], v, -d0);
    var v2 = vec2_exports.scale([], v, d1);
    var cp0 = vec2_exports.add([], point, v1);
    var cp1 = vec2_exports.add([], point, v2);
    if (hasConstraint) {
      vec2_exports.max(cp0, cp0, min4);
      vec2_exports.min(cp0, cp0, max4);
      vec2_exports.max(cp1, cp1, min4);
      vec2_exports.min(cp1, cp1, max4);
    }
    cps.push([cp0[0], cp0[1]]);
    cps.push([cp1[0], cp1[1]]);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2bezier(pointList, z, constraint) {
  var isLoop = !!z;
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len5 - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
  }
  return d1;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/smoothPolyline.js
var SmoothPolyline = (
  /** @class */
  function(_super) {
    __extends(SmoothPolyline2, _super);
    function SmoothPolyline2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    SmoothPolyline2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["smooth", "points"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    SmoothPolyline2.prototype.updatePath = function() {
      var _a = this.parsedStyle, smooth = _a.smooth, points = _a.points;
      var pos2 = points.points;
      var d4 = [["M", pos2[0][0], pos2[0][1]]];
      if (smooth) {
        var constaint = [[0, 0], [1, 1]];
        var sps = catmullRom2bezier(pos2.map(function(d5) {
          return {
            x: d5[0],
            y: d5[1]
          };
        }), false, constaint);
        for (var i = 0, n = sps.length; i < n; i++) {
          var sp = sps[i];
          d4.push(["C", sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);
        }
      } else {
        var i = void 0;
        var l = void 0;
        for (i = 1, l = pos2.length - 1; i < l; i++) {
          d4.push(["L", pos2[i][0], pos2[i][1]]);
        }
        d4.push(["L", pos2[l][0], pos2[l][1]]);
      }
      _super.prototype.setAttribute.call(this, "path", d4);
    };
    SmoothPolyline2.tag = "smooth-polyline";
    return SmoothPolyline2;
  }(Path)
);

// node_modules/.pnpm/@antv+g-gesture@0.0.68/node_modules/@antv/g-gesture/dist/index.esm.js
var import_eventemitter32 = __toESM(require_eventemitter3());
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var clock = typeof performance === "object" && performance.now ? performance : Date;
var PRESS_DELAY = 250;
var calcDirection = function calcDirection2(start, end) {
  var xDistance = end.x - start.x;
  var yDistance = end.y - start.y;
  if (Math.abs(xDistance) > Math.abs(yDistance)) {
    return xDistance > 0 ? "right" : "left";
  }
  return yDistance > 0 ? "down" : "up";
};
var calcDistance = function calcDistance2(point1, point2) {
  var xDistance = Math.abs(point2.x - point1.x);
  var yDistance = Math.abs(point2.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter = function getCenter2(point1, point2) {
  var x = point1.x + (point2.x - point1.x) / 2;
  var y = point1.y + (point2.y - point1.y) / 2;
  return {
    x,
    y
  };
};
var Gesture = function(_EE) {
  _inheritsLoose2(Gesture3, _EE);
  function Gesture3(el) {
    var _this2;
    _this2 = _EE.call(this) || this;
    _this2.el = void 0;
    _this2.evCache = [];
    _this2.startTime = void 0;
    _this2.pressTimeout = void 0;
    _this2.startPoints = [];
    _this2.processEvent = {};
    _this2.startDistance = void 0;
    _this2.center = void 0;
    _this2.eventType = void 0;
    _this2.direction = void 0;
    _this2.lastMoveTime = void 0;
    _this2.prevMovePoint = void 0;
    _this2.prevMoveTime = void 0;
    _this2.lastMovePoint = void 0;
    _this2.throttleTimer = 0;
    _this2.emitThrottles = [];
    _this2._start = function(ev) {
      _this2.reset();
      _this2.startTime = clock.now();
      var _assertThisInitialize = _assertThisInitialized2(_this2), evCache = _assertThisInitialize.evCache, startPoints = _assertThisInitialize.startPoints;
      if (ev) {
        var pointerId = ev.pointerId, x = ev.x, y = ev.y;
        evCache.push({
          pointerId,
          x,
          y,
          ev
        });
      }
      startPoints.length = evCache.length;
      for (var i = 0; i < evCache.length; i++) {
        var _evCache$i = evCache[i], _x = _evCache$i.x, _y = _evCache$i.y;
        var point = {
          x: _x,
          y: _y
        };
        startPoints[i] = point;
      }
      if (startPoints.length === 1) {
        var event = evCache[0].ev;
        _this2.pressTimeout = setTimeout(function() {
          var eventType = "press";
          var direction = "none";
          event.direction = direction;
          event.deltaX = 0;
          event.deltaY = 0;
          event.points = startPoints;
          _this2.emitStart(eventType, event);
          _this2._emit(eventType, event);
          _this2.eventType = eventType;
          _this2.direction = direction;
        }, PRESS_DELAY);
        return;
      }
      _this2.startDistance = calcDistance(startPoints[0], startPoints[1]);
      _this2.center = getCenter(startPoints[0], startPoints[1]);
    };
    _this2._move = function(ev) {
      _this2.clearPressTimeout();
      var _assertThisInitialize2 = _assertThisInitialized2(_this2), startPoints = _assertThisInitialize2.startPoints, evCache = _assertThisInitialize2.evCache;
      if (!startPoints.length)
        return;
      var x = ev.x, y = ev.y, pointerId = ev.pointerId;
      var isTriggerStart = false;
      for (var i = 0, len5 = evCache.length; i < len5; i++) {
        if (pointerId === evCache[i].pointerId) {
          evCache[i] = {
            pointerId,
            x,
            y,
            ev
          };
          isTriggerStart = true;
          break;
        }
      }
      if (!isTriggerStart) {
        var _point = {
          x,
          y
        };
        startPoints.push(_point);
        evCache.push({
          pointerId,
          x,
          y,
          ev
        });
        _this2.startDistance = calcDistance(startPoints[0], startPoints[1]);
        _this2.center = getCenter(startPoints[0], startPoints[1]);
      }
      var point = {
        x,
        y
      };
      var points = evCache.map(function(ev2) {
        return {
          x: ev2.x,
          y: ev2.y
        };
      });
      var now = clock.now();
      _this2.prevMoveTime = _this2.lastMoveTime;
      _this2.prevMovePoint = _this2.lastMovePoint;
      _this2.lastMoveTime = now;
      _this2.lastMovePoint = point;
      if (startPoints.length === 1) {
        var startPoint = startPoints[0];
        var deltaX = x - startPoint.x;
        var deltaY = y - startPoint.y;
        var direction = _this2.direction || calcDirection(startPoint, point);
        _this2.direction = direction;
        var eventType = _this2.getEventType(point);
        ev.direction = direction;
        ev.deltaX = deltaX;
        ev.deltaY = deltaY;
        ev.points = points;
        _this2.emitStart(eventType, ev);
        _this2._emit(eventType, ev);
        return;
      }
      var _assertThisInitialize3 = _assertThisInitialized2(_this2), startDistance = _assertThisInitialize3.startDistance;
      var currentDistance = calcDistance(points[0], points[1]);
      ev.zoom = currentDistance / startDistance;
      ev.center = _this2.center;
      ev.points = points;
      _this2.emitStart("pinch", ev);
      _this2._emit("pinch", ev);
    };
    _this2._end = function(ev) {
      var _assertThisInitialize4 = _assertThisInitialized2(_this2), evCache = _assertThisInitialize4.evCache, startPoints = _assertThisInitialize4.startPoints;
      var points = evCache.map(function(ev2) {
        return {
          x: ev2.x,
          y: ev2.y
        };
      });
      ev.points = points;
      _this2.emitEnd(ev);
      if (evCache.length === 1) {
        var now = clock.now();
        var lastMoveTime = _this2.lastMoveTime;
        if (now - lastMoveTime < 100) {
          var prevMoveTime = _this2.prevMoveTime || _this2.startTime;
          var intervalTime = lastMoveTime - prevMoveTime;
          if (intervalTime > 0) {
            var prevMovePoint = _this2.prevMovePoint || startPoints[0];
            var lastMovePoint = _this2.lastMovePoint || startPoints[0];
            var velocity = calcDistance(prevMovePoint, lastMovePoint) / intervalTime;
            if (velocity > 0.3) {
              ev.velocity = velocity;
              ev.direction = calcDirection(prevMovePoint, lastMovePoint);
              _this2._emit("swipe", ev);
            }
          }
        }
      }
      for (var i = 0, len5 = evCache.length; i < len5; i++) {
        if (evCache[i].pointerId === ev.pointerId) {
          evCache.splice(i, 1);
          startPoints.splice(i, 1);
          break;
        }
      }
      _this2.reset();
      if (evCache.length > 0) {
        _this2._start();
      }
    };
    _this2.el = el;
    _this2._initEvent();
    return _this2;
  }
  var _proto = Gesture3.prototype;
  _proto._initEvent = function _initEvent() {
    var el = this.el;
    el.addEventListener("pointerdown", this._start);
    el.addEventListener("pointermove", this._move);
    el.addEventListener("pointerup", this._end);
    el.addEventListener("pointerupoutside", this._end);
  };
  _proto.getEventType = function getEventType(point) {
    var eventType = this.eventType, startTime = this.startTime, startPoints = this.startPoints;
    if (eventType) {
      return eventType;
    }
    var type;
    var panEventListeners = this._events.pan;
    if (!panEventListeners) {
      type = "press";
    } else {
      var now = clock.now();
      if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], point) < 10) {
        type = "press";
      } else {
        type = "pan";
      }
    }
    this.eventType = type;
    return type;
  };
  _proto.enable = function enable(eventType) {
    this.processEvent[eventType] = true;
  };
  _proto.isProcess = function isProcess(eventType) {
    return this.processEvent[eventType];
  };
  _proto.emitStart = function emitStart(type, ev) {
    if (this.isProcess(type)) {
      return;
    }
    this.enable(type);
    this._emit(type + "start", ev);
  };
  _proto._emit = function _emit(type, ev) {
    var _el$ownerDocument, _el$document, _this2 = this;
    this.pushEvent(type, ev);
    var el = this.el, throttleTimer = this.throttleTimer, emitThrottles = this.emitThrottles;
    if (throttleTimer) {
      return;
    }
    var global2 = ((_el$ownerDocument = el.ownerDocument) === null || _el$ownerDocument === void 0 ? void 0 : _el$ownerDocument.defaultView) || ((_el$document = el.document) === null || _el$document === void 0 ? void 0 : _el$document.defaultView);
    this.throttleTimer = global2.requestAnimationFrame(function() {
      for (var i = 0, len5 = emitThrottles.length; i < len5; i++) {
        var _emitThrottles$i = emitThrottles[i], _type = _emitThrottles$i.type, _ev = _emitThrottles$i.ev;
        _this2.emit(_type, _ev);
      }
      _this2.throttleTimer = 0;
      _this2.emitThrottles.length = 0;
    });
  };
  _proto.emitEnd = function emitEnd(ev) {
    var _this3 = this;
    var processEvent = this.processEvent;
    Object.keys(processEvent).forEach(function(type) {
      _this3._emit(type + "end", ev);
      delete processEvent[type];
    });
  };
  _proto.pushEvent = function pushEvent(type, ev) {
    var emitThrottles = this.emitThrottles;
    var newEvent = {
      type,
      ev
    };
    for (var i = 0, len5 = emitThrottles.length; i < len5; i++) {
      if (emitThrottles[i].type === type) {
        emitThrottles.splice(i, 1, newEvent);
        return;
      }
    }
    emitThrottles.push(newEvent);
  };
  _proto.clearPressTimeout = function clearPressTimeout() {
    if (this.pressTimeout) {
      clearTimeout(this.pressTimeout);
      this.pressTimeout = null;
    }
  };
  _proto.reset = function reset() {
    this.clearPressTimeout();
    this.startTime = 0;
    this.startDistance = 0;
    this.direction = null;
    this.eventType = null;
    this.prevMoveTime = 0;
    this.prevMovePoint = null;
    this.lastMoveTime = 0;
    this.lastMovePoint = null;
  };
  return Gesture3;
}(import_eventemitter32.default);
var index_esm_default = Gesture;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/gesture.js
var G_SHAPE_EVENT = {
  click: true,
  touchstart: true,
  touchmove: true,
  touchend: true,
  touchendoutside: true,
  dragenter: true,
  dragleave: true,
  dragover: true,
  drop: true,
  dragstart: true,
  drag: true,
  dragend: true
};
var GESTURE_EVENT = {
  panstart: true,
  pan: true,
  panend: true,
  pressstart: true,
  press: true,
  pressend: true,
  swipe: true,
  pinchstart: true,
  pinch: true,
  pinchend: true
};
var Gesture2 = (
  /** @class */
  function() {
    function Gesture3(element) {
      this.el = element;
      this.gesture = new index_esm_default(element);
    }
    Gesture3.prototype.on = function(eventName, listener) {
      var _a = this, el = _a.el, gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.addEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.on(eventName, listener);
      }
    };
    Gesture3.prototype.off = function(eventName, listener) {
      var _a = this, el = _a.el, gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.removeEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.off(eventName, listener);
      }
    };
    return Gesture3;
  }()
);
var gesture_default = Gesture2;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/jsx/tag.js
var SHAPE_TAG = {};
var registerTag = function registerTag2(name, ShapeConstructor) {
  SHAPE_TAG[name] = ShapeConstructor;
};
var getTag = function getTag2(type) {
  return SHAPE_TAG[type];
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/createShape.js
var EVENT_LIST = [
  ["click", "onClick"],
  ["touchstart", "onTouchStart"],
  ["touchmove", "onTouchMove"],
  ["touchend", "onTouchEnd"],
  ["touchendoutside", "onTouchEndOutside"],
  // drage 
  ["dragenter", "onDragEnter"],
  ["dragleave", "onDragLeave"],
  ["dragover", "onDragOver"],
  ["drop", "onDrop"],
  ["dragstart", "onDragStart"],
  ["drag", "onDrag"],
  ["dragend", "onDragEnd"],
  // pan
  ["panstart", "onPanStart"],
  ["pan", "onPan"],
  ["panend", "onPanEnd"],
  // press
  ["pressstart", "onPressStart"],
  ["press", "onPress"],
  ["pressend", "onPressEnd"],
  // swipe
  ["swipe", "onSwipe"],
  // pinch
  ["pinchstart", "onPinchStart"],
  ["pinch", "onPinch"],
  ["pinchend", "onPinchEnd"]
];
var TagElements = [["group", Rect], ["text", Text], ["circle", Circle], ["path", Path], ["ellipse", Ellipse], ["rect", Rect], ["image", Image], ["line", Line], ["polyline", SmoothPolyline], ["polygon", Polygon], ["arc", Arc], ["marker", Marker], ["sector", Sector]];
TagElements.map(function(_a) {
  var type = _a[0], ShapeClass = _a[1];
  registerTag(type, ShapeClass);
});
var SECTOR_CSS_PROPERTY = [{
  name: "r0",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE
}, {
  name: "startAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}, {
  name: "endAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}];
SECTOR_CSS_PROPERTY.forEach(function(property) {
  CSS.registerProperty(property);
});
function createShape(type, props) {
  if (!type)
    return null;
  var ShapeClass = getTag(type);
  if (!ShapeClass)
    return null;
  var shape = new ShapeClass(props);
  addEvent(shape, props);
  return shape;
}
function addEvent(shape, props) {
  var gesture = new gesture_default(shape);
  EVENT_LIST.forEach(function(_a) {
    var eventName = _a[0], handlerName = _a[1];
    if (!props[handlerName])
      return;
    gesture.on(eventName, props[handlerName]);
  });
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/equal.js
function objToString(obj) {
  return Object.prototype.toString.call(obj);
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function equal(a, b) {
  if (a === b)
    return true;
  if (_typeof(a) !== _typeof(b)) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true;
  }
  if (objToString(a) !== objToString(b)) {
    return false;
  }
  if (is_function_default(a)) {
    return true;
  }
  if (_typeof(a) !== "object") {
    return false;
  }
  if (is_array_default(a)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = a.length - 1; i >= 0; i--) {
      if (!equal(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (!is_plain_object_default(a)) {
    return false;
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (var i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    }
  }
  for (var i = ka.length - 1; i >= 0; i--) {
    var key = ka[i];
    if (!equal(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
var equal_default = equal;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/workTags.js
var FunctionComponent = 0;
var ClassComponent = 1;
var Shape2 = 2;
function getWorkTag(type) {
  if (is_string_default(type)) {
    return Shape2;
  }
  if (type.prototype && type.prototype.isF2Component) {
    return ClassComponent;
  }
  return FunctionComponent;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/findClosestShapeNode.js
function findClosestShapeNode(vNode) {
  var tag = vNode.tag, children = vNode.children;
  if (tag === Shape2) {
    return vNode;
  }
  var shapeNode;
  children_default.map(children, function(child) {
    if (shapeNode)
      return;
    shapeNode = findClosestShapeNode(child);
  });
  return shapeNode;
}
var findClosestShapeNode_default = findClosestShapeNode;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animator.js
var import_eventemitter33 = __toESM(require_eventemitter3());

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/applyStyle.js
function applyStyle(shape, style) {
  if (!style)
    return;
  Object.keys(style).forEach(function(key) {
    if (key === "clip" || key === "offset") {
      var effect = style[key];
      if (isDisplayObject(effect === null || effect === void 0 ? void 0 : effect.current)) {
        shape.setAttribute("".concat(key, "Path"), effect.current);
        return;
      }
      var effectConfig = is_function_default(effect) ? effect(style) : effect;
      if (effectConfig) {
        var type = effectConfig.type, style_1 = effectConfig.style;
        var effectShape = createShape(type, {
          style: style_1
        });
        shape.setAttribute("".concat(key, "Path"), effectShape);
      }
    } else {
      shape.setAttribute(key, style[key]);
    }
  });
}
var applyStyle_default = applyStyle;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animator.js
var Animator = (
  /** @class */
  function(_super) {
    __extends(Animator2, _super);
    function Animator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Animator2.prototype.animate = function(shape, start, end, effect) {
      this.shape = shape;
      this.start = start;
      this.end = end;
      this.effect = effect;
    };
    Animator2.prototype.loadPlay = function() {
      var _a = this, shape = _a.shape, start = _a.start, end = _a.end, effect = _a.effect, children = _a.children;
      var animations = [];
      if (effect) {
        var _b = effect.property, property = _b === void 0 ? [] : _b, easing = effect.easing, duration = effect.duration, delay = effect.delay, iterations = effect.iterations, clip = effect.clip, _c = effect.onFrame, onFrame = _c === void 0 ? function() {
        } : _c, _d = effect.onEnd, onEnd = _d === void 0 ? function() {
        } : _d;
        if (property.length && duration > 0) {
          var style = __assign(__assign({}, omit_default(end, property)), omit_default(start, property));
          applyStyle_default(shape, style);
          var keyframeStart = property.reduce(function(prev, cur) {
            prev[cur] = start[cur];
            return prev;
          }, {});
          var keyframeEnd = pick_default(end, property);
          var animation = shape.animate([keyframeStart, keyframeEnd], {
            fill: "both",
            easing,
            duration,
            delay,
            iterations
          });
          if (animation) {
            animation.onframe = onFrame;
            animation.onfinish = onEnd;
            if (iterations !== Infinity) {
              animations.push(animation);
            }
            this.animation = animation;
          } else {
            applyStyle_default(shape, end);
          }
        } else {
          applyStyle_default(shape, end);
        }
        if (clip) {
          var clipConfig = is_function_default(clip) ? clip(end) : clip;
          if (clipConfig) {
            var clipType = clipConfig.type, clipStyle = clipConfig.style, _e = clipConfig.property, clipProperty = _e === void 0 ? [] : _e, clipEasing = clipConfig.easing, clipDuration = clipConfig.duration, clipDelay = clipConfig.delay, clipIterations = clipConfig.iterations, clipStart = clipConfig.start, clipEnd = clipConfig.end;
            if (clipProperty.length && (clipDuration || duration) > 0) {
              var clipStartStyle_1 = __assign(__assign({}, clipStyle), clipStart);
              var clipEndStyle = __assign(__assign({}, clipStyle), clipEnd);
              var clipKeyframeStart = clipProperty.reduce(function(prev, cur) {
                prev[cur] = clipStartStyle_1[cur];
                return prev;
              }, {});
              var clipKeyframeEnd = pick_default(clipEndStyle, clipProperty);
              var clipShape_1 = createShape(clipType, {
                style: clipStartStyle_1
              });
              shape.setAttribute("clipPath", clipShape_1);
              shape.ownerDocument.documentElement.appendChild(clipShape_1);
              var clipAnimation = clipShape_1.animate([clipKeyframeStart, clipKeyframeEnd], {
                fill: "both",
                easing: clipEasing || easing,
                duration: clipDuration || duration,
                delay: clipDelay || delay,
                iterations: clipIterations || iterations
              });
              if (clipAnimation) {
                var clipFinished = clipAnimation.finished;
                this.animation = clipAnimation;
                clipFinished.then(function() {
                  shape.setAttribute("clipPath", null);
                  clipShape_1.destroy();
                });
                if ((clipIterations || iterations) !== Infinity) {
                  animations.push(clipAnimation);
                }
              } else {
                shape.setAttribute("clipPath", null);
                clipShape_1.destroy();
              }
            }
          }
        }
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          var childAnimator = child.loadPlay();
          if (childAnimator) {
            animations.push.apply(animations, childAnimator);
          }
        });
      }
      this.endEmit(animations);
      return animations;
    };
    Animator2.prototype.pause = function() {
      var _a = this, children = _a.children, animation = _a.animation;
      if (animation) {
        animation.pause();
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          child.pause();
        });
      }
    };
    Animator2.prototype.endEmit = function(animations) {
      var _this2 = this;
      if (!animations.length) {
        this.emit("end");
        return null;
      }
      var finished = Promise.all(animations.map(function(d4) {
        return d4.finished;
      }));
      finished.then(function() {
        _this2.emit("end");
      });
    };
    Animator2.prototype.play = function() {
      var _a = this, children = _a.children, animation = _a.animation;
      if (animation) {
        animation.play();
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          child.play();
        });
      }
    };
    Animator2.prototype.reset = function(shape) {
      this.shape = shape;
      this.start = null;
      this.end = null;
      this.effect = null;
      this.children = null;
    };
    return Animator2;
  }(import_eventemitter33.default)
);
var animator_default = Animator;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animation.js
function findAllShapeNode(vNode) {
  var shapeNodes = [];
  children_default.map(vNode, function(node) {
    if (!node)
      return;
    var tag = node.tag, type = node.type, children = node.children;
    if (tag === Shape2 && type !== "group") {
      shapeNodes.push(node);
    }
    if (children) {
      shapeNodes.push.apply(shapeNodes, findAllShapeNode(children));
    }
  });
  return shapeNodes;
}
function morphShape(lastNode, nextNode, animator) {
  var nextProps = nextNode.props, nextShape = nextNode.shape, nextStyle = nextNode.style;
  var lastShape = lastNode.shape, lastStyle = lastNode.style;
  lastShape.destroy();
  var animate = nextProps.animate, animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  if (animate === false || !animationEffect) {
    return animator;
  }
  animator = animator || new animator_default();
  var start = animationEffect.start, end = animationEffect.end, _a = animationEffect.property, property = _a === void 0 ? [] : _a;
  var nextParsedStyle = nextShape.parsedStyle;
  var lastParsedStyle = lastShape.parsedStyle;
  var lastPath = convertToPath(lastShape);
  var nextPath = convertToPath(nextShape);
  var startStyle = __assign(__assign(__assign({}, lastStyle), start), {
    path: lastPath
  });
  var endStyle = __assign(__assign(__assign({}, nextStyle), end), {
    path: nextPath
  });
  var pathShape = createShape("path", {
    style: __assign(__assign({}, startStyle), {
      path: ""
    })
  });
  var animateProperty = property.filter(function(key) {
    return nextParsedStyle.hasOwnProperty(key) && lastParsedStyle.hasOwnProperty(key);
  }).concat("path");
  animator.animate(pathShape, startStyle, endStyle, __assign(__assign({}, animationEffect), {
    property: animateProperty
  }));
  animator.once("end", function() {
    applyStyle_default(nextShape, endStyle);
    pathShape.replaceWith(nextShape);
  });
  return animator;
}
function appearAnimation(vNode) {
  return children_default.map(vNode, function(node) {
    if (!node)
      return;
    var tag = node.tag, shape = node.shape, style = node.style, children = node.children, animate = node.animate, props = node.props, animator = node.animator;
    animator.reset(shape);
    animator.children = children ? createAnimation(node, children, null) : null;
    if (animate === false || tag !== Shape2) {
      applyStyle_default(shape, style);
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.appear : null;
    if (!animationEffect) {
      applyStyle_default(shape, style);
      return animator;
    }
    var _a = animationEffect.start, start = _a === void 0 ? {} : _a, end = animationEffect.end;
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(shape, start, endStyle, animationEffect);
    return animator;
  });
}
function updateAnimation(nextNode, lastNode) {
  var nextTag = nextNode.tag, nextType = nextNode.type, nextStyle = nextNode.style, nextChildren = nextNode.children, nextProps = nextNode.props, nextShape = nextNode.shape, animator = nextNode.animator, animate = nextNode.animate;
  var lastTag = lastNode.tag, lastType = lastNode.type, lastStyle = lastNode.style, lastChildren = lastNode.children, lastShape = lastNode.shape;
  animator.reset(nextShape);
  animator.children = createAnimation(nextNode, nextChildren, lastChildren);
  var animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  if (nextType === lastType) {
    var resetStyle = lastStyle ? Object.keys(lastStyle).reduce(function(prev, cur) {
      prev[cur] = "";
      return prev;
    }, {}) : null;
    var style = __assign(__assign({}, resetStyle), nextStyle);
    if (nextTag !== Shape2) {
      applyStyle_default(nextShape, style);
      return animator;
    }
    if (animate === false || !animationEffect) {
      applyStyle_default(nextShape, style);
      return animator;
    }
    var start = animationEffect.start, end = animationEffect.end;
    var startStyle = __assign(__assign({}, lastStyle), start);
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(nextShape, startStyle, endStyle, animationEffect);
    return animator;
  }
  if (nextTag !== Shape2 || lastTag !== Shape2) {
    lastShape.destroy();
    return animator;
  }
  if (nextType === "group") {
    var shapeNodes = findAllShapeNode(nextNode.children);
    return shapeNodes.map(function(node) {
      return morphShape(lastNode, node);
    });
  }
  if (lastType === "group") {
    var shapeNodes = findAllShapeNode(lastNode.children);
    return shapeNodes.map(function(node) {
      return morphShape(node, nextNode);
    });
  }
  if (animate === false || !animationEffect) {
    applyStyle_default(nextShape, nextStyle);
    return animator;
  }
  return morphShape(lastNode, nextNode, animator);
}
function destroyAnimation(node) {
  return children_default.map(node, function(vNode) {
    if (!vNode)
      return null;
    var tag = vNode.tag, shape = vNode.shape, children = vNode.children, animate = vNode.animate, style = vNode.style, props = vNode.props, animator = vNode.animator;
    if (shape.destroyed) {
      return null;
    }
    animator.reset(shape);
    var childrenAnimation = children ? children_default.toArray(children).map(function(child) {
      return destroyAnimation(child);
    }).filter(Boolean) : null;
    if (animate === false) {
      shape.destroy();
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.leave : null;
    if (!(childrenAnimation && childrenAnimation.length) && !animationEffect) {
      shape.destroy();
      return animator;
    }
    animator.children = childrenAnimation;
    if (animationEffect && tag === Shape2) {
      var start = animationEffect.start, _a = animationEffect.end, end = _a === void 0 ? {} : _a;
      var startStyle = __assign(__assign({}, style), start);
      var endStyle = end;
      animator.animate(shape, startStyle, endStyle, animationEffect);
    }
    animator.once("end", function() {
      shape.destroy();
    });
    return animator;
  });
}
function createAnimator(nextNode, lastNode) {
  if (!nextNode && !lastNode) {
    return null;
  }
  if (!nextNode && lastNode) {
    return destroyAnimation(lastNode);
  }
  var transform = nextNode.transform;
  if (transform) {
    var closestShapeNode = findClosestShapeNode_default(nextNode);
    nextNode.transform = null;
    closestShapeNode.transform = transform;
  }
  if (nextNode.transform) {
    if (!lastNode) {
      return updateAnimation(nextNode, nextNode.transform);
    }
    return [updateAnimation(nextNode, nextNode.transform), destroyAnimation(lastNode)];
  }
  if (nextNode && !lastNode) {
    return appearAnimation(nextNode);
  }
  return updateAnimation(nextNode, lastNode);
}
function insertShape(parent, shape, nextSibling) {
  if (nextSibling) {
    parent.insertBefore(shape, nextSibling);
  } else {
    parent.appendChild(shape);
  }
}
function createAnimation(parent, nextChildren, lastChildren) {
  if (!nextChildren && !lastChildren) {
    return;
  }
  var parentShape = parent.shape;
  var prevSibling;
  var childrenAnimator = [];
  children_default.compare(nextChildren, lastChildren, function(nextNode, lastNode) {
    var animator = createAnimator(nextNode, lastNode);
    children_default.map(animator, function(item) {
      if (!item)
        return;
      childrenAnimator.push(item);
      var shape = item.shape;
      if (!shape || shape.destroyed)
        return;
      var nextSibling;
      if (!prevSibling) {
        nextSibling = parentShape.firstChild;
      } else {
        nextSibling = prevSibling.nextSibling;
      }
      if (nextSibling !== shape) {
        insertShape(parentShape, shape, nextSibling);
      }
      prevSibling = shape;
    });
  });
  return childrenAnimator;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/rect.js
var rect_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width, height = layout.height;
  return {
    x: left,
    y: top,
    width,
    height
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/line.js
var line_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width, height = layout.height;
  return {
    x1: left,
    y1: top,
    x2: left + width,
    y2: top + height
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/text.js
var text_default = function(layout) {
  var height = layout.height, left = layout.left, top = layout.top;
  return {
    x: left,
    y: top + height / 2,
    // middle + top 
    textBaseline: "middle"
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/circle.js
var circle_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width;
  var r = width / 2;
  return {
    cx: left + r,
    cy: top + r,
    r
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/marker.js
var marker_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width;
  var r = width / 2;
  return {
    x: left + r,
    y: top,
    radius: r
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/index.js
var map2 = {
  rect: rect_default,
  line: line_default,
  text: text_default,
  circle: circle_default,
  marker: marker_default,
  group: rect_default
};
var shape_default = function(type, layout) {
  if (!layout)
    return null;
  var fn = map2[type] || rect_default;
  return fn(layout);
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/css-layout.js
var CSS_UNDEFINED;
var CSS_DIRECTION_INHERIT = "inherit";
var CSS_DIRECTION_LTR = "ltr";
var CSS_DIRECTION_RTL = "rtl";
var CSS_FLEX_DIRECTION_ROW = "row";
var CSS_FLEX_DIRECTION_ROW_REVERSE = "row-reverse";
var CSS_FLEX_DIRECTION_COLUMN = "column";
var CSS_FLEX_DIRECTION_COLUMN_REVERSE = "column-reverse";
var CSS_JUSTIFY_FLEX_START = "flex-start";
var CSS_JUSTIFY_CENTER = "center";
var CSS_JUSTIFY_FLEX_END = "flex-end";
var CSS_JUSTIFY_SPACE_BETWEEN = "space-between";
var CSS_JUSTIFY_SPACE_AROUND = "space-around";
var CSS_ALIGN_FLEX_START = "flex-start";
var CSS_ALIGN_CENTER = "center";
var CSS_ALIGN_FLEX_END = "flex-end";
var CSS_ALIGN_STRETCH = "stretch";
var CSS_POSITION_RELATIVE = "relative";
var CSS_POSITION_ABSOLUTE = "absolute";
var leading = {
  row: "left",
  "row-reverse": "right",
  column: "top",
  "column-reverse": "bottom"
};
var trailing = {
  row: "right",
  "row-reverse": "left",
  column: "bottom",
  "column-reverse": "top"
};
var pos = {
  row: "left",
  "row-reverse": "right",
  column: "top",
  "column-reverse": "bottom"
};
var dim = {
  row: "width",
  "row-reverse": "width",
  column: "height",
  "column-reverse": "height"
};
function fillNodes(node) {
  if (!node.layout || node.isDirty) {
    node.layout = {
      width: void 0,
      height: void 0,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  if (!node.style) {
    node.style = {};
  }
  if (!node.children) {
    node.children = [];
  }
  node.children.forEach(fillNodes);
  return node;
}
function isUndefined2(value) {
  return value === void 0;
}
function isRowDirection(flexDirection) {
  return flexDirection === CSS_FLEX_DIRECTION_ROW || flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;
}
function isColumnDirection(flexDirection) {
  return flexDirection === CSS_FLEX_DIRECTION_COLUMN || flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;
}
function getLeadingMargin(node, axis) {
  if (node.style.marginStart !== void 0 && isRowDirection(axis)) {
    return node.style.marginStart;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.marginLeft;
      break;
    case "row-reverse":
      value = node.style.marginRight;
      break;
    case "column":
      value = node.style.marginTop;
      break;
    case "column-reverse":
      value = node.style.marginBottom;
      break;
  }
  if (value !== void 0) {
    return value;
  }
  if (node.style.margin !== void 0) {
    return node.style.margin;
  }
  return 0;
}
function getTrailingMargin(node, axis) {
  if (node.style.marginEnd !== void 0 && isRowDirection(axis)) {
    return node.style.marginEnd;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.marginRight;
      break;
    case "row-reverse":
      value = node.style.marginLeft;
      break;
    case "column":
      value = node.style.marginBottom;
      break;
    case "column-reverse":
      value = node.style.marginTop;
      break;
  }
  if (value != null) {
    return value;
  }
  if (node.style.margin !== void 0) {
    return node.style.margin;
  }
  return 0;
}
function getLeadingPadding(node, axis) {
  if (node.style.paddingStart !== void 0 && node.style.paddingStart >= 0 && isRowDirection(axis)) {
    return node.style.paddingStart;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.paddingLeft;
      break;
    case "row-reverse":
      value = node.style.paddingRight;
      break;
    case "column":
      value = node.style.paddingTop;
      break;
    case "column-reverse":
      value = node.style.paddingBottom;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.padding !== void 0 && node.style.padding >= 0) {
    return node.style.padding;
  }
  return 0;
}
function getTrailingPadding(node, axis) {
  if (node.style.paddingEnd !== void 0 && node.style.paddingEnd >= 0 && isRowDirection(axis)) {
    return node.style.paddingEnd;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.paddingRight;
      break;
    case "row-reverse":
      value = node.style.paddingLeft;
      break;
    case "column":
      value = node.style.paddingBottom;
      break;
    case "column-reverse":
      value = node.style.paddingTop;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.padding !== void 0 && node.style.padding >= 0) {
    return node.style.padding;
  }
  return 0;
}
function getLeadingBorder(node, axis) {
  if (node.style.borderStartWidth !== void 0 && node.style.borderStartWidth >= 0 && isRowDirection(axis)) {
    return node.style.borderStartWidth;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.borderLeftWidth;
      break;
    case "row-reverse":
      value = node.style.borderRightWidth;
      break;
    case "column":
      value = node.style.borderTopWidth;
      break;
    case "column-reverse":
      value = node.style.borderBottomWidth;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.borderWidth !== void 0 && node.style.borderWidth >= 0) {
    return node.style.borderWidth;
  }
  return 0;
}
function getTrailingBorder(node, axis) {
  if (node.style.borderEndWidth !== void 0 && node.style.borderEndWidth >= 0 && isRowDirection(axis)) {
    return node.style.borderEndWidth;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.borderRightWidth;
      break;
    case "row-reverse":
      value = node.style.borderLeftWidth;
      break;
    case "column":
      value = node.style.borderBottomWidth;
      break;
    case "column-reverse":
      value = node.style.borderTopWidth;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.borderWidth !== void 0 && node.style.borderWidth >= 0) {
    return node.style.borderWidth;
  }
  return 0;
}
function getLeadingPaddingAndBorder(node, axis) {
  return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);
}
function getTrailingPaddingAndBorder(node, axis) {
  return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);
}
function getBorderAxis(node, axis) {
  return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);
}
function getMarginAxis(node, axis) {
  return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);
}
function getPaddingAndBorderAxis(node, axis) {
  return getLeadingPaddingAndBorder(node, axis) + getTrailingPaddingAndBorder(node, axis);
}
function getJustifyContent(node) {
  if (node.style.justifyContent) {
    return node.style.justifyContent;
  }
  return "flex-start";
}
function getAlignContent(node) {
  if (node.style.alignContent) {
    return node.style.alignContent;
  }
  return "flex-start";
}
function getAlignItem(node, child) {
  if (child.style.alignSelf) {
    return child.style.alignSelf;
  }
  if (node.style.alignItems) {
    return node.style.alignItems;
  }
  return "stretch";
}
function resolveAxis(axis, direction) {
  if (direction === CSS_DIRECTION_RTL) {
    if (axis === CSS_FLEX_DIRECTION_ROW) {
      return CSS_FLEX_DIRECTION_ROW_REVERSE;
    } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {
      return CSS_FLEX_DIRECTION_ROW;
    }
  }
  return axis;
}
function resolveDirection(node, parentDirection) {
  var direction;
  if (node.style.direction) {
    direction = node.style.direction;
  } else {
    direction = CSS_DIRECTION_INHERIT;
  }
  if (direction === CSS_DIRECTION_INHERIT) {
    direction = parentDirection === void 0 ? CSS_DIRECTION_LTR : parentDirection;
  }
  return direction;
}
function getFlexDirection(node) {
  if (node.style.flexDirection) {
    return node.style.flexDirection;
  }
  return CSS_FLEX_DIRECTION_COLUMN;
}
function getCrossFlexDirection(flexDirection, direction) {
  if (isColumnDirection(flexDirection)) {
    return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
  } else {
    return CSS_FLEX_DIRECTION_COLUMN;
  }
}
function getPositionType(node) {
  if (node.style.position) {
    return node.style.position;
  }
  return "relative";
}
function isFlex(node) {
  return getPositionType(node) === CSS_POSITION_RELATIVE && node.style.flex > 0;
}
function isFlexWrap(node) {
  return node.style.flexWrap === "wrap";
}
function getDimWithMargin(node, axis) {
  return node.layout[dim[axis]] + getMarginAxis(node, axis);
}
function isDimDefined(node, axis) {
  return node.style[dim[axis]] !== void 0 && node.style[dim[axis]] >= 0;
}
function isPosDefined(node, pos2) {
  return node.style[pos2] !== void 0;
}
function isMeasureDefined(node) {
  return node.style.measure !== void 0;
}
function getPosition(node, pos2) {
  if (node.style[pos2] !== void 0) {
    return node.style[pos2];
  }
  return 0;
}
function boundAxis(node, axis, value) {
  var min4 = {
    row: node.style.minWidth,
    "row-reverse": node.style.minWidth,
    column: node.style.minHeight,
    "column-reverse": node.style.minHeight
  }[axis];
  var max4 = {
    row: node.style.maxWidth,
    "row-reverse": node.style.maxWidth,
    column: node.style.maxHeight,
    "column-reverse": node.style.maxHeight
  }[axis];
  var boundValue = value;
  if (max4 !== void 0 && max4 >= 0 && boundValue > max4) {
    boundValue = max4;
  }
  if (min4 !== void 0 && min4 >= 0 && boundValue < min4) {
    boundValue = min4;
  }
  return boundValue;
}
function fmaxf(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}
function setDimensionFromStyle(node, axis) {
  if (node.layout[dim[axis]] !== void 0) {
    return;
  }
  if (!isDimDefined(node, axis)) {
    return;
  }
  node.layout[dim[axis]] = fmaxf(boundAxis(node, axis, node.style[dim[axis]]), getPaddingAndBorderAxis(node, axis));
}
function setTrailingPosition(node, child, axis) {
  child.layout[trailing[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - child.layout[pos[axis]];
}
function getRelativePosition(node, axis) {
  if (node.style[leading[axis]] !== void 0) {
    return getPosition(node, leading[axis]);
  }
  return -getPosition(node, trailing[axis]);
}
function layoutNodeImpl(node, parentMaxWidth, parentDirection) {
  var direction = resolveDirection(node, parentDirection);
  var mainAxis = resolveAxis(getFlexDirection(node), direction);
  var crossAxis = getCrossFlexDirection(mainAxis, direction);
  var resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
  setDimensionFromStyle(node, mainAxis);
  setDimensionFromStyle(node, crossAxis);
  node.layout.direction = direction;
  node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
  node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
  node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
  node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
  var childCount = node.children.length;
  var paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);
  if (isMeasureDefined(node)) {
    var isResolvedRowDimDefined = !isUndefined2(node.layout[dim[resolvedRowAxis]]);
    var width = CSS_UNDEFINED;
    if (isDimDefined(node, resolvedRowAxis)) {
      width = node.style.width;
    } else if (isResolvedRowDimDefined) {
      width = node.layout[dim[resolvedRowAxis]];
    } else {
      width = parentMaxWidth - getMarginAxis(node, resolvedRowAxis);
    }
    width -= paddingAndBorderAxisResolvedRow;
    var isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;
    var isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined2(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);
    if (isRowUndefined || isColumnUndefined) {
      var measureDim = node.style.measure(
        /*(c)!node->context,*/
        /*(java)!layoutContext.measureOutput,*/
        width
      );
      if (isRowUndefined) {
        node.layout.width = measureDim.width + paddingAndBorderAxisResolvedRow;
      }
      if (isColumnUndefined) {
        node.layout.height = measureDim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);
      }
    }
    if (childCount === 0) {
      return;
    }
  }
  var isNodeFlexWrap = isFlexWrap(node);
  var justifyContent = getJustifyContent(node);
  var leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);
  var leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);
  var paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);
  var paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);
  var isMainDimDefined = !isUndefined2(node.layout[dim[mainAxis]]);
  var isCrossDimDefined = !isUndefined2(node.layout[dim[crossAxis]]);
  var isMainRowDirection = isRowDirection(mainAxis);
  var i;
  var ii;
  var child;
  var axis;
  var firstAbsoluteChild = null;
  var currentAbsoluteChild = null;
  var definedMainDim = CSS_UNDEFINED;
  if (isMainDimDefined) {
    definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;
  }
  var startLine = 0;
  var endLine = 0;
  var alreadyComputedNextLayout = 0;
  var linesCrossDim = 0;
  var linesMainDim = 0;
  var linesCount = 0;
  while (endLine < childCount) {
    var mainContentDim = 0;
    var flexibleChildrenCount = 0;
    var totalFlexible = 0;
    var nonFlexibleChildrenCount = 0;
    var isSimpleStackMain = isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START || !isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER;
    var firstComplexMain = isSimpleStackMain ? childCount : startLine;
    var isSimpleStackCross = true;
    var firstComplexCross = childCount;
    var firstFlexChild = null;
    var currentFlexChild = null;
    var mainDim = leadingPaddingAndBorderMain;
    var crossDim = 0;
    var maxWidth;
    for (i = startLine; i < childCount; ++i) {
      child = node.children[i];
      child.lineIndex = linesCount;
      child.nextAbsoluteChild = null;
      child.nextFlexChild = null;
      var alignItem = getAlignItem(node, child);
      if (alignItem === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && isCrossDimDefined && !isDimDefined(child, crossAxis)) {
        child.layout[dim[crossAxis]] = fmaxf(
          boundAxis(child, crossAxis, node.layout[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(child, crossAxis)
        );
      } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {
        if (firstAbsoluteChild === null) {
          firstAbsoluteChild = child;
        }
        if (currentAbsoluteChild !== null) {
          currentAbsoluteChild.nextAbsoluteChild = child;
        }
        currentAbsoluteChild = child;
        for (ii = 0; ii < 2; ii++) {
          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
          if (!isUndefined2(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {
            child.layout[dim[axis]] = fmaxf(
              boundAxis(child, axis, node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])),
              // You never want to go smaller than padding
              getPaddingAndBorderAxis(child, axis)
            );
          }
        }
      }
      var nextContentDim = 0;
      if (isMainDimDefined && isFlex(child)) {
        flexibleChildrenCount++;
        totalFlexible += child.style.flex;
        if (firstFlexChild === null) {
          firstFlexChild = child;
        }
        if (currentFlexChild !== null) {
          currentFlexChild.nextFlexChild = child;
        }
        currentFlexChild = child;
        nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);
      } else {
        maxWidth = CSS_UNDEFINED;
        if (!isMainRowDirection) {
          if (isDimDefined(node, resolvedRowAxis)) {
            maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
          } else {
            maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
          }
        }
        if (alreadyComputedNextLayout === 0) {
          layoutNode(
            /*(java)!layoutContext, */
            child,
            maxWidth,
            direction
          );
        }
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          nonFlexibleChildrenCount++;
          nextContentDim = getDimWithMargin(child, mainAxis);
        }
      }
      if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim && // If there's only one element, then it's bigger than the content
      // and needs its own line
      i !== startLine) {
        nonFlexibleChildrenCount--;
        alreadyComputedNextLayout = 1;
        break;
      }
      if (isSimpleStackMain && (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {
        isSimpleStackMain = false;
        firstComplexMain = i;
      }
      if (isSimpleStackCross && (getPositionType(child) !== CSS_POSITION_RELATIVE || alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START || isUndefined2(child.layout[dim[crossAxis]]))) {
        isSimpleStackCross = false;
        firstComplexCross = i;
      }
      if (isSimpleStackMain) {
        child.layout[pos[mainAxis]] += mainDim;
        if (isMainDimDefined) {
          setTrailingPosition(node, child, mainAxis);
        }
        mainDim += getDimWithMargin(child, mainAxis);
        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
      }
      if (isSimpleStackCross) {
        child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;
        if (isCrossDimDefined) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
      alreadyComputedNextLayout = 0;
      mainContentDim += nextContentDim;
      endLine = i + 1;
    }
    var leadingMainDim = 0;
    var betweenMainDim = 0;
    var remainingMainDim = 0;
    if (isMainDimDefined) {
      remainingMainDim = definedMainDim - mainContentDim;
    } else {
      remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;
    }
    if (flexibleChildrenCount !== 0) {
      var flexibleMainDim = remainingMainDim / totalFlexible;
      var baseMainDim;
      var boundMainDim;
      currentFlexChild = firstFlexChild;
      while (currentFlexChild !== null) {
        baseMainDim = flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis);
        boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);
        if (baseMainDim !== boundMainDim) {
          remainingMainDim -= boundMainDim;
          totalFlexible -= currentFlexChild.style.flex;
        }
        currentFlexChild = currentFlexChild.nextFlexChild;
      }
      flexibleMainDim = remainingMainDim / totalFlexible;
      if (flexibleMainDim < 0) {
        flexibleMainDim = 0;
      }
      currentFlexChild = firstFlexChild;
      while (currentFlexChild !== null) {
        currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis));
        maxWidth = CSS_UNDEFINED;
        if (isDimDefined(node, resolvedRowAxis)) {
          maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
        } else if (!isMainRowDirection) {
          maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
        }
        layoutNode(
          /*(java)!layoutContext, */
          currentFlexChild,
          maxWidth,
          direction
        );
        child = currentFlexChild;
        currentFlexChild = currentFlexChild.nextFlexChild;
        child.nextFlexChild = null;
      }
    } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {
      if (justifyContent === CSS_JUSTIFY_CENTER) {
        leadingMainDim = remainingMainDim / 2;
      } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {
        leadingMainDim = remainingMainDim;
      } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {
        remainingMainDim = fmaxf(remainingMainDim, 0);
        if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {
          betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
        } else {
          betweenMainDim = 0;
        }
      } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {
        betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
        leadingMainDim = betweenMainDim / 2;
      }
    }
    mainDim += leadingMainDim;
    for (i = firstComplexMain; i < endLine; ++i) {
      child = node.children[i];
      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {
        child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis);
      } else {
        child.layout[pos[mainAxis]] += mainDim;
        if (isMainDimDefined) {
          setTrailingPosition(node, child, mainAxis);
        }
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);
          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
        }
      }
    }
    var containerCrossAxis = node.layout[dim[crossAxis]];
    if (!isCrossDimDefined) {
      containerCrossAxis = fmaxf(
        // For the cross dim, we add both sides at the end because the value
        // is aggregate via a max function. Intermediate negative values
        // can mess this computation otherwise
        boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),
        paddingAndBorderAxisCross
      );
    }
    for (i = firstComplexCross; i < endLine; ++i) {
      child = node.children[i];
      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {
        child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis);
      } else {
        var leadingCrossDim = leadingPaddingAndBorderCross;
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          var alignItem = getAlignItem(node, child);
          if (alignItem === CSS_ALIGN_STRETCH) {
            if (isUndefined2(child.layout[dim[crossAxis]])) {
              child.layout[dim[crossAxis]] = fmaxf(
                boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
                // You never want to go smaller than padding
                getPaddingAndBorderAxis(child, crossAxis)
              );
            }
          } else if (alignItem !== CSS_ALIGN_FLEX_START) {
            var remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);
            if (alignItem === CSS_ALIGN_CENTER) {
              leadingCrossDim += remainingCrossDim / 2;
            } else {
              leadingCrossDim += remainingCrossDim;
            }
          }
        }
        child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;
        if (isCrossDimDefined) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
    }
    linesCrossDim += crossDim;
    linesMainDim = fmaxf(linesMainDim, mainDim);
    linesCount += 1;
    startLine = endLine;
  }
  if (linesCount > 1 && isCrossDimDefined) {
    var nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] - paddingAndBorderAxisCross;
    var remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;
    var crossDimLead = 0;
    var currentLead = leadingPaddingAndBorderCross;
    var alignContent = getAlignContent(node);
    if (alignContent === CSS_ALIGN_FLEX_END) {
      currentLead += remainingAlignContentDim;
    } else if (alignContent === CSS_ALIGN_CENTER) {
      currentLead += remainingAlignContentDim / 2;
    } else if (alignContent === CSS_ALIGN_STRETCH) {
      if (nodeCrossAxisInnerSize > linesCrossDim) {
        crossDimLead = remainingAlignContentDim / linesCount;
      }
    }
    var endIndex = 0;
    for (i = 0; i < linesCount; ++i) {
      var startIndex = endIndex;
      var lineHeight = 0;
      for (ii = startIndex; ii < childCount; ++ii) {
        child = node.children[ii];
        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
          continue;
        }
        if (child.lineIndex !== i) {
          break;
        }
        if (!isUndefined2(child.layout[dim[crossAxis]])) {
          lineHeight = fmaxf(lineHeight, child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis));
        }
      }
      endIndex = ii;
      lineHeight += crossDimLead;
      for (ii = startIndex; ii < endIndex; ++ii) {
        child = node.children[ii];
        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
          continue;
        }
        var alignContentAlignItem = getAlignItem(node, child);
        if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {
          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
        } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {
          child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];
        } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {
          var childHeight = child.layout[dim[crossAxis]];
          child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;
        } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {
          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
        }
      }
      currentLead += lineHeight;
    }
  }
  var needsMainTrailingPos = false;
  var needsCrossTrailingPos = false;
  if (!isMainDimDefined) {
    node.layout[dim[mainAxis]] = fmaxf(
      // We're missing the last padding at this point to get the final
      // dimension
      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),
      // We can never assign a width smaller than the padding and borders
      paddingAndBorderAxisMain
    );
    if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsMainTrailingPos = true;
    }
  }
  if (!isCrossDimDefined) {
    node.layout[dim[crossAxis]] = fmaxf(
      // For the cross dim, we add both sides at the end because the value
      // is aggregate via a max function. Intermediate negative values
      // can mess this computation otherwise
      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),
      paddingAndBorderAxisCross
    );
    if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsCrossTrailingPos = true;
    }
  }
  if (needsMainTrailingPos || needsCrossTrailingPos) {
    for (i = 0; i < childCount; ++i) {
      child = node.children[i];
      if (needsMainTrailingPos) {
        setTrailingPosition(node, child, mainAxis);
      }
      if (needsCrossTrailingPos) {
        setTrailingPosition(node, child, crossAxis);
      }
    }
  }
  currentAbsoluteChild = firstAbsoluteChild;
  while (currentAbsoluteChild !== null) {
    for (ii = 0; ii < 2; ii++) {
      axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
      if (!isUndefined2(node.layout[dim[axis]]) && !isDimDefined(currentAbsoluteChild, axis) && isPosDefined(currentAbsoluteChild, leading[axis]) && isPosDefined(currentAbsoluteChild, trailing[axis])) {
        currentAbsoluteChild.layout[dim[axis]] = fmaxf(
          boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis])),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(currentAbsoluteChild, axis)
        );
      }
      if (isPosDefined(currentAbsoluteChild, trailing[axis]) && !isPosDefined(currentAbsoluteChild, leading[axis])) {
        currentAbsoluteChild.layout[leading[axis]] = node.layout[dim[axis]] - currentAbsoluteChild.layout[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]);
      }
    }
    child = currentAbsoluteChild;
    currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;
    child.nextAbsoluteChild = null;
  }
}
function saveMargin(node) {
  var style = node.style;
  var margin = {};
  [
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft"
    // marginLeft
  ].forEach(function(key) {
    var value = style[key];
    if (value && /^-?\d+%$/.test(value)) {
      margin[key] = value;
      style[key] = 0;
    }
  });
  node.margin = margin;
}
function percent2Num(value) {
  var percent2 = Number(value.substr(0, value.length - 1));
  return percent2 / 100;
}
function layoutMargin(node) {
  var margin = node.margin, layout = node.layout;
  Object.keys(margin).forEach(function(key) {
    var percent2 = percent2Num(margin[key]);
    if ((key === "marginLeft" || key === "marginRight") && layout.width) {
      layout.left += layout.width * percent2;
    } else if ((key === "marginTop" || key === "marginBottom") && layout.height) {
      layout.top += layout.height * percent2;
    }
  });
}
function layoutNode(node, parentMaxWidth, parentDirection) {
  node.shouldUpdate = true;
  saveMargin(node);
  var direction = node.style.direction || CSS_DIRECTION_LTR;
  var skipLayout = !node.isDirty && node.lastLayout && node.lastLayout.requestedHeight === node.layout.height && node.lastLayout.requestedWidth === node.layout.width && node.lastLayout.parentMaxWidth === parentMaxWidth && node.lastLayout.direction === direction;
  if (skipLayout) {
    node.layout.width = node.lastLayout.width;
    node.layout.height = node.lastLayout.height;
    node.layout.top = node.lastLayout.top;
    node.layout.left = node.lastLayout.left;
  } else {
    if (!node.lastLayout) {
      node.lastLayout = {};
    }
    node.lastLayout.requestedWidth = node.layout.width;
    node.lastLayout.requestedHeight = node.layout.height;
    node.lastLayout.parentMaxWidth = parentMaxWidth;
    node.lastLayout.direction = direction;
    node.children.forEach(function(child) {
      child.layout.width = void 0;
      child.layout.height = void 0;
      child.layout.top = 0;
      child.layout.left = 0;
    });
    layoutNodeImpl(node, parentMaxWidth, parentDirection);
    node.lastLayout.width = node.layout.width;
    node.lastLayout.height = node.layout.height;
    node.lastLayout.top = node.layout.top;
    node.lastLayout.left = node.layout.left;
  }
  layoutMargin(node);
}
function computeLayout(node) {
  if (!node)
    return node;
  fillNodes(node);
  layoutNode(node, null, null);
  return node;
}
var css_layout_default = computeLayout;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/computeLayout.js
function createMeasure(style, measureText2) {
  return function() {
    var text = style.text, width = style.width, height = style.height;
    var outputWidth = width;
    var outputHeight = height;
    if (!is_number_default(width) || !is_number_default(height)) {
      var _a = measureText2(text, style), measureWidth = _a.width, measureHeight = _a.height;
      if (!is_number_default(width)) {
        outputWidth = measureWidth;
      }
      if (!is_number_default(height)) {
        outputHeight = measureHeight;
      }
    }
    return {
      width: outputWidth,
      height: outputHeight
    };
  };
}
function getChildrenLayout(nodeTree) {
  if (!nodeTree)
    return;
  var left = 0;
  var top = 0;
  var right = 0;
  var bottom = 0;
  var width = 0;
  var height = 0;
  nodeTree.forEach(function(node) {
    var layout = node.layout;
    if (!layout)
      return;
    left = Math.min(left, layout.left);
    top = Math.min(top, layout.top);
    right = Math.min(right, layout.left + layout.width);
    bottom = Math.min(bottom, layout.top + layout.height);
    width = Math.max(width, layout.width);
    height = Math.max(height, layout.height);
  });
  return {
    left,
    top,
    right,
    bottom,
    width,
    height
  };
}
var NodeTree = (
  /** @class */
  function() {
    function NodeTree2(node) {
      var className = node.className, children = node.children, layout = node.layout;
      var nodeChildren = children && children.length ? children.map(function(child) {
        return new NodeTree2(child);
      }) : void 0;
      var nodeLayout = layout ? layout : getChildrenLayout(nodeChildren);
      this.children = nodeChildren;
      this.layout = nodeLayout;
      this.className = className;
    }
    NodeTree2.prototype.getElementsByClassName = function(targetClassName) {
      var result = [];
      var _a = this, className = _a.className, children = _a.children;
      if (className === targetClassName) {
        result.push(this);
      }
      if (children) {
        children.forEach(function(child) {
          result.push.apply(result, child.getElementsByClassName(targetClassName));
        });
      }
      return result;
    };
    return NodeTree2;
  }()
);
function extendMap(arr, fn) {
  if (!arr) {
    return arr;
  }
  var newArray = [];
  if (!is_array_default(arr)) {
    var rst = fn(arr);
    if (!rst) {
      return newArray;
    }
    if (is_array_default(rst)) {
      newArray = newArray.concat(rst);
    } else {
      newArray.push(rst);
    }
    return newArray;
  }
  for (var i = 0; i < arr.length; i++) {
    var element = arr[i];
    if (is_array_default(element)) {
      newArray = newArray.concat(extendMap(element, fn));
    } else if (element) {
      var rst = fn(element);
      if (!rst) {
        continue;
      }
      if (is_array_default(rst)) {
        newArray = newArray.concat(rst);
      } else {
        newArray.push(rst);
      }
    }
  }
  return newArray;
}
function createChildNodeTree(parent, vNodeChildren) {
  var tag = parent.tag;
  var children = extendMap(vNodeChildren, function(child) {
    var childTag = child.tag, childStyle = child.style, childChildren = child.children;
    if (tag !== Shape2 && childTag === Shape2 && childStyle.display !== "flex") {
      return null;
    }
    if (childTag !== Shape2) {
      return createChildNodeTree(child, childChildren);
    }
    return createNodeTree(child);
  });
  return children;
}
function createNodeTree(vNode) {
  var tag = vNode.tag, type = vNode.type, style = vNode.style, context = vNode.context, vNodeChildren = vNode.children;
  var measureText2 = context.measureText;
  var children = createChildNodeTree(vNode, vNodeChildren);
  if (type === "text") {
    style.measure = createMeasure(style, measureText2);
  }
  return {
    tag,
    type,
    style,
    children,
    //  vNode 
    vNode
  };
}
function fillElementLayout(node) {
  var type = node.type, style = node.style, vNode = node.vNode, children = node.children, layout = node.layout;
  var attrs = shape_default(type, layout);
  if (style.measure) {
    delete style.measure;
  }
  vNode.layout = layout;
  vNode.style = __assign(__assign({}, attrs), style);
  if (!children || !children.length) {
    return;
  }
  for (var i = 0, len5 = children.length; i < len5; i++) {
    var child = children[i];
    fillElementLayout(child);
  }
}
function fillComponentLayout(vNode) {
  var layout = vNode.layout, vNodeChildren = vNode.children;
  children_default.map(vNodeChildren, function(child) {
    if (!child) {
      return;
    }
    var childTag = child.tag, childLayout = child.layout, style = child.style;
    if (childTag !== Shape2 && layout && !childLayout) {
      child.layout = layout;
      child.style = __assign({
        width: layout.width,
        height: layout.height
      }, style);
    }
    fillComponentLayout(child);
  });
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/index.js
function pickElement(element) {
  if (!element)
    return element;
  return children_default.map(element, function(item) {
    if (!item)
      return item;
    return pick_default(item, ["key", "ref", "type", "props"]);
  });
}
function getStyle2(tagType, props, context) {
  var _a = props.style, customStyle = _a === void 0 ? {} : _a, attrs = props.attrs, zIndex = props.zIndex;
  if (tagType === Shape2) {
    return context.px2hd(__assign(__assign({}, customStyle), attrs));
  }
  if (is_number_default(zIndex)) {
    return {
      zIndex
    };
  }
  return {};
}
function createVNode(parent, vNode) {
  var canvas = parent.canvas, context = parent.context, updater = parent.updater, parentAnimate = parent.animate;
  var ref = vNode.ref, type = vNode.type, originProps = vNode.props;
  var animate = originProps.animate, transformFrom = originProps.transformFrom, props = __rest(originProps, ["animate", "transformFrom"]);
  var tag = getWorkTag(type);
  var animator = new animator_default();
  var style = getStyle2(tag, props, context);
  vNode.parent = parent;
  vNode.tag = tag;
  vNode.style = style;
  vNode.context = context;
  vNode.updater = updater;
  vNode.canvas = canvas;
  vNode.animate = is_boolean_default(animate) ? animate : parentAnimate;
  vNode.animator = animator;
  if (tag === Shape2) {
    var shape = createShape(type, __assign(__assign({}, props), {
      style
    }));
    if (ref) {
      ref.current = shape;
    }
    shape._vNode = vNode;
    vNode.shape = shape;
  } else {
    var component = void 0;
    if (tag === ClassComponent) {
      component = new type(props, context, updater);
    } else {
      component = new component_default(props, context, updater);
      component.render = function() {
        return type(this.props, context, updater);
      };
    }
    var group = new Group();
    component.container = group;
    if (ref) {
      ref.current = component;
    }
    component.context = context;
    component.updater = updater;
    component.animator = animator;
    component._vNode = vNode;
    vNode.shape = group;
    vNode.component = component;
  }
  if (transformFrom && transformFrom.current) {
    var transformVNode = transformFrom.current._vNode;
    vNode.transform = findClosestShapeNode_default(transformVNode);
    if (vNode.transform) {
      vNode.transform.parent.children = null;
    }
  }
  return vNode;
}
function updateVNode(parent, nextNode, lastNode) {
  var canvas = parent.canvas, context = parent.context, updater = parent.updater, parentAnimate = parent.animate;
  var tag = lastNode.tag, animator = lastNode.animator, component = lastNode.component, shape = lastNode.shape, children = lastNode.children;
  var props = nextNode.props;
  var animate = props.animate;
  nextNode.parent = parent;
  nextNode.tag = tag;
  nextNode.canvas = canvas;
  nextNode.context = context;
  nextNode.updater = updater;
  nextNode.component = component;
  nextNode.shape = shape;
  nextNode.parent = parent;
  nextNode.children = children;
  nextNode.animate = is_boolean_default(animate) ? animate : parentAnimate;
  nextNode.animator = animator;
  nextNode.style = getStyle2(tag, props, context);
  if (component) {
    component._vNode = nextNode;
  } else {
    shape._vNode = nextNode;
  }
  return nextNode;
}
function createElement(parent, element) {
  return children_default.map(element, function(el) {
    if (!el)
      return el;
    return createVNode(parent, el);
  });
}
function destroyElement(vNode) {
  children_default.map(vNode, function(node) {
    if (!node)
      return;
    var component = node.component, children = node.children;
    if (component) {
      component.willUnmount();
      destroyElement(children);
      component.didUnmount();
      component.destroy();
    }
  });
}
function updateElement(parent, nextElement, lastElement) {
  var nextType = nextElement.type, nextProps = nextElement.props;
  var lastType = lastElement.type, lastProps = lastElement.props;
  if (nextType === lastType) {
    var nextVNode_1 = updateVNode(parent, nextElement, lastElement);
    if (equal_default(nextProps, lastProps) && parent.context === lastElement.context) {
      return null;
    }
    return nextVNode_1;
  }
  var nextVNode = createVNode(parent, nextElement);
  destroyElement(lastElement);
  return nextVNode;
}
function diffElement(parent, nextElement, lastElement) {
  if (!nextElement && !lastElement) {
    return null;
  }
  if (!nextElement && lastElement) {
    destroyElement(lastElement);
    return null;
  }
  if (nextElement && !lastElement) {
    return createElement(parent, nextElement);
  }
  return updateElement(parent, nextElement, lastElement);
}
function renderComponentNodes(componentNodes) {
  if (!componentNodes || !componentNodes.length) {
    return;
  }
  var shouldProcessChildren = componentNodes.filter(function(node) {
    var component = node.component, props = node.props, context = node.context, layout = node.layout;
    component.layout = layout;
    if (!component.isMounted)
      return true;
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    component.willReceiveProps(props, context);
    component.props = props;
    component.context = context;
    return true;
  });
  if (!shouldProcessChildren.length) {
    return;
  }
  shouldProcessChildren.forEach(function(child) {
    var component = child.component;
    if (!component.isMounted) {
      component.willMount();
    } else {
      component.willUpdate();
    }
  });
  shouldProcessChildren.forEach(function(child) {
    var canvas = child.canvas, component = child.component, children = child.children;
    var newChildren = canvas.toRawChildren(component.render());
    renderChildren(child, newChildren, children);
    if (!component.isMounted) {
      component.didMount();
      component.isMounted = true;
    } else {
      component.didUpdate();
    }
  });
}
function renderVNode(node, nextChildren, lastChildren) {
  var component = node.component;
  var newChildren = pickElement(nextChildren);
  node.children = newChildren;
  if (component) {
    component.children = newChildren;
  }
  var componentNodeChildren = [];
  children_default.compare(newChildren, lastChildren, function(next, last2) {
    var element = diffElement(node, next, last2);
    children_default.map(element, function(child) {
      if (!child)
        return;
      var tag = child.tag, childProps = child.props, childLastChildren = child.children;
      var childrenNode = [];
      if (tag === Shape2) {
        childrenNode = renderVNode(child, childProps.children, childLastChildren);
      } else {
        childrenNode = [child];
      }
      componentNodeChildren = componentNodeChildren.concat(childrenNode);
    });
  });
  return componentNodeChildren;
}
function renderChildren(parent, nextChildren, lastChildren) {
  var componentNodeChildren = renderVNode(parent, nextChildren, lastChildren);
  var nodeTree = createNodeTree(parent);
  css_layout_default(nodeTree);
  fillElementLayout(nodeTree);
  fillComponentLayout(parent);
  var newChildren = parent.children;
  if (!componentNodeChildren.length) {
    return newChildren;
  }
  renderComponentNodes(componentNodeChildren);
  return newChildren;
}
function render(vNode) {
  var lastChildren = vNode.children, props = vNode.props;
  var nextChildren = props.children;
  var children = renderChildren(vNode, nextChildren, lastChildren);
  var childrenAnimation = createAnimation(vNode, children, lastChildren);
  if (childrenAnimation.length) {
    childrenAnimation.forEach(function(animator) {
      animator.loadPlay();
    });
  }
}
function updateComponents(components) {
  if (!components.length)
    return;
  components.forEach(function(component) {
    var vNode = component._vNode, lastChildren = component.children, props = component.props, animator = component.animator;
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    component.willUpdate();
    var canvas = vNode.canvas;
    var newChildren = canvas.toRawChildren(component.render());
    var nextChildren = renderChildren(vNode, newChildren, lastChildren);
    component.children = nextChildren;
    vNode.children = nextChildren;
    var childrenAnimation = createAnimation(vNode, nextChildren, lastChildren);
    if (childrenAnimation && childrenAnimation.length) {
      animator.children = childrenAnimation;
    }
    animator.loadPlay();
    component.didUpdate();
  });
}

// node_modules/.pnpm/@antv+g-plugin-canvas-path-generator@1.1.44_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function generatePath(context, parsedStyle) {
  var r = parsedStyle.r;
  context.arc(r, r, r, 0, Math.PI * 2, false);
}
function generatePath$1(context, parsedStyle) {
  var rxInPixels = parsedStyle.rx, ryInPixels = parsedStyle.ry;
  var rx = rxInPixels;
  var ry = ryInPixels;
  if (context.ellipse) {
    context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r = rx > ry ? rx : ry;
    var scaleX = rx > ry ? 1 : rx / ry;
    var scaleY = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX, scaleY);
    context.arc(0, 0, r, 0, Math.PI * 2);
  }
}
function generatePath$2(context, parsedStyle) {
  var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = x2 - x1;
    y = y2 - y1;
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = x1 - x2;
    y = y1 - y2;
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 - defX + startOffsetX, y1 - defY + startOffsetY);
  context.lineTo(x2 - defX + endOffsetX, y2 - defY + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$path = parsedStyle.path, absolutePath = _parsedStyle$path.absolutePath, segments = _parsedStyle$path.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _markerStart$parentNo = markerStart.parentNode.getStartTangent(), p1 = _markerStart$parentNo[0], p2 = _markerStart$parentNo[1];
    x = p1[0] - p2[0];
    y = p1[1] - p2[1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _markerEnd$parentNode = markerEnd.parentNode.getEndTangent(), _p = _markerEnd$parentNode[0], _p2 = _markerEnd$parentNode[1];
    x = _p[0] - _p2[0];
    y = _p[1] - _p2[1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  for (var i = 0; i < absolutePath.length; i++) {
    var params = absolutePath[i];
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    switch (command) {
      case "M":
        if (useStartOffset) {
          context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);
          context.lineTo(params[1] - defX, params[2] - defY);
        } else {
          context.moveTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "L":
        if (useEndOffset) {
          context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);
        } else {
          context.lineTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "Q":
        context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);
        if (useEndOffset) {
          context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);
        }
        break;
      case "C":
        context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);
        if (useEndOffset) {
          context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);
        }
        break;
      case "A": {
        var arcParams = segments[i].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx - defX, cy - defY);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-(cx - defX), -(cy - defY));
        }
        if (useEndOffset) {
          context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$4(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length14 = points.length;
  var x1 = points[0][0] - defX;
  var y1 = points[0][1] - defY;
  var x2 = points[length14 - 1][0] - defX;
  var y2 = points[length14 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = points[1][0] - points[0][0];
    y = points[1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = points[length14 - 1][0] - points[0][0];
    y = points[length14 - 1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
  for (var i = 1; i < length14 - 1; i++) {
    var point = points[i];
    context.lineTo(point[0] - defX, point[1] - defY);
  }
  context.lineTo(x2, y2);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length14 = points.length;
  var x1 = points[0][0] - defX;
  var y1 = points[0][1] - defY;
  var x2 = points[length14 - 1][0] - defX;
  var y2 = points[length14 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = points[1][0] - points[0][0];
    y = points[1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = points[length14 - 2][0] - points[length14 - 1][0];
    y = points[length14 - 2][1] - points[length14 - 1][1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  for (var i = 1; i < length14 - 1; i++) {
    var point = points[i];
    context.lineTo(point[0] - defX, point[1] - defY);
  }
  context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}
function generatePath$6(context, parsedStyle) {
  var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w = width;
  var h2 = height;
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  if (!hasRadius) {
    context.rect(0, 0, w, h2);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r) {
      return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h2) / 2));
    }), tlr = _radius$map[0], trr = _radius$map[1], brr = _radius$map[2], blr = _radius$map[3];
    context.moveTo(signX * tlr, 0);
    context.lineTo(w - signX * trr, 0);
    if (trr !== 0) {
      context.arc(w - signX * trr, signY * trr, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w, h2 - signY * brr);
    if (brr !== 0) {
      context.arc(w - signX * brr, h2 - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr, h2);
    if (blr !== 0) {
      context.arc(signX * blr, h2 - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(0, signY * tlr);
    if (tlr !== 0) {
      context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = function(_AbstractRendererPlug) {
  _inheritsLoose3(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _pathGeneratorFactory;
    var pathGeneratorFactory = (_pathGeneratorFactory = {}, _pathGeneratorFactory[Shape.CIRCLE] = generatePath, _pathGeneratorFactory[Shape.ELLIPSE] = generatePath$1, _pathGeneratorFactory[Shape.RECT] = generatePath$6, _pathGeneratorFactory[Shape.LINE] = generatePath$2, _pathGeneratorFactory[Shape.POLYLINE] = generatePath$5, _pathGeneratorFactory[Shape.POLYGON] = generatePath$4, _pathGeneratorFactory[Shape.PATH] = generatePath$3, _pathGeneratorFactory[Shape.TEXT] = void 0, _pathGeneratorFactory[Shape.GROUP] = void 0, _pathGeneratorFactory[Shape.IMAGE] = void 0, _pathGeneratorFactory[Shape.HTML] = void 0, _pathGeneratorFactory[Shape.MESH] = void 0, _pathGeneratorFactory);
    this.context.pathGeneratorFactory = pathGeneratorFactory;
  };
  _proto.destroy = function destroy() {
    delete this.context.pathGeneratorFactory;
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-canvas-picker@1.8.42_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
function _regeneratorRuntime2() {
  _regeneratorRuntime2 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i = 0, arr2 = new Array(len5); i < len5; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat42 = mat4_exports.create();
var CanvasPickerPlugin = function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    this.canvasConfig = void 0;
    this.pathGeneratorFactory = void 0;
    this.pointInPathPickerFactory = void 0;
    this.isHit = function(displayObject, position, worldTransform, isClipPath, runtime2) {
      var pick = _this2.pointInPathPickerFactory[displayObject.nodeName];
      if (pick) {
        var invertWorldMat = mat4_exports.invert(tmpMat42, worldTransform);
        var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
        var _displayObject$getGeo = displayObject.getGeometryBounds(), halfExtents = _displayObject$getGeo.halfExtents;
        var anchor = displayObject.parsedStyle.anchor;
        localPosition[0] += (anchor && anchor[0] || 0) * halfExtents[0] * 2;
        localPosition[1] += (anchor && anchor[1] || 0) * halfExtents[1] * 2;
        if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, runtime2)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(runtime2, displayObject, position) {
      var context = runtime2.offscreenCanvas.getOrCreateContext(_this2.canvasConfig.offscreenCanvas);
      var generatePath2 = _this2.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position.x, position.y);
    };
  }
  var _proto = CanvasPickerPlugin2.prototype;
  _proto.apply = function apply(context, runtime2) {
    var _renderingContext$roo, _this2 = this;
    var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, pathGeneratorFactory = context.pathGeneratorFactory, pointInPathPickerFactory = context.pointInPathPickerFactory;
    this.canvasConfig = config;
    this.pathGeneratorFactory = pathGeneratorFactory;
    this.pointInPathPickerFactory = pointInPathPickerFactory;
    var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
    renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function() {
      var _ref = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(result) {
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document2, result, runtime2));
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }());
    renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
      return _this2.pick(document2, result, runtime2);
    });
  };
  _proto.pick = function pick(document2, result, runtime2) {
    var topmost = result.topmost, _result$position = result.position, x = _result$position.x, y = _result$position.y;
    var position = vec3_exports.set(tmpVec3a, x, y, 0);
    var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
    var pickedDisplayObjects = [];
    for (var _iterator = _createForOfIteratorHelperLoose2(hitTestList), _step; !(_step = _iterator()).done; ) {
      var displayObject = _step.value;
      var worldTransform = displayObject.getWorldTransform();
      var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false, runtime2);
      if (isHitOriginShape) {
        var clipped = findClosestClipPathTarget(displayObject);
        if (clipped) {
          var clipPath = clipped.parsedStyle.clipPath;
          var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true, runtime2);
          if (isHitClipPath) {
            if (topmost) {
              result.picked = [displayObject];
              return result;
            } else {
              pickedDisplayObjects.push(displayObject);
            }
          }
        } else {
          if (topmost) {
            result.picked = [displayObject];
            return result;
          } else {
            pickedDisplayObjects.push(displayObject);
          }
        }
      }
    }
    result.picked = pickedDisplayObjects;
    return result;
  };
  return CanvasPickerPlugin2;
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function distance5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual3(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray2(xArr, yArr) {
  var minX = Math.min.apply(Math, xArr);
  var minY = Math.min.apply(Math, yArr);
  var maxX = Math.max.apply(Math, xArr);
  var maxY = Math.max.apply(Math, yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function piMod2(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
var line2 = {
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {object} 
   */
  box: function box7(x1, y1, x2, y2) {
    return getBBoxByArray2([x1, x2], [y1, y2]);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  length: function length11(x1, y1, x2, y2) {
    return distance5(x1, y1, x2, y2);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} t 
   * @return {object}  x, y 
   */
  pointAt: function pointAt7(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointDistance: function pointDistance7(x1, y1, x2, y2, x, y) {
    var cross4 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross4 < 0) {
      return distance5(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross4 > lengthSquare) {
      return distance5(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointToLine: function pointToLine2(x1, y1, x2, y2, x, y) {
    var d4 = [x2 - x1, y2 - y1];
    if (vec2_exports.exactEquals(d4, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d4[1], d4[0]];
    vec2_exports.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2_exports.dot(a, u));
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  tangentAngle: function tangentAngle7(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON3 = 1e-4;
function nearestPoint4(xArr, yArr, x, y, tCallback, length14) {
  var t = -1;
  var d4 = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length14 && length14 > 200) {
    segNum = length14 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
    var d1 = distance5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d4) {
      t = _t;
      d4 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d4 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval < EPSILON3) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
    var _d = distance5(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d4) {
      t = prev;
      d4 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
      var d22 = distance5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d4) {
        t = next;
        d4 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, xArr.concat([t])),
    y: tCallback.apply(void 0, yArr.concat([t]))
  };
}
function snapLength2(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance5(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt2(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema2(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual3(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt2(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic2(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt2(x1, x2, x3, t);
  var yt = quadraticAt2(y1, y2, y3, t);
  var controlPoint1 = line2.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line2.pointAt(x2, y2, x3, y3, t);
  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
}
function quadraticLength2(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance5(x1, y1, x2, y2) + distance5(x2, y2, x3, y3) + distance5(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic2(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength2.apply(void 0, left) + quadraticLength2.apply(void 0, right);
}
var quadratic2 = {
  box: function box8(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema2(x1, x2, x3)[0];
    var yExtrema2 = extrema2(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt2(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt2(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray2(xArr, yArr);
  },
  length: function length12(x1, y1, x2, y2, x3, y3) {
    return quadraticLength2(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function nearestPoint$13(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint4([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt2);
  },
  pointDistance: function pointDistance8(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance5(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt2,
  pointAt: function pointAt8(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt2(x1, x2, x3, t),
      y: quadraticAt2(y1, y2, y3, t)
    };
  },
  divide: function divide6(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic2(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function tangentAngle8(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt2(x1, x2, x3, t);
    var dy = derivativeAt2(y1, y2, y3, t);
    var angle3 = Math.atan2(dy, dx);
    return piMod2(angle3);
  }
};
function cubicAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt$12(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema$12(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual3(a, 0)) {
    if (!isNumberEqual3(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual3(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt2(x1, x2, x3, x4, t);
  var yt = cubicAt2(y1, y2, y3, y4, t);
  var c1 = line2.pointAt(x1, y1, x2, y2, t);
  var c2 = line2.pointAt(x2, y2, x3, y3, t);
  var c3 = line2.pointAt(x3, y3, x4, y4, t);
  var c12 = line2.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line2.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
}
function cubicLength2(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength2([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = [].concat(cubics[0], [iterationCount - 1]);
  var right = [].concat(cubics[1], [iterationCount - 1]);
  return cubicLength2.apply(void 0, left) + cubicLength2.apply(void 0, right);
}
var cubic2 = {
  extrema: extrema$12,
  box: function box9(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema$12(x1, x2, x3, x4);
    var yExtrema2 = extrema$12(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt2(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var _i = 0; _i < yExtrema2.length; _i++) {
      yArr.push(cubicAt2(y1, y2, y3, y4, yExtrema2[_i]));
    }
    return getBBoxByArray2(xArr, yArr);
  },
  length: function length13(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength2(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function nearestPoint$14(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    return nearestPoint4([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt2, length14);
  },
  pointDistance: function pointDistance9(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14);
    return distance5(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt2,
  pointAt: function pointAt9(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt2(x1, x2, x3, x4, t),
      y: cubicAt2(y1, y2, y3, y4, t)
    };
  },
  divide: function divide7(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function tangentAngle9(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt$12(x1, x2, x3, x4, t);
    var dy = derivativeAt$12(y1, y2, y3, y4, t);
    return piMod2(Math.atan2(dy, dx));
  }
};
function distance$1(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}
function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle3 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  var point = {
    x: cx + r * Math.cos(angle3),
    y: cy + r * Math.sin(angle3)
  };
  return distance$1(point.x, point.y, x, y) <= lineWidth / 2;
}
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  return line2.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = inPolygon(points, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, r = _displayObject$parsed.r, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, pointerEvents = _displayObject$parsed.pointerEvents;
  var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var absDistance = distance$1(r, r, position.x, position.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r;
  }
  if (hasStroke) {
    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$1(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, rx = _displayObject$parsed.rx, ry = _displayObject$parsed.ry, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, pointerEvents = _displayObject$parsed.pointerEvents;
  var x = position.x, y = position.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var squareX = (x - rx) * (x - rx);
  var squareY = (y - ry) * (y - ry);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function isPointInPath$2(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, x1 = _displayObject$parsed.x1, y1 = _displayObject$parsed.y1, x2 = _displayObject$parsed.x2, y2 = _displayObject$parsed.y2, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasStroke = _isFillOrStrokeAffect[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x1, y1, x2, y2, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y);
}
function isPointInStroke2(segments, lineWidth, px2, py, length14) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box10 = segment.box;
    if (box10 && !inBox(box10.x - halfWidth, box10.y - halfWidth, box10.width + lineWidth, box10.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = quadratic2.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = cubic2.pointDistance(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length14
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = cubic2.pointDistance(
            prePointInCubic[0],
            // ,  C 
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length14
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _displayObject$parsed = displayObject.parsedStyle, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, stroke = _displayObject$parsed.stroke, fill = _displayObject$parsed.fill, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, path = _displayObject$parsed.path, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var segments = path.segments, hasArc = path.hasArc, polylines = path.polylines, polygons = path.polygons;
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(runtime2, displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);
    }
    return isHit;
  } else if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, stroke = _displayObject$parsed.stroke, fill = _displayObject$parsed.fill, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, points = _displayObject$parsed.points, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x + x, position.y + y);
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, points = _displayObject$parsed.points, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasStroke = _isFillOrStrokeAffect[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, false);
}
function isPointInPath$6(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _displayObject$parsed = displayObject.parsedStyle, radius = _displayObject$parsed.radius, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, width = _displayObject$parsed.width, height = _displayObject$parsed.height, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(0, 0, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(0, 0, width, height, radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(runtime2, displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {
  var tlr = radiusArray[0], trr = radiusArray[1], brr = radiusArray[2], blr = radiusArray[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}
var Plugin2 = function(_AbstractRendererPlug) {
  _inheritsLoose4(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "canvas-picker";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _pointInPathPickerFac;
    var trueFunc = function trueFunc2() {
      return true;
    };
    var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _pointInPathPickerFac[Shape.CIRCLE] = isPointInPath, _pointInPathPickerFac[Shape.ELLIPSE] = isPointInPath$1, _pointInPathPickerFac[Shape.RECT] = isPointInPath$6, _pointInPathPickerFac[Shape.LINE] = isPointInPath$2, _pointInPathPickerFac[Shape.POLYLINE] = isPointInPath$5, _pointInPathPickerFac[Shape.POLYGON] = isPointInPath$4, _pointInPathPickerFac[Shape.PATH] = isPointInPath$3, _pointInPathPickerFac[Shape.TEXT] = trueFunc, _pointInPathPickerFac[Shape.GROUP] = null, _pointInPathPickerFac[Shape.IMAGE] = trueFunc, _pointInPathPickerFac[Shape.HTML] = null, _pointInPathPickerFac[Shape.MESH] = null, _pointInPathPickerFac);
    this.context.pointInPathPickerFactory = pointInPathPickerFactory;
    this.addRenderingPlugin(new CanvasPickerPlugin());
  };
  _proto.destroy = function destroy() {
    delete this.context.pointInPathPickerFactory;
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-canvas-renderer@1.7.47_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
function _regeneratorRuntime3() {
  _regeneratorRuntime3 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep3(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator3(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf5(subClass, superClass);
}
function _setPrototypeOf5(o, p) {
  _setPrototypeOf5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf5(o, p);
}
var CanvasRendererPlugin = function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    this.canvasRendererPluginOptions = void 0;
    this.context = void 0;
    this.pathGeneratorFactory = void 0;
    this.rBush = void 0;
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    this.restoreStack = [];
    this.clearFullScreen = false;
    this.vpMatrix = mat4_exports.create();
    this.dprMatrix = mat4_exports.create();
    this.tmpMat4 = mat4_exports.create();
    this.vec3a = vec3_exports.create();
    this.vec3b = vec3_exports.create();
    this.vec3c = vec3_exports.create();
    this.vec3d = vec3_exports.create();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  var _proto = CanvasRendererPlugin2.prototype;
  _proto.apply = function apply(context, runtime2) {
    var _this2 = this;
    this.context = context;
    var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, pathGeneratorFactory = context.pathGeneratorFactory;
    this.rBush = rBushRoot;
    this.pathGeneratorFactory = pathGeneratorFactory;
    var contextService = context.contextService;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    var handleUnmounted = function handleUnmounted2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
      }
    };
    var handleCulled = function handleCulled2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
      }
    };
    renderingService.hooks.init.tapPromise(CanvasRendererPlugin2.tag, _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee() {
      var dpr, width, height, context2;
      return _regeneratorRuntime3().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.CULLED, handleCulled);
              dpr = contextService.getDPR();
              width = config.width, height = config.height;
              context2 = contextService.getContext();
              _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
      canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
    });
    renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
      var context2 = contextService.getContext();
      var dpr = contextService.getDPR();
      var width = config.width, height = config.height;
      var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
      var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
      var ratio = rendered / total;
      _this2.clearFullScreen = renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
      if (context2) {
        context2.resetTransform();
        if (_this2.clearFullScreen) {
          _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
        }
      }
    });
    var renderByZIndex = function renderByZIndex2(object, context2) {
      if (object.isVisible() && !object.isCulled()) {
        _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
        _this2.saveDirtyAABB(object);
      }
      var sorted = object.sortable.sorted || object.childNodes;
      sorted.forEach(function(child) {
        renderByZIndex2(child, context2);
      });
    };
    renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
      var context2 = contextService.getContext();
      var dpr = contextService.getDPR();
      mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
      mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
      if (_this2.clearFullScreen) {
        renderByZIndex(renderingContext.root, context2);
      } else {
        var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_this2.removedRBushNodeAABBs.map(function(_ref2) {
          var minX = _ref2.minX, minY = _ref2.minY, maxX = _ref2.maxX, maxY = _ref2.maxY;
          var aabb = new AABB();
          aabb.setMinMax(
            // vec3.fromValues(minX, minY, 0),
            // vec3.fromValues(maxX, maxY, 0),
            [minX, minY, 0],
            [maxX, maxY, 0]
          );
          return aabb;
        })));
        _this2.removedRBushNodeAABBs = [];
        if (AABB.isEmpty(dirtyRenderBounds)) {
          _this2.renderQueue = [];
          return;
        }
        var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
        var x = dirtyRect.x, y = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
        var tl = vec3_exports.transformMat4(_this2.vec3a, [x, y, 0], _this2.vpMatrix);
        var tr = vec3_exports.transformMat4(_this2.vec3b, [x + width, y, 0], _this2.vpMatrix);
        var bl = vec3_exports.transformMat4(_this2.vec3c, [x, y + height, 0], _this2.vpMatrix);
        var br = vec3_exports.transformMat4(_this2.vec3d, [x + width, y + height, 0], _this2.vpMatrix);
        var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
        var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
        var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
        var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
        var ix = Math.floor(minx);
        var iy = Math.floor(miny);
        var iwidth = Math.ceil(maxx - minx);
        var iheight = Math.ceil(maxy - miny);
        context2.save();
        _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
        context2.beginPath();
        context2.rect(ix, iy, iwidth, iheight);
        context2.clip();
        context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
        var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
        if (enableDirtyRectangleRenderingDebug) {
          canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
            dirtyRect: {
              x: ix,
              y: iy,
              width: iwidth,
              height: iheight
            }
          }));
        }
        var dirtyObjects = _this2.searchDirtyObjects(runtime2, dirtyRenderBounds);
        dirtyObjects.sort(function(a, b) {
          return a.sortable.renderOrder - b.sortable.renderOrder;
        }).forEach(function(object) {
          if (object && object.isVisible() && !object.isCulled()) {
            _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
          }
        });
        context2.restore();
        _this2.renderQueue.forEach(function(object) {
          _this2.saveDirtyAABB(object);
        });
        _this2.renderQueue = [];
      }
      _this2.restoreStack.forEach(function() {
        context2.restore();
      });
      _this2.restoreStack = [];
    });
    renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
      if (!_this2.clearFullScreen) {
        _this2.renderQueue.push(object);
      }
    });
  };
  _proto.clearRect = function clearRect(context, x, y, width, height, background) {
    context.clearRect(x, y, width, height);
    if (background) {
      context.fillStyle = background;
      context.fillRect(x, y, width, height);
    }
  };
  _proto.renderDisplayObject = function renderDisplayObject(object, context, canvasContext, restoreStack, runtime2) {
    var nodeName = object.nodeName;
    var parent = restoreStack[restoreStack.length - 1];
    if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
      context.restore();
      restoreStack.pop();
    }
    var styleRenderer = this.context.styleRendererFactory[nodeName];
    var generatePath2 = this.pathGeneratorFactory[nodeName];
    var clipPath = object.parsedStyle.clipPath;
    if (clipPath) {
      this.applyWorldTransform(context, clipPath);
      var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
      if (_generatePath) {
        context.save();
        restoreStack.push(object);
        context.beginPath();
        _generatePath(context, clipPath.parsedStyle);
        context.closePath();
        context.clip();
      }
    }
    if (styleRenderer) {
      this.applyWorldTransform(context, object);
      context.save();
      this.applyAttributesToContext(context, object);
    }
    if (generatePath2) {
      context.beginPath();
      generatePath2(context, object.parsedStyle);
      if (object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
        context.closePath();
      }
    }
    if (styleRenderer) {
      styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
      context.restore();
    }
    object.renderable.dirty = false;
  };
  _proto.convertAABB2Rect = function convertAABB2Rect(aabb) {
    var min4 = aabb.getMin();
    var max4 = aabb.getMax();
    var minX = Math.floor(min4[0]);
    var minY = Math.floor(min4[1]);
    var maxX = Math.ceil(max4[0]);
    var maxY = Math.ceil(max4[1]);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      x: minX,
      y: minY,
      width,
      height
    };
  };
  _proto.mergeDirtyAABBs = function mergeDirtyAABBs(dirtyObjects) {
    var aabb = new AABB();
    dirtyObjects.forEach(function(object) {
      var renderBounds = object.getRenderBounds();
      aabb.add(renderBounds);
      var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
      if (dirtyRenderBounds) {
        aabb.add(dirtyRenderBounds);
      }
    });
    return aabb;
  };
  _proto.searchDirtyObjects = function searchDirtyObjects(runtime2, dirtyRectangle) {
    var _dirtyRectangle$getMi = dirtyRectangle.getMin(), minX = _dirtyRectangle$getMi[0], minY = _dirtyRectangle$getMi[1];
    var _dirtyRectangle$getMa = dirtyRectangle.getMax(), maxX = _dirtyRectangle$getMa[0], maxY = _dirtyRectangle$getMa[1];
    var rBushNodes = this.rBush.search({
      minX,
      minY,
      maxX,
      maxY
    });
    return rBushNodes.map(function(_ref3) {
      var id2 = _ref3.id;
      return runtime2.displayObjectPool.getByEntity(id2);
    });
  };
  _proto.saveDirtyAABB = function saveDirtyAABB(object) {
    var renderable = object.renderable;
    if (!renderable.dirtyRenderBounds) {
      renderable.dirtyRenderBounds = new AABB();
    }
    var renderBounds = object.getRenderBounds();
    if (renderBounds) {
      renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
    }
  };
  _proto.applyAttributesToContext = function applyAttributesToContext(context, object) {
    var _object$parsedStyle = object.parsedStyle, stroke = _object$parsedStyle.stroke, fill = _object$parsedStyle.fill, opacity = _object$parsedStyle.opacity, lineDash = _object$parsedStyle.lineDash, lineDashOffset = _object$parsedStyle.lineDashOffset;
    if (lineDash) {
      context.setLineDash(lineDash);
    }
    if (!is_nil_default(lineDashOffset)) {
      context.lineDashOffset = lineDashOffset;
    }
    if (!is_nil_default(opacity)) {
      context.globalAlpha *= opacity;
    }
    if (!is_nil_default(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
      context.strokeStyle = object.attributes.stroke;
    }
    if (!is_nil_default(fill) && !Array.isArray(fill) && !fill.isNone) {
      context.fillStyle = object.attributes.fill;
    }
  };
  _proto.applyWorldTransform = function applyWorldTransform(context, object, matrix) {
    var tx = 0;
    var ty = 0;
    var _ref4 = object.parsedStyle || {}, anchor = _ref4.anchor;
    var anchorX = anchor && anchor[0] || 0;
    var anchorY = anchor && anchor[1] || 0;
    if (anchorX !== 0 || anchorY !== 0) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 0;
      var height = bounds && bounds.halfExtents[1] * 2 || 0;
      tx = -(anchorX * width);
      ty = -(anchorY * height);
    }
    if (matrix) {
      mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
      this.vec3a[0] = tx;
      this.vec3a[1] = ty;
      this.vec3a[2] = 0;
      mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
      mat4_exports.multiply(this.tmpMat4, matrix, this.tmpMat4);
      mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
    } else {
      mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
      this.vec3a[0] = tx;
      this.vec3a[1] = ty;
      this.vec3a[2] = 0;
      mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
      mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
    }
    context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
  };
  _proto.safeMergeAABB = function safeMergeAABB() {
    var merged = new AABB();
    for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
      aabbs[_key] = arguments[_key];
    }
    aabbs.forEach(function(aabb) {
      merged.add(aabb);
    });
    return merged;
  };
  return CanvasRendererPlugin2;
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
var DefaultRenderer = function() {
  function DefaultRenderer2(imagePool) {
    this.imagePool = void 0;
    this.imagePool = imagePool;
  }
  var _proto = DefaultRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, opacity = parsedStyle.opacity, fillOpacity = parsedStyle.fillOpacity, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity, lineWidth = parsedStyle.lineWidth, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
    var hasFill = !is_nil_default(fill) && !fill.isNone;
    var hasStroke = !is_nil_default(stroke) && !stroke.isNone && lineWidth > 0;
    var isFillTransparent = fill.alpha === 0;
    var hasFilter = !!(filter && filter.length);
    var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
    var nodeName = object.nodeName;
    var isInnerShadow = shadowType === "inner";
    var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
    if (hasFill) {
      context.globalAlpha = opacity * fillOpacity;
      if (!shouldDrawShadowWithStroke) {
        setShadowAndFilter(object, context, hasShadow);
      }
      this.fill(context, object, fill, fillRule, canvasContext, plugin, runtime2);
      if (!shouldDrawShadowWithStroke) {
        this.clearShadowAndFilter(context, hasFilter, hasShadow);
      }
    }
    if (hasStroke) {
      context.globalAlpha = opacity * strokeOpacity;
      context.lineWidth = lineWidth;
      if (!is_nil_default(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      if (!is_nil_default(lineCap)) {
        context.lineCap = lineCap;
      }
      if (!is_nil_default(lineJoin)) {
        context.lineJoin = lineJoin;
      }
      if (shouldDrawShadowWithStroke) {
        if (isInnerShadow) {
          context.globalCompositeOperation = "source-atop";
        }
        setShadowAndFilter(object, context, true);
        if (isInnerShadow) {
          this.stroke(context, object, stroke, canvasContext, plugin, runtime2);
          context.globalCompositeOperation = "source-over";
          this.clearShadowAndFilter(context, hasFilter, true);
        }
      }
      this.stroke(context, object, stroke, canvasContext, plugin, runtime2);
    }
  };
  _proto.clearShadowAndFilter = function clearShadowAndFilter(context, hasFilter, hasShadow) {
    if (hasShadow) {
      context.shadowColor = "transparent";
      context.shadowBlur = 0;
    }
    if (hasFilter) {
      var oldFilter = context.filter;
      if (!is_nil_default(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
        context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
      }
    }
  };
  _proto.fill = function fill(context, object, _fill, fillRule, canvasContext, plugin, runtime2) {
    var _this2 = this;
    if (Array.isArray(_fill)) {
      _fill.forEach(function(gradient2) {
        context.fillStyle = _this2.getColor(gradient2, object, context);
        context.fill(fillRule);
      });
    } else {
      if (isPattern(_fill)) {
        context.fillStyle = this.getPattern(_fill, object, context, canvasContext, plugin, runtime2);
      }
      context.fill(fillRule);
    }
  };
  _proto.stroke = function stroke(context, object, _stroke, canvasContext, plugin, runtime2) {
    var _this2 = this;
    if (Array.isArray(_stroke)) {
      _stroke.forEach(function(gradient2) {
        context.strokeStyle = _this2.getColor(gradient2, object, context);
        context.stroke();
      });
    } else {
      if (isPattern(_stroke)) {
        context.strokeStyle = this.getPattern(_stroke, object, context, canvasContext, plugin, runtime2);
      }
      context.stroke();
    }
  };
  _proto.getPattern = function getPattern(pattern, object, context, canvasContext, plugin, runtime2) {
    var $offscreenCanvas;
    var dpr;
    if (pattern.image.nodeName === "rect") {
      var _pattern$image$parsed = pattern.image.parsedStyle, width = _pattern$image$parsed.width, height = _pattern$image$parsed.height;
      dpr = canvasContext.contextService.getDPR();
      var offscreenCanvas = canvasContext.config.offscreenCanvas;
      $offscreenCanvas = runtime2.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
      $offscreenCanvas.width = width * dpr;
      $offscreenCanvas.height = height * dpr;
      var offscreenCanvasContext = runtime2.offscreenCanvas.getOrCreateContext(offscreenCanvas);
      var restoreStack = [];
      pattern.image.forEach(function(object2) {
        plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, restoreStack, runtime2);
      });
      restoreStack.forEach(function() {
        offscreenCanvasContext.restore();
      });
    }
    var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function() {
      object.renderable.dirty = true;
      canvasContext.renderingService.dirtify();
    });
    return canvasPattern;
  };
  _proto.getColor = function getColor(parsedColor, object, context) {
    var color2;
    if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 1;
      var height = bounds && bounds.halfExtents[1] * 2 || 1;
      color2 = this.imagePool.getOrCreateGradient(_extends2({
        type: parsedColor.type
      }, parsedColor.value, {
        width,
        height
      }), context);
    }
    return color2;
  };
  return DefaultRenderer2;
}();
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter && filter.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
var ImageRenderer = function() {
  function ImageRenderer2(imagePool) {
    this.imagePool = void 0;
    this.imagePool = imagePool;
  }
  var _proto = ImageRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object) {
    var width = parsedStyle.width, height = parsedStyle.height, img = parsedStyle.img, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
    var image;
    var iw = width;
    var ih = height;
    if (is_string_default(img)) {
      image = this.imagePool.getImageSync(img);
    } else {
      iw || (iw = img.width);
      ih || (ih = img.height);
      image = img;
    }
    if (image) {
      var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        context.drawImage(image, 0, 0, iw, ih);
      } catch (e2) {
      }
    }
  };
  return ImageRenderer2;
}();
var TextRenderer = function() {
  function TextRenderer2() {
  }
  var _proto = TextRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object) {
    var lineWidth = parsedStyle.lineWidth, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, lineJoin = parsedStyle.lineJoin, miterLimit = parsedStyle.miterLimit, letterSpacing = parsedStyle.letterSpacing, stroke = parsedStyle.stroke, fill = parsedStyle.fill, fillOpacity = parsedStyle.fillOpacity, strokeOpacity = parsedStyle.strokeOpacity, opacity = parsedStyle.opacity, metrics = parsedStyle.metrics, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
    var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
    context.font = font;
    context.lineWidth = lineWidth;
    context.textAlign = textAlign === "middle" ? "center" : textAlign;
    context.textBaseline = textBaseline;
    context.lineJoin = lineJoin;
    if (!is_nil_default(miterLimit)) {
      context.miterLimit = miterLimit;
    }
    var linePositionY = 0;
    if (textBaseline === "middle") {
      linePositionY = -height / 2 - lineHeight / 2;
    } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
      linePositionY = -height;
    } else if (textBaseline === "top" || textBaseline === "hanging") {
      linePositionY = -lineHeight;
    }
    var offsetX = dx || 0;
    linePositionY += dy || 0;
    var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
    setShadowAndFilter(object, context, hasShadow);
    for (var i = 0; i < lines.length; i++) {
      var linePositionX = lineWidth / 2 + offsetX;
      linePositionY += lineHeight;
      if (!is_nil_default(stroke) && !stroke.isNone && lineWidth) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);
      }
      if (!is_nil_default(fill)) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);
      }
    }
  };
  _proto.drawLetterSpacing = function drawLetterSpacing(context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    if (letterSpacing === 0) {
      if (isStroke) {
        this.strokeText(context, text, x, y, strokeOpacity);
      } else {
        this.fillText(context, text, x, y, fillOpacity, opacity);
      }
      return;
    }
    var currentTextAlign = context.textAlign;
    context.textAlign = "left";
    var currentPosition = x;
    if (textAlign === "center" || textAlign === "middle") {
      currentPosition = x - lineMetrics.width / 2;
    } else if (textAlign === "right" || textAlign === "end") {
      currentPosition = x - lineMetrics.width;
    }
    var stringArray = Array.from(text);
    var previousWidth = context.measureText(text).width;
    var currentWidth = 0;
    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];
      if (isStroke) {
        this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);
      } else {
        this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);
      }
      currentWidth = context.measureText(text.substring(i + 1)).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
    context.textAlign = currentTextAlign;
  };
  _proto.fillText = function fillText(context, text, x, y, fillOpacity, opacity) {
    var currentGlobalAlpha;
    var applyOpacity = !is_nil_default(fillOpacity) && fillOpacity !== 1;
    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = fillOpacity * opacity;
    }
    context.fillText(text, x, y);
    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };
  _proto.strokeText = function strokeText(context, text, x, y, strokeOpacity) {
    var currentGlobalAlpha;
    var applyOpacity = !is_nil_default(strokeOpacity) && strokeOpacity !== 1;
    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = strokeOpacity;
    }
    context.strokeText(text, x, y);
    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };
  return TextRenderer2;
}();
var RectRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(RectRenderer2, _DefaultRenderer);
  function RectRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return RectRenderer2;
}(DefaultRenderer);
var CircleRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(CircleRenderer2, _DefaultRenderer);
  function CircleRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return CircleRenderer2;
}(DefaultRenderer);
var EllipseRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(EllipseRenderer2, _DefaultRenderer);
  function EllipseRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return EllipseRenderer2;
}(DefaultRenderer);
var LineRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(LineRenderer2, _DefaultRenderer);
  function LineRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return LineRenderer2;
}(DefaultRenderer);
var PolylineRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PolylineRenderer2, _DefaultRenderer);
  function PolylineRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PolylineRenderer2;
}(DefaultRenderer);
var PolygonRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PolygonRenderer2, _DefaultRenderer);
  function PolygonRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PolygonRenderer2;
}(DefaultRenderer);
var PathRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PathRenderer2, _DefaultRenderer);
  function PathRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PathRenderer2;
}(DefaultRenderer);
var Plugin3 = function(_AbstractRendererPlug) {
  _inheritsLoose5(Plugin7, _AbstractRendererPlug);
  function Plugin7(options) {
    var _this2;
    if (options === void 0) {
      options = {};
    }
    _this2 = _AbstractRendererPlug.call(this) || this;
    _this2.options = void 0;
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _defaultStyleRenderer;
    var canvasRendererPluginOptions = _extends2({
      dirtyObjectNumThreshold: 500,
      dirtyObjectRatioThreshold: 0.8
    }, this.options);
    var imagePool = this.context.imagePool;
    var defaultRenderer = new DefaultRenderer(imagePool);
    var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defaultStyleRenderer[Shape.CIRCLE] = defaultRenderer, _defaultStyleRenderer[Shape.ELLIPSE] = defaultRenderer, _defaultStyleRenderer[Shape.RECT] = defaultRenderer, _defaultStyleRenderer[Shape.IMAGE] = new ImageRenderer(imagePool), _defaultStyleRenderer[Shape.TEXT] = new TextRenderer(), _defaultStyleRenderer[Shape.LINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYLINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYGON] = defaultRenderer, _defaultStyleRenderer[Shape.PATH] = defaultRenderer, _defaultStyleRenderer[Shape.GROUP] = void 0, _defaultStyleRenderer[Shape.HTML] = void 0, _defaultStyleRenderer[Shape.MESH] = void 0, _defaultStyleRenderer);
    this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
    this.context.styleRendererFactory = defaultStyleRendererFactory;
    this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
    delete this.context.defaultStyleRendererFactory;
    delete this.context.styleRendererFactory;
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-image-loader@1.1.45_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
function _regeneratorRuntime4() {
  _regeneratorRuntime4 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep4(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator4(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep4(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep4(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf6(subClass, superClass);
}
function _setPrototypeOf6(o, p) {
  _setPrototypeOf6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf6(o, p);
}
var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create7() {
  var out = new ARRAY_TYPE2(16);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function identity4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function scale7(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
var ImagePool = function() {
  function ImagePool2(canvasConfig) {
    this.canvasConfig = void 0;
    this.imageCache = {};
    this.gradientCache = {};
    this.patternCache = {};
    this.canvasConfig = canvasConfig;
  }
  var _proto = ImagePool2.prototype;
  _proto.getImageSync = function getImageSync(src, callback) {
    if (!this.imageCache[src]) {
      this.getOrCreateImage(src).then(function() {
        if (callback) {
          callback();
        }
      });
    } else {
      if (callback) {
        callback();
      }
    }
    return this.imageCache[src];
  };
  _proto.getOrCreateImage = function getOrCreateImage(src) {
    var _this2 = this;
    if (this.imageCache[src]) {
      return Promise.resolve(this.imageCache[src]);
    }
    var createImage = this.canvasConfig.createImage;
    return new Promise(function(resolve, reject) {
      var image;
      if (createImage) {
        image = createImage(src);
      } else if (isBrowser) {
        image = new window.Image();
      }
      if (image) {
        image.onload = function() {
          resolve(image);
        };
        image.onerror = function(ev) {
          reject(ev);
        };
        image.crossOrigin = "Anonymous";
        image.src = src;
        _this2.imageCache[src] = image;
      }
    });
  };
  _proto.getOrCreatePatternSync = function getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, callback) {
    var patternKey = this.generatePatternKey(pattern);
    if (patternKey && this.patternCache[patternKey]) {
      return this.patternCache[patternKey];
    }
    var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
    var src;
    var needScaleWithDPR = false;
    if (is_string_default(image)) {
      src = this.getImageSync(image, callback);
    } else if ($offscreenCanvas) {
      src = $offscreenCanvas;
      needScaleWithDPR = true;
    } else {
      src = image;
    }
    var canvasPattern = src && context.createPattern(src, repetition);
    if (canvasPattern) {
      var mat;
      if (transform) {
        mat = parsedTransformToMat4(parseTransform(transform));
      } else {
        mat = identity4(create7());
      }
      if (needScaleWithDPR) {
        scale7(mat, mat, [1 / dpr, 1 / dpr, 1]);
      }
      canvasPattern.setTransform({
        a: mat[0],
        b: mat[1],
        c: mat[4],
        d: mat[5],
        e: mat[12],
        f: mat[13]
      });
    }
    if (patternKey && canvasPattern) {
      this.patternCache[patternKey] = canvasPattern;
    }
    return canvasPattern;
  };
  _proto.getOrCreateGradient = function getOrCreateGradient(params, context) {
    var key = this.generateGradientKey(params);
    var type = params.type, steps = params.steps, width = params.width, height = params.height, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
    if (this.gradientCache[key]) {
      return this.gradientCache[key];
    }
    var gradient2 = null;
    if (type === GradientType.LinearGradient) {
      var _computeLinearGradien = computeLinearGradient(width, height, angle3), x1 = _computeLinearGradien.x1, y1 = _computeLinearGradien.y1, x2 = _computeLinearGradien.x2, y2 = _computeLinearGradien.y2;
      gradient2 = context.createLinearGradient(x1, y1, x2, y2);
    } else if (type === GradientType.RadialGradient) {
      var _computeRadialGradien = computeRadialGradient(width, height, cx, cy, size2), x = _computeRadialGradien.x, y = _computeRadialGradien.y, r = _computeRadialGradien.r;
      gradient2 = context.createRadialGradient(x, y, 0, x, y, r);
    }
    if (gradient2) {
      steps.forEach(function(_ref) {
        var offset = _ref.offset, color2 = _ref.color;
        if (offset.unit === UnitType.kPercentage) {
          var _gradient;
          (_gradient = gradient2) === null || _gradient === void 0 ? void 0 : _gradient.addColorStop(offset.value / 100, color2.toString());
        }
      });
      this.gradientCache[key] = gradient2;
    }
    return this.gradientCache[key];
  };
  _proto.generateGradientKey = function generateGradientKey(params) {
    var type = params.type, width = params.width, height = params.height, steps = params.steps, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
    return "gradient-" + type + "-" + ((angle3 === null || angle3 === void 0 ? void 0 : angle3.toString()) || 0) + "-" + ((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0) + "-" + ((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0) + "-" + ((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0) + "-" + width + "-" + height + "-" + steps.map(function(_ref2) {
      var offset = _ref2.offset, color2 = _ref2.color;
      return "" + offset + color2;
    }).join("-");
  };
  _proto.generatePatternKey = function generatePatternKey(pattern) {
    var image = pattern.image, repetition = pattern.repetition;
    if (is_string_default(image)) {
      return "pattern-" + image + "-" + repetition;
    } else if (image.nodeName === "rect") {
      return "pattern-" + image.entity + "-" + repetition;
    }
  };
  return ImagePool2;
}();
var LoadImagePlugin = function() {
  function LoadImagePlugin2() {
  }
  var _proto = LoadImagePlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    var handleMounted = function handleMounted2(e2) {
      var object = e2.target;
      var nodeName = object.nodeName, attributes = object.attributes;
      if (nodeName === Shape.IMAGE) {
        var img = attributes.img;
        if (is_string_default(img)) {
          imagePool.getImageSync(img, function() {
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      }
    };
    var handleAttributeChanged = function handleAttributeChanged2(e2) {
      var object = e2.target;
      var attrName = e2.attrName, newValue = e2.newValue;
      if (object.nodeName === Shape.IMAGE) {
        if (attrName === "img") {
          if (is_string_default(newValue)) {
            imagePool.getOrCreateImage(newValue).then(function() {
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        }
      }
    };
    renderingService.hooks.init.tapPromise(LoadImagePlugin2.tag, _asyncToGenerator4(_regeneratorRuntime4().mark(function _callee() {
      return _regeneratorRuntime4().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
      canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
    });
  };
  return LoadImagePlugin2;
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin4 = function(_AbstractRendererPlug) {
  _inheritsLoose6(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "image-loader";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.context.imagePool = new ImagePool(this.context.config);
    this.addRenderingPlugin(new LoadImagePlugin());
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-mobile-interaction@0.7.42_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-mobile-interaction/dist/index.esm.js
function _regeneratorRuntime5() {
  _regeneratorRuntime5 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep5(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator5(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep5(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep5(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose7(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf7(subClass, superClass);
}
function _setPrototypeOf7(o, p) {
  _setPrototypeOf7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf7(o, p);
}
var MobileInteractionPlugin = function() {
  function MobileInteractionPlugin2() {
  }
  var _proto = MobileInteractionPlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService, contextService = context.contextService;
    var canvasEl = contextService.getDomElement();
    var onPointerDown = function onPointerDown2(ev) {
      renderingService.hooks.pointerDown.call(ev);
    };
    var onPointerUp = function onPointerUp2(ev) {
      renderingService.hooks.pointerUp.call(ev);
    };
    var onPointerMove = function onPointerMove2(ev) {
      renderingService.hooks.pointerMove.call(ev);
    };
    var onPointerOver = function onPointerOver2(ev) {
      renderingService.hooks.pointerOver.call(ev);
    };
    var onPointerOut = function onPointerOut2(ev) {
      renderingService.hooks.pointerOut.call(ev);
    };
    var onPointerCancel = function onPointerCancel2(ev) {
      renderingService.hooks.pointerCancel.call(ev);
    };
    renderingService.hooks.init.tapPromise(MobileInteractionPlugin2.tag, _asyncToGenerator5(_regeneratorRuntime5().mark(function _callee() {
      return _regeneratorRuntime5().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvasEl.addEventListener("touchstart", onPointerDown, true);
              canvasEl.addEventListener("touchend", onPointerUp, true);
              canvasEl.addEventListener("touchmove", onPointerMove, true);
              canvasEl.addEventListener("touchcancel", onPointerCancel, true);
              canvasEl.addEventListener("mouseout", onPointerOut, true);
              canvasEl.addEventListener("mouseover", onPointerOver, true);
            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(MobileInteractionPlugin2.tag, function() {
      canvasEl.removeEventListener("touchstart", onPointerDown, true);
      canvasEl.removeEventListener("touchend", onPointerUp, true);
      canvasEl.removeEventListener("touchmove", onPointerMove, true);
      canvasEl.removeEventListener("touchcancel", onPointerCancel, true);
      canvasEl.removeEventListener("mouseout", onPointerOut, true);
      canvasEl.removeEventListener("mouseover", onPointerOver, true);
    });
  };
  return MobileInteractionPlugin2;
}();
MobileInteractionPlugin.tag = "MobileInteraction";
var Plugin5 = function(_AbstractRendererPlug) {
  _inheritsLoose7(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "mobile-interaction";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.addRenderingPlugin(new MobileInteractionPlugin());
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-mobile-canvas@0.8.42_@antv+g-lite@1.0.42/node_modules/@antv/g-mobile-canvas/dist/index.esm.js
function _regeneratorRuntime6() {
  _regeneratorRuntime6 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep6(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator6(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep6(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep6(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose8(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf8(subClass, superClass);
}
function _setPrototypeOf8(o, p) {
  _setPrototypeOf8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf8(o, p);
}
function _regeneratorRuntime$1() {
  _regeneratorRuntime$1 = function _regeneratorRuntime7() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function define3(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; ) {
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          }
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object) {
      keys.push(key);
    }
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this) {
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        }
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator$1(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
var DragndropPlugin = function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    this.dragndropPluginOptions = void 0;
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  var _proto = DragndropPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    var renderingService = context.renderingService, renderingContext = context.renderingContext;
    var document2 = renderingContext.root.ownerDocument;
    var canvas = document2.defaultView;
    var handlePointerdown = function handlePointerdown2(event) {
      var target = event.target;
      var isDocument = target === document2;
      var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
      if (draggableEventTarget) {
        var dragstartTriggered = false;
        var dragstartTimeStamp = event.timeStamp;
        var dragstartClientCoordinates = [event.clientX, event.clientY];
        var currentDroppable = null;
        var lastDragClientCoordinates = [event.clientX, event.clientY];
        var handlePointermove = function() {
          var _ref = _asyncToGenerator$1(_regeneratorRuntime$1().mark(function _callee(event2) {
            var timeElapsed, distanceMoved, point, elementsBelow, elementBelow, droppableBelow;
            return _regeneratorRuntime$1().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 8;
                      break;
                    }
                    timeElapsed = event2.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                    if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    event2.type = "dragstart";
                    draggableEventTarget.dispatchEvent(event2);
                    dragstartTriggered = true;
                  case 8:
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates = [event2.clientX, event2.clientY];
                    if (isDocument) {
                      _context.next = 21;
                      break;
                    }
                    point = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    _context.next = 17;
                    return document2.elementsFromPoint(point[0], point[1]);
                  case 17:
                    elementsBelow = _context.sent;
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        event2.type = "dragover";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                    }
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function handlePointermove2(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        canvas.addEventListener("pointermove", handlePointermove);
        var stopDragging = function stopDragging2(originalPointerUpEvent) {
          if (dragstartTriggered) {
            originalPointerUpEvent.detail = {
              preventClick: true
            };
            var _event = originalPointerUpEvent.clone();
            if (currentDroppable) {
              _event.type = "drop";
              _event.target = currentDroppable;
              currentDroppable.dispatchEvent(_event);
            }
            _event.type = "dragend";
            draggableEventTarget.dispatchEvent(_event);
            dragstartTriggered = false;
          }
          canvas.removeEventListener("pointermove", handlePointermove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: true
        });
        target.addEventListener("pointerupoutside", stopDragging, {
          once: true
        });
      }
    };
    renderingService.hooks.init.tapPromise(DragndropPlugin2.tag, _asyncToGenerator$1(_regeneratorRuntime$1().mark(function _callee2() {
      return _regeneratorRuntime$1().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              canvas.addEventListener("pointerdown", handlePointerdown);
            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
      canvas.removeEventListener("pointerdown", handlePointerdown);
    });
  };
  return DragndropPlugin2;
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin6 = function(_AbstractRendererPlug) {
  _inheritsLoose$1(Plugin7, _AbstractRendererPlug);
  function Plugin7(options) {
    var _this2;
    if (options === void 0) {
      options = {};
    }
    _this2 = _AbstractRendererPlug.call(this) || this;
    _this2.options = void 0;
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.addRenderingPlugin(new DragndropPlugin(_extends3({
      overlap: "pointer",
      isDocumentDraggable: false,
      isDocumentDroppable: false,
      dragstartDistanceThreshold: 0,
      dragstartTimeThreshold: 0
    }, this.options)));
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  _proto.setOptions = function setOptions(options) {
    Object.assign(this.plugins[0].dragndropPluginOptions, options);
  };
  return Plugin7;
}(AbstractRendererPlugin);
function isCanvasElement(el) {
  if (!el || typeof el !== "object")
    return false;
  if (el.nodeType === 1 && el.nodeName) {
    return true;
  }
  return !!el.isCanvasElement;
}
var Canvas2DContextService = function() {
  function Canvas2DContextService2(context) {
    this.$canvas = void 0;
    this.dpr = void 0;
    this.context = void 0;
    this.canvasConfig = void 0;
    this.canvasConfig = context.config;
  }
  var _proto = Canvas2DContextService2.prototype;
  _proto.init = function() {
    var _init = _asyncToGenerator6(_regeneratorRuntime6().mark(function _callee() {
      var _this$canvasConfig, canvas, devicePixelRatio, dpr;
      return _regeneratorRuntime6().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$canvasConfig = this.canvasConfig, canvas = _this$canvasConfig.canvas, devicePixelRatio = _this$canvasConfig.devicePixelRatio;
              this.$canvas = canvas;
              this.context = this.$canvas.getContext("2d");
              dpr = devicePixelRatio || 1;
              dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
              this.dpr = dpr;
              this.resize(this.canvasConfig.width, this.canvasConfig.height);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function init() {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.getContext = function getContext() {
    return this.context;
  };
  _proto.getDomElement = function getDomElement() {
    return this.$canvas;
  };
  _proto.getDPR = function getDPR() {
    return this.dpr;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    if (this.$canvas.getBoundingClientRect) {
      return this.$canvas.getBoundingClientRect();
    }
  };
  _proto.destroy = function destroy() {
    this.context = null;
    this.$canvas = null;
  };
  _proto.resize = function resize(width, height) {
    var devicePixelRatio = this.canvasConfig.devicePixelRatio;
    var pixelRatio = devicePixelRatio;
    var canvasDOM = this.$canvas;
    if (canvasDOM.style) {
      canvasDOM.style.width = width + "px";
      canvasDOM.style.height = height + "px";
    }
    if (isCanvasElement(canvasDOM)) {
      canvasDOM.width = width * pixelRatio;
      canvasDOM.height = height * pixelRatio;
      if (pixelRatio !== 1) {
        this.context.scale(pixelRatio, pixelRatio);
      }
    }
  };
  _proto.applyCursorStyle = function applyCursorStyle(cursor) {
  };
  _proto.toDataURL = function() {
    var _toDataURL = _asyncToGenerator6(_regeneratorRuntime6().mark(function _callee2(options) {
      var type, encoderOptions;
      return _regeneratorRuntime6().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              type = options.type, encoderOptions = options.encoderOptions;
              return _context2.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function toDataURL(_x) {
      return _toDataURL.apply(this, arguments);
    }
    return toDataURL;
  }();
  return Canvas2DContextService2;
}();
var ContextRegisterPlugin = function(_AbstractRendererPlug) {
  _inheritsLoose8(ContextRegisterPlugin2, _AbstractRendererPlug);
  function ContextRegisterPlugin2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "mobile-canvas-context-register";
    return _this2;
  }
  var _proto = ContextRegisterPlugin2.prototype;
  _proto.init = function init() {
    this.context.ContextService = Canvas2DContextService;
  };
  _proto.destroy = function destroy() {
    delete this.context.ContextService;
  };
  return ContextRegisterPlugin2;
}(AbstractRendererPlugin);
var Renderer = function(_AbstractRenderer) {
  _inheritsLoose8(Renderer2, _AbstractRenderer);
  function Renderer2(config) {
    var _this2;
    _this2 = _AbstractRenderer.call(this, config) || this;
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new Plugin4());
    _this2.registerPlugin(new Plugin());
    _this2.registerPlugin(new Plugin3());
    _this2.registerPlugin(new Plugin5());
    _this2.registerPlugin(new Plugin2());
    _this2.registerPlugin(new Plugin6({
      isDocumentDraggable: is_nil_default(config === null || config === void 0 ? void 0 : config.isDocumentDraggable) ? true : config.isDocumentDraggable,
      isDocumentDroppable: is_nil_default(config === null || config === void 0 ? void 0 : config.isDocumentDroppable) ? true : config.isDocumentDroppable,
      dragstartDistanceThreshold: is_nil_default(config === null || config === void 0 ? void 0 : config.dragstartDistanceThreshold) ? 10 : config.dragstartDistanceThreshold,
      dragstartTimeThreshold: is_nil_default(config === null || config === void 0 ? void 0 : config.dragstartTimeThreshold) ? 50 : config.dragstartTimeThreshold
    }));
    return _this2;
  }
  return Renderer2;
}(AbstractRenderer);

// node_modules/.pnpm/@antv+g-mobile-canvas-element@0.6.42_@antv+g-lite@1.0.42/node_modules/@antv/g-mobile-canvas-element/dist/index.esm.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var CanvasElement = function() {
  function CanvasElement2(ctx) {
    this.width = void 0;
    this.height = void 0;
    this.isCanvasElement = true;
    this.context = void 0;
    this.emitter = new import_eventemitter34.default();
    this.context = ctx;
    var canvas = ctx.canvas || {};
    this.width = canvas.width || 0;
    this.height = canvas.height || 0;
  }
  var _proto = CanvasElement2.prototype;
  _proto.getContext = function getContext(contextId, contextAttributes) {
    return this.context;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    var width = this.width;
    var height = this.height;
    return {
      top: 0,
      right: width,
      bottom: height,
      left: 0,
      width,
      height,
      x: 0,
      y: 0
    };
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    this.emitter.on(type, listener);
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    this.emitter.off(type, listener);
  };
  _proto.dispatchEvent = function dispatchEvent(e2) {
    this.emitter.emit(e2.type, e2);
    return true;
  };
  return CanvasElement2;
}();
function supportEventListener(canvas) {
  if (!canvas) {
    return false;
  }
  if (canvas.nodeType !== 1 || !canvas.nodeName || canvas.nodeName.toLowerCase() !== "canvas") {
    return false;
  }
  var support = false;
  try {
    canvas.addEventListener("eventTest", function() {
      support = true;
    });
    canvas.dispatchEvent(new Event("eventTest"));
  } catch (error) {
    support = false;
  }
  return support;
}
function createMobileCanvasElement(ctx) {
  if (!ctx) {
    return null;
  }
  if (supportEventListener(ctx.canvas)) {
    return ctx.canvas;
  }
  return new CanvasElement(ctx);
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/component/updater.js
function createUpdater(canvas) {
  var setStateQueue = [];
  function process() {
    var item;
    var renderComponents = [];
    var renderCallbackQueue = [];
    while (item = setStateQueue.shift()) {
      var state = item.state, component = item.component, callback = item.callback;
      if (component.destroyed) {
        continue;
      }
      if (!component.prevState) {
        component.prevState = Object.assign({}, component.state);
      }
      if (typeof state === "function") {
        Object.assign(component.state, state(component.prevState, component.props));
      } else {
        Object.assign(component.state, state);
      }
      component.prevState = component.state;
      if (typeof callback === "function") {
        renderCallbackQueue.push({
          callback,
          component
        });
      }
      if (renderComponents.indexOf(component) < 0) {
        renderComponents.push(component);
      }
    }
    canvas.updateComponents(renderComponents);
    commitRenderQueue(renderCallbackQueue);
  }
  function enqueueSetState(component, state, callback) {
    if (setStateQueue.length === 0) {
      setTimeout(process, 0);
    }
    setStateQueue.push({
      component,
      state,
      callback
    });
  }
  function commitRenderQueue(callbackQueue) {
    for (var i = 0; i < callbackQueue.length; i++) {
      var _a = callbackQueue[i], callback = _a.callback, component = _a.component;
      callback.call(component);
    }
  }
  var updater = {
    // isMounted: function(publicInstance) {
    //   return false;
    // },
    enqueueForceUpdate: enqueueSetState,
    // enqueueReplaceState: function(publicInstance, completeState) {
    // },
    enqueueSetState
  };
  return updater;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/index.js
var import_eventemitter35 = __toESM(require_eventemitter3());

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/theme.js
var THEME = {
  fontSize: "24px",
  fontFamily: '"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif',
  pixelRatio: 1,
  padding: [0, 0, 0, 0]
};
var theme_default = THEME;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/cssRule.js
var elementStyle = {
  fillStyle: "String",
  font: "String",
  globalAlpha: "Number",
  lineCap: "String",
  lineWidth: ["Number", "String"],
  lineJoin: "String",
  miterLimit: "Number",
  shadowBlur: "Number",
  shadowColor: "String",
  shadowOffsetX: "Number",
  shadowOffsetY: "Number",
  strokeStyle: "String",
  textAlign: "String",
  textBaseline: "String",
  lineDash: ["Array", "Number"],
  shadow: "String",
  matrix: "Array",
  stroke: "String",
  fill: ["String", "Object"],
  opacity: "Number",
  fillOpacity: "Number",
  strokeOpacity: "Number"
};
var DEFAULT_CSS_RULE = {
  group: __assign({}, elementStyle),
  text: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    text: "String",
    width: "Number",
    height: "Number",
    fontSize: ["Number", "String"],
    fontFamily: "String",
    fontStyle: "String",
    fontWeight: ["Number", "String"],
    fontVariant: "String"
  }),
  circle: __assign(__assign({}, elementStyle), {
    cx: "Number",
    cy: "Number",
    r: "Number"
  }),
  path: __assign({}, elementStyle),
  ellipse: __assign(__assign({}, elementStyle), {
    cy: "Number",
    cx: "Number",
    ry: "Number",
    rx: "Number"
  }),
  rect: __assign(__assign({}, elementStyle), {
    width: "Number",
    height: "Number",
    x: "Number",
    y: "Number",
    radius: ["Array", "Number"]
  }),
  image: __assign(__assign({}, elementStyle), {
    width: "Number",
    height: "Number",
    x: "Number",
    y: "Number",
    img: "String",
    src: "String"
  }),
  line: __assign(__assign({}, elementStyle), {
    x1: "Number",
    x2: "Number",
    y1: "Number",
    y2: "Number"
  }),
  polyline: __assign(__assign({}, elementStyle), {
    points: "Array",
    smooth: "Boolean"
  }),
  polygon: __assign(__assign({}, elementStyle), {
    points: "Array"
  }),
  arc: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    r: "Number",
    startAngle: ["Number", "String"],
    endAngle: ["Number", "String"],
    anticlockwise: "Boolean"
  }),
  marker: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    radius: "Number",
    symbol: "String"
  }),
  sector: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    startAngle: ["Number", "String"],
    endAngle: ["Number", "String"],
    r: "Number",
    r0: "Number",
    anticlockwise: "Boolean"
  })
};
function checkCSSRule(type, style) {
  if (!style) {
    return style;
  }
  var cssStyle = {};
  Object.keys(style).forEach(function(key) {
    var value = style[key];
    if (is_nil_default(value)) {
      return;
    }
    var rule = DEFAULT_CSS_RULE[type] && DEFAULT_CSS_RULE[type][key];
    if (!rule) {
      cssStyle[key] = value;
      return;
    }
    var valueType = Object.prototype.toString.call(value);
    if (is_array_default(rule)) {
      for (var i = 0, len5 = rule.length; i < len5; i++) {
        if (valueType === "[object ".concat(rule[i], "]")) {
          cssStyle[key] = value;
          return;
        }
      }
      return;
    }
    if (valueType === "[object ".concat(rule, "]")) {
      cssStyle[key] = value;
    }
  });
  return cssStyle;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/util.js
var ONE_REM;
try {
  ONE_REM = parseInt(document.documentElement.style.fontSize, 10) || 50;
} catch (e2) {
  ONE_REM = 50;
}
var SCALE = ONE_REM / 100;
function defaultPx2hd(px2) {
  if (!px2) {
    return 0;
  }
  return Number((px2 * SCALE).toFixed(1));
}
function parsePadding(padding) {
  if (is_number_default(padding)) {
    return [padding, padding, padding, padding];
  }
  var top = padding[0];
  var right = is_number_default(padding[1]) ? padding[1] : padding[0];
  var bottom = is_number_default(padding[2]) ? padding[2] : top;
  var left = is_number_default(padding[3]) ? padding[3] : right;
  return [top, right, bottom, left];
}
function batch2hd(px2hd2) {
  var batchPx2hd = function batchPx2hd2(value) {
    if (is_string_default(value) && /^-?\d+(\.\d+)?px$/.test(value)) {
      var num = value.substr(0, value.length - 2);
      return px2hd2(Number(num));
    }
    if (is_array_default(value)) {
      return value.map(function(v) {
        return batchPx2hd2(v);
      });
    }
    if (is_plain_object_default(value)) {
      var result = {};
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var rst = batchPx2hd2(value[key]);
          if (!rst) {
            result[key] = rst;
            continue;
          }
          if (key === "padding" || key === "margin") {
            var paddingArray = parsePadding(rst);
            result[key] = paddingArray;
            result["".concat(key, "Top")] = paddingArray[0];
            result["".concat(key, "Right")] = paddingArray[1];
            result["".concat(key, "Bottom")] = paddingArray[2];
            result["".concat(key, "Left")] = paddingArray[3];
            continue;
          }
          result[key] = rst;
        }
      }
      return result;
    }
    return value;
  };
  return batchPx2hd;
}
var px2hd = batch2hd(defaultPx2hd);

// node_modules/.pnpm/@antv+g-web-animations-api@1.0.31_@antv+g-lite@1.0.42/node_modules/@antv/g-web-animations-api/dist/index.esm.js
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose9(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf9(subClass, superClass);
}
function _setPrototypeOf9(o, p) {
  _setPrototypeOf9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf9(o, p);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var AnimationEvent = function(_FederatedEvent) {
  _inheritsLoose9(AnimationEvent2, _FederatedEvent);
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _this2 = _FederatedEvent.call(this, manager) || this;
    _this2.currentTime = void 0;
    _this2.timelineTime = void 0;
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  return AnimationEvent2;
}(FederatedEvent);
var sequenceNumber = 0;
var Animation = function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    this.effect = void 0;
    this.timeline = void 0;
    this.id = void 0;
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this.oldPlayState = void 0;
    this._holdTime = void 0;
    this.readyPromise = void 0;
    this.finishedPromise = void 0;
    this.resolveReadyPromise = void 0;
    this.rejectReadyPromise = void 0;
    this.resolveFinishedPromise = void 0;
    this.rejectFinishedPromise = void 0;
    this.onfinish = void 0;
    this.oncancel = void 0;
    this.onframe = void 0;
    this._currentTime = 0;
    this._startTime = void 0;
    this._playbackRate = 1;
    this._totalDuration = void 0;
    this._inEffect = void 0;
    this._inTimeline = true;
    this.onremove = void 0;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "" + sequenceNumber++;
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  var _proto = Animation2.prototype;
  _proto.updatePromises = function updatePromises() {
    var oldPlayState = this.oldPlayState;
    var newPlayState = this.pending ? "pending" : this.playState;
    if (this.readyPromise && newPlayState !== oldPlayState) {
      if (newPlayState === "idle") {
        this.rejectReadyPromise();
        this.readyPromise = void 0;
      } else if (oldPlayState === "pending") {
        this.resolveReadyPromise();
      } else if (newPlayState === "pending") {
        this.readyPromise = void 0;
      }
    }
    if (this.finishedPromise && newPlayState !== oldPlayState) {
      if (newPlayState === "idle") {
        this.rejectFinishedPromise();
        this.finishedPromise = void 0;
      } else if (newPlayState === "finished") {
        this.resolveFinishedPromise();
      } else if (oldPlayState === "finished") {
        this.finishedPromise = void 0;
      }
    }
    this.oldPlayState = newPlayState;
    return this.readyPromise || this.finishedPromise;
  };
  _proto.play = function play() {
    this.updatePromises();
    this._paused = false;
    if (this._isFinished || this._idle) {
      this.rewind();
      this._startTime = null;
    }
    this._finishedFlag = false;
    this._idle = false;
    this.ensureAlive();
    this.timeline.applyDirtiedAnimation(this);
    if (this.timeline.animations.indexOf(this) === -1) {
      this.timeline.animations.push(this);
    }
    this.updatePromises();
  };
  _proto.pause = function pause() {
    this.updatePromises();
    if (this.currentTime) {
      this._holdTime = this.currentTime;
    }
    if (!this._isFinished && !this._paused && !this._idle) {
      this.currentTimePending = true;
    } else if (this._idle) {
      this.rewind();
      this._idle = false;
    }
    this._startTime = null;
    this._paused = true;
    this.updatePromises();
  };
  _proto.finish = function finish() {
    this.updatePromises();
    if (this._idle)
      return;
    this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
    this._startTime = this._totalDuration - this.currentTime;
    this.currentTimePending = false;
    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };
  _proto.cancel = function cancel() {
    this.updatePromises();
    if (!this._inEffect)
      return;
    this._inEffect = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._startTime = null;
    this.effect.update(null);
    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };
  _proto.reverse = function reverse() {
    this.updatePromises();
    var oldCurrentTime = this.currentTime;
    this.playbackRate *= -1;
    this.play();
    if (oldCurrentTime !== null) {
      this.currentTime = oldCurrentTime;
    }
    this.updatePromises();
  };
  _proto.updatePlaybackRate = function updatePlaybackRate(playbackRate) {
    this.playbackRate = playbackRate;
  };
  _proto.targetAnimations = function targetAnimations() {
    var _this$effect2;
    var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
    return target.getAnimations();
  };
  _proto.markTarget = function markTarget() {
    var animations = this.targetAnimations();
    if (animations.indexOf(this) === -1) {
      animations.push(this);
    }
  };
  _proto.unmarkTarget = function unmarkTarget() {
    var animations = this.targetAnimations();
    var index = animations.indexOf(this);
    if (index !== -1) {
      animations.splice(index, 1);
    }
  };
  _proto.tick = function tick(timelineTime, isAnimationFrame) {
    if (!this._idle && !this._paused) {
      if (this._startTime === null) {
        if (isAnimationFrame) {
          this.startTime = timelineTime - this._currentTime / this.playbackRate;
        }
      } else if (!this._isFinished) {
        this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
      }
    }
    if (isAnimationFrame) {
      this.currentTimePending = false;
      this.fireEvents(timelineTime);
    }
  };
  _proto.rewind = function rewind() {
    if (this.playbackRate >= 0) {
      this.currentTime = 0;
    } else if (this._totalDuration < Infinity) {
      this.currentTime = this._totalDuration;
    } else {
      throw new Error("Unable to rewind negative playback rate animation with infinite duration");
    }
  };
  _proto.persist = function persist() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.dispatchEvent = function dispatchEvent(event) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.commitStyles = function commitStyles() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.ensureAlive = function ensureAlive() {
    if (this.playbackRate < 0 && this.currentTime === 0) {
      var _this$effect3;
      this._inEffect = !!((_this$effect3 = this.effect) === null || _this$effect3 === void 0 ? void 0 : _this$effect3.update(-1));
    } else {
      var _this$effect4;
      this._inEffect = !!((_this$effect4 = this.effect) === null || _this$effect4 === void 0 ? void 0 : _this$effect4.update(this.currentTime));
    }
    if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
      this._inTimeline = true;
      this.timeline.animations.push(this);
    }
  };
  _proto.tickCurrentTime = function tickCurrentTime(newTime, ignoreLimit) {
    if (newTime !== this._currentTime) {
      this._currentTime = newTime;
      if (this._isFinished && !ignoreLimit) {
        this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      }
      this.ensureAlive();
    }
  };
  _proto.fireEvents = function fireEvents(baseTime) {
    var _this2 = this;
    if (this._isFinished) {
      if (!this._finishedFlag) {
        if (this.onfinish) {
          var event = new AnimationEvent(null, this, this.currentTime, baseTime);
          setTimeout(function() {
            if (_this2.onfinish) {
              _this2.onfinish(event);
            }
          });
        }
        this._finishedFlag = true;
      }
    } else {
      if (this.onframe && this.playState === "running") {
        var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
        this.onframe(_event);
      }
      this._finishedFlag = false;
    }
  };
  _createClass2(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get() {
      if (this._idle)
        return "idle";
      if (this._isFinished)
        return "finished";
      if (this._paused)
        return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get() {
      var _this3 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this3.resolveFinishedPromise = function() {
            resolve(_this3);
          };
          _this3.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
  }, {
    key: "currentTime",
    get: function get() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set7(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime))
        return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    },
    set: function set7(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime))
          return;
        if (this._paused || this._idle)
          return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get() {
      return this._playbackRate;
    },
    set: function set7(value) {
      if (value === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }]);
  return Animation2;
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A2 = function A3(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B2 = function B3(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C2 = function C3(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0)
      aB = currentT;
    else
      aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0)
      return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2)
    return function(t) {
      return t;
    };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist4 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist4 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE)
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    else if (initialSlope === 0)
      return guessForT;
    else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  };
  return function(t) {
    if (t === 0 || t === 1)
      return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-" + letter.toLowerCase();
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function Quad2(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic2(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart2(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint2(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo2(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine2(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ2(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back2(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce2(t) {
  var pow2, b = 4;
  while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params = params, _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a = clamp_default(Number(amplitude), 1, 10);
  var p = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1)
    return t;
  return -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
};
var Spring = function Spring2(t, params, duration) {
  if (params === void 0) {
    params = [];
  }
  var _params2 = params, _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1)
    return t;
  return 1 - progress;
};
var Steps = function Steps2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params3 = params, _params3$ = _params3[0], steps = _params3$ === void 0 ? 10 : _params3$, type = _params3[1];
  var trunc = type == "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params4 = params, mX1 = _params4[0], mY1 = _params4[1], mX2 = _params4[2], mY2 = _params4[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return 1 - ease2(1 - t, params, duration);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function stepEnd(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function linear(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  in: easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear2 = function linear3(x) {
  return x;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count, pos2) {
  return function(x) {
    if (x >= 1) {
      return 1;
    }
    var stepSize = 1 / count;
    x += pos2 * stepSize;
    return x - x % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(" + numberString + "," + numberString + "," + numberString + "," + numberString + "\\)");
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, cubicData.slice(1).map(Number));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both")
        return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both")
        return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d4 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d4 += 1;
    }
    currentDirection = "normal";
    if (d4 !== Infinity && d4 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null)
    return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration);
        target2.style[interpolation.property] = interpolation.interpolation(scaledLocalTime);
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) {
        if (isNotReservedWord(property)) {
          target2.style[property] = null;
        }
      }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f) {
    var interpolated = interpolate(from, to, f);
    return !runtime.enableCSSParsing && is_number_default(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left, right, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata.int) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var usedLeft;
      var usedRight;
      if (runtime.enableCSSParsing) {
        var computedLeft = runtime.styleValueRegistry.parseProperty(property, left, target);
        var computedRight = runtime.styleValueRegistry.parseProperty(property, right, target);
        usedLeft = runtime.styleValueRegistry.computeProperty(property, computedLeft, target);
        usedRight = runtime.styleValueRegistry.computeProperty(property, computedRight, target);
      } else {
        var parser = propertyHandler.parserWithCSSDisabled;
        usedLeft = parser ? parser(left, target) : left;
        usedRight = parser ? parser(right, target) : right;
      }
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, interpolationArgs);
        return function(t) {
          if (t === 0)
            return left;
          if (t === 1)
            return right;
          return interp(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right : left;
  });
}
function interpolate(from, to, f) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f) + to * f;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    if (from.length === to.length) {
      var r = [];
      for (var i = 0; i < from.length; i++) {
        r.push(interpolate(from[i], to[i], f));
      }
      return r;
    }
  }
  throw new Error("Mismatched interpolation arguments " + from + ":" + to);
}
var AnimationEffectTiming = function() {
  function AnimationEffectTiming2() {
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear2;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.playbackRate = void 0;
    this.effect = void 0;
    this.composite = void 0;
    this.activeDuration = void 0;
    this.endTime = void 0;
    this.currentIteration = null;
    this.progress = null;
  }
  _createClass2(AnimationEffectTiming2, [{
    key: "easing",
    get: function get() {
      return this._easing;
    },
    set: function set7(value) {
      this.easingFunction = parseEasingFunction(value);
      this._easing = value;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay
     */
  }]);
  return AnimationEffectTiming2;
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values = effectInput[property];
    if (!Array.isArray(values)) {
      values = [values];
    }
    var numKeyframes = values.length;
    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i] = keyframe;
      }
      if (values[i] !== void 0 && values[i] !== null) {
        normalizedEffectInput[i][property] = values[i];
      }
    }
  }
  normalizedEffectInput.sort(function(a, b) {
    return (a.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing === null || timing === void 0 ? void 0 : timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue))
            throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1)
            throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error(memberValue + " compositing is not supported");
        }
      } else
        ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i = 0; i < keyframes.length; i++) {
    var offset = keyframes[i].offset;
    if (!is_nil_default(offset)) {
      if (offset < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var length14 = keyframes.length;
    keyframes[length14 - 1].computedOffset = Number((_keyframes$offset = keyframes[length14 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length14 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length14; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!is_nil_default(_offset) && !is_nil_default(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++) {
          keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        }
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset)
    spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  var _timingInput;
  timingInput = numericTimingToObject((_timingInput = timingInput) !== null && _timingInput !== void 0 ? _timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = void 0;
    this.animation = void 0;
    this.timing = void 0;
    this.computedTiming = void 0;
    this.normalizedKeyframes = void 0;
    this.timeFraction = void 0;
    this.interpolations = void 0;
    this.target = target;
    this.timing = normalizeTimingInput(timingInput, false);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    this.computedTiming = new Proxy(this.timing, {
      get: function get(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        } else if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        } else if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        } else if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        } else if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set7() {
        return true;
      }
    });
  }
  var _proto = KeyframeEffect2.prototype;
  _proto.applyInterpolations = function applyInterpolations() {
    this.interpolations(this.target, Number(this.timeFraction));
  };
  _proto.update = function update(localTime) {
    if (localTime === null) {
      return false;
    }
    this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
    return this.timeFraction !== null;
  };
  _proto.getKeyframes = function getKeyframes() {
    return this.normalizedKeyframes;
  };
  _proto.setKeyframes = function setKeyframes(keyframes) {
    this.normalizedKeyframes = normalizeKeyframes(keyframes);
  };
  _proto.getComputedTiming = function getComputedTiming() {
    return this.computedTiming;
  };
  _proto.getTiming = function getTiming() {
    return this.timing;
  };
  _proto.updateTiming = function updateTiming(timing) {
    var _this2 = this;
    Object.keys(timing || {}).forEach(function(name) {
      _this2.timing[name] = timing[name];
    });
  };
  return KeyframeEffect2;
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    this.document = void 0;
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.frameId = void 0;
    this.webAnimationsNextTick = function(t) {
      _this2.currentTime = t;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t < Number(_this2.currentTime))
        t = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  var _proto = AnimationTimeline2.prototype;
  _proto.getAnimations = function getAnimations() {
    this.discardAnimations();
    return this.animations.slice();
  };
  _proto.isTicking = function isTicking() {
    return this.inTick;
  };
  _proto.play = function play(target, keyframes, options) {
    var effect = new KeyframeEffect(target, keyframes, options);
    var animation = new Animation(effect, this);
    this.animations.push(animation);
    this.restartWebAnimationsNextTick();
    animation.updatePromises();
    animation.play();
    animation.updatePromises();
    return animation;
  };
  _proto.applyDirtiedAnimation = function applyDirtiedAnimation(animation) {
    var _this2 = this;
    if (this.inTick) {
      return;
    }
    animation.markTarget();
    var animations = animation.targetAnimations();
    animations.sort(compareAnimations);
    var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
    inactiveAnimations.forEach(function(animation2) {
      var index = _this2.animations.indexOf(animation2);
      if (index !== -1) {
        _this2.animations.splice(index, 1);
      }
    });
    this.applyPendingEffects();
  };
  _proto.restart = function restart() {
    if (!this.ticking) {
      this.ticking = true;
      this.requestAnimationFrame(function() {
      });
      this.hasRestartedThisFrame = true;
    }
    return this.hasRestartedThisFrame;
  };
  _proto.destroy = function destroy() {
    this.document.defaultView.cancelAnimationFrame(this.frameId);
  };
  _proto.applyPendingEffects = function applyPendingEffects() {
    this.pendingEffects.forEach(function(effect) {
      effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
    });
    this.pendingEffects = [];
  };
  _proto.updateAnimationsPromises = function updateAnimationsPromises() {
    this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
      return animation.updatePromises();
    });
  };
  _proto.discardAnimations = function discardAnimations() {
    this.updateAnimationsPromises();
    this.animations = this.animations.filter(function(animation) {
      return animation.playState !== "finished" && animation.playState !== "idle";
    });
  };
  _proto.restartWebAnimationsNextTick = function restartWebAnimationsNextTick() {
    if (!this.timelineTicking) {
      this.timelineTicking = true;
      this.requestAnimationFrame(this.webAnimationsNextTick);
    }
  };
  _proto.rAF = function rAF(f) {
    var id2 = this.rafId++;
    if (this.rafCallbacks.length === 0) {
      this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
    }
    this.rafCallbacks.push([id2, f]);
    return id2;
  };
  _proto.requestAnimationFrame = function requestAnimationFrame3(f) {
    var _this3 = this;
    return this.rAF(function(x) {
      _this3.updateAnimationsPromises();
      f(x);
      _this3.updateAnimationsPromises();
    });
  };
  _proto.tick = function tick(t, isAnimationFrame, updatingAnimations) {
    var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
    this.inTick = true;
    this.hasRestartedThisFrame = false;
    this.currentTime = t;
    this.ticking = false;
    var newPendingClears = [];
    var newPendingEffects = [];
    var activeAnimations = [];
    var inactiveAnimations = [];
    updatingAnimations.forEach(function(animation) {
      animation.tick(t, isAnimationFrame);
      if (!animation._inEffect) {
        newPendingClears.push(animation.effect);
        animation.unmarkTarget();
      } else {
        newPendingEffects.push(animation.effect);
        animation.markTarget();
      }
      if (animation._needsTick)
        _this4.ticking = true;
      var alive = animation._inEffect || animation._needsTick;
      animation._inTimeline = alive;
      if (alive) {
        activeAnimations.push(animation);
      } else {
        inactiveAnimations.push(animation);
      }
    });
    (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
    (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
    if (this.ticking)
      this.requestAnimationFrame(function() {
      });
    this.inTick = false;
    return [activeAnimations, inactiveAnimations];
  };
  return AnimationTimeline2;
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/index.js
function measureText(container, px2hd2, theme) {
  return function(text, font) {
    var _a = font || {}, _b = _a.fontSize, fontSize = _b === void 0 ? theme.fontSize : _b, _c = _a.fontFamily, fontFamily = _c === void 0 ? theme.fontFamily : _c, _d = _a.fontWeight, fontWeight = _d === void 0 ? theme.fontWeight : _d, _e = _a.fontVariant, fontVariant = _e === void 0 ? theme.fontVariant : _e, _f = _a.fontStyle, fontStyle = _f === void 0 ? theme.fontStyle : _f, _g = _a.textAlign, textAlign = _g === void 0 ? theme.textAlign : _g, _h = _a.textBaseline, textBaseline = _h === void 0 ? theme.textBaseline : _h, _j = _a.lineWidth, lineWidth = _j === void 0 ? 1 : _j;
    var style = {
      x: 0,
      y: 0,
      fontSize: px2hd2(fontSize),
      fontFamily,
      fontStyle,
      fontWeight,
      fontVariant,
      text,
      textAlign,
      textBaseline,
      lineWidth,
      visibility: "hidden"
    };
    var result = checkCSSRule("text", style);
    var shape = new Text({
      style: result
    });
    container.appendChild(shape);
    var _k = shape.getBBox(), width = _k.width, height = _k.height;
    shape.remove();
    return {
      width,
      height
    };
  };
}
function computeLayout3(style) {
  var left = style.left, top = style.top, width = style.width, height = style.height, padding = style.padding;
  var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
  return {
    left: left + paddingLeft,
    top: top + paddingTop,
    width: width - paddingLeft - paddingRight,
    height: height - paddingTop - paddingBottom
  };
}
var Canvas2 = (
  /** @class */
  function() {
    function Canvas3(props) {
      var context = props.context, _a = props.renderer, renderer = _a === void 0 ? new Renderer() : _a, width = props.width, height = props.height, customTheme = props.theme, customPx2hd = props.px2hd, customPixelRatio = props.pixelRatio, landscape = props.landscape, rendererContainer = props.container, customStyle = props.style, _b = props.animate, animate = _b === void 0 ? true : _b, createImage = props.createImage, requestAnimationFrame3 = props.requestAnimationFrame, cancelAnimationFrame3 = props.cancelAnimationFrame;
      var px2hd2 = is_function_default(customPx2hd) ? batch2hd(customPx2hd) : px2hd;
      var theme = px2hd2(__assign(__assign({}, theme_default), customTheme));
      var pixelRatio = theme.pixelRatio, fontSize = theme.fontSize, fontFamily = theme.fontFamily, padding = theme.padding;
      var devicePixelRatio = customPixelRatio ? customPixelRatio : pixelRatio;
      var updater = createUpdater(this);
      var canvasElement = createMobileCanvasElement(context);
      var canvas = new Canvas({
        container: rendererContainer,
        canvas: canvasElement,
        devicePixelRatio,
        renderer,
        width,
        height,
        supportsTouchEvents: true,
        supportsPointerEvents: true,
        createImage,
        requestAnimationFrame: requestAnimationFrame3,
        cancelAnimationFrame: cancelAnimationFrame3
      });
      var container = canvas.getRoot();
      var _c = canvas.getConfig(), canvasWidth = _c.width, canvasHeight = _c.height;
      container.setAttribute("fontSize", fontSize);
      container.setAttribute("fontFamily", fontFamily);
      var gesture = new gesture_default(container);
      var componentContext = {
        ctx: context,
        root: this,
        canvas,
        px2hd: px2hd2,
        theme,
        gesture,
        measureText: measureText(container, px2hd2, theme)
      };
      var vNode = {
        key: void 0,
        tag: ClassComponent,
        // style: layout,
        // @ts-ignore
        type: Canvas3,
        props,
        shape: container,
        animate,
        // @ts-ignore
        component: this,
        canvas: this,
        context: componentContext,
        updater
      };
      this._ee = new import_eventemitter35.default();
      this.props = props;
      this.context = componentContext;
      this.updater = updater;
      this.gesture = gesture;
      this.theme = theme;
      this.canvas = canvas;
      this.container = container;
      this.el = canvasElement;
      this.vNode = vNode;
      this.landscape = landscape;
      this.updateLayout(__assign(__assign({}, props), {
        width: canvasWidth,
        height: canvasHeight
      }));
    }
    Canvas3.prototype.updateComponents = function(components) {
      updateComponents(components);
    };
    Canvas3.prototype.update = function(nextProps) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, props, vNode, _b, animate;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a = this, props = _a.props, vNode = _a.vNode;
              if (equal_default(nextProps, props)) {
                return [
                  2
                  /*return*/
                ];
              }
              _b = props.animate, animate = _b === void 0 ? true : _b;
              this.props = nextProps;
              vNode.props = nextProps;
              vNode.animate = animate;
              return [4, this.render()];
            case 1:
              _c.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.render = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a, canvas, vNode;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = this, canvas = _a.canvas, vNode = _a.vNode;
              return [4, canvas.ready];
            case 1:
              _b.sent();
              render(vNode);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.emit = function(type, event) {
      this._ee.emit(type, event);
    };
    Canvas3.prototype.on = function(type, listener) {
      this._ee.on(type, listener);
    };
    Canvas3.prototype.off = function(type, listener) {
      this._ee.off(type, listener);
    };
    Canvas3.prototype.getCanvasEl = function() {
      return this.el;
    };
    Canvas3.prototype.resize = function(width, height) {
      return __awaiter(this, void 0, void 0, function() {
        var canvas;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              canvas = this.canvas;
              canvas.resize(width, height);
              this.updateLayout(__assign(__assign({}, this.props), {
                width,
                height
              }));
              return [4, this.render()];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.updateLayout = function(props) {
      var width = props.width, height = props.height;
      var _a = this.context, px2hd2 = _a.px2hd, theme = _a.theme;
      var style = px2hd2(__assign({
        left: 0,
        top: 0,
        width,
        height,
        padding: theme.padding
      }, props.style));
      var layout = computeLayout3(style);
      var left = layout.left, top = layout.top;
      this.container.setAttribute("x", left);
      this.container.setAttribute("y", top);
      this.context = __assign(__assign({}, this.context), {
        left,
        top,
        width: layout.width,
        height: layout.height
      });
      this.vNode = __assign(__assign({}, this.vNode), {
        style: layout,
        context: this.context
      });
    };
    Canvas3.prototype.toRawChildren = function(children) {
      return children;
    };
    Canvas3.prototype.destroy = function() {
      var _a = this, canvas = _a.canvas, children = _a.children, el = _a.el;
      destroyElement(children);
      el.width = 0;
      el.height = 0;
      this.props = null;
      this.context = null;
      this.updater = null;
      this.theme = null;
      this.canvas = null;
      this.container = null;
      this.el = null;
      this.vNode = null;
      canvas.ready.then(function() {
        canvas.destroy();
      });
    };
    return Canvas3;
  }()
);
var canvas_default = Canvas2;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/timeline.js
var Timeline = (
  /** @class */
  function(_super) {
    __extends(Timeline2, _super);
    function Timeline2(props) {
      var _this2 = _super.call(this, props) || this;
      _this2.next = function() {
        var _a2 = _this2, state = _a2.state, props2 = _a2.props;
        var index = state.index, count2 = state.count, delay2 = state.delay;
        var loop = props2.loop;
        var next = loop ? (index + 1) % count2 : index + 1;
        if (next < count2) {
          setTimeout(function() {
            _this2.setState({
              index: next
            });
          }, delay2 || 0);
        }
      };
      var delay = props.delay, _a = props.start, start = _a === void 0 ? 0 : _a, children = props.children;
      var count = children_default.toArray(children).length;
      _this2.state = {
        delay,
        count,
        index: start
      };
      return _this2;
    }
    Timeline2.prototype.didMount = function() {
      this.animator.on("end", this.next);
    };
    Timeline2.prototype.didUnmount = function() {
      this.animator.off("end", this.next);
    };
    Timeline2.prototype.render = function() {
      var _a = this, state = _a.state, props = _a.props;
      var children = props.children;
      var index = state.index;
      var childrenArray = children_default.toArray(children);
      return childrenArray[index];
    };
    return Timeline2;
  }(component_default)
);

// node_modules/.pnpm/@antv+f-vue@0.0.35_vue@3.2.47/node_modules/@antv/f-vue/es/index.js
var toRawChildren = function toRawChildren2(slots) {
  return children_default.map(slots, function(slot) {
    if (!slot)
      return slot;
    var element = toRaw(slot);
    if (isVNode(element)) {
      var key = element.key, ref = element.ref, type = element.type, props = element.props, children = element.children;
      if (children) {
        props.children = toRawChildren2(children);
      }
      return {
        key,
        ref,
        type,
        props
      };
    }
    if (element.default) {
      var children = element.default();
      return toRawChildren2(children);
    }
    return null;
  });
};
var es_default = {
  props: {
    className: {
      type: String,
      required: false
    },
    pixelRatio: {
      type: Number,
      default: 1,
      required: false
    },
    width: {
      type: [Number, String],
      required: false
    },
    height: {
      type: [Number, String],
      required: false
    },
    padding: {
      type: [Number, String, Array],
      required: false
    },
    animate: {
      type: [Boolean],
      default: true,
      required: false
    },
    px2hd: {
      type: [Function],
      required: false
    }
  },
  methods: {
    getProps: function getProps() {
      var _a = this, $props = _a.$props, $slots = _a.$slots;
      var props = toRaw($props);
      var canvasEl = this.$el;
      var context = canvasEl.getContext("2d");
      return __assign(__assign({}, props), {
        // context 
        context,
        children: toRawChildren($slots)
      });
    }
  },
  mounted: function mounted() {
    return __awaiter(this, void 0, void 0, function() {
      var props, canvas;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            props = this.getProps();
            canvas = new canvas_default(props);
            return [4, canvas.render()];
          case 1:
            _a.sent();
            this.canvas = canvas;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  updated: function updated() {
    return __awaiter(this, void 0, void 0, function() {
      var props, canvas;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            props = this.getProps();
            canvas = this.canvas;
            return [4, canvas.update(props)];
          case 1:
            _a.sent();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  render: function render2() {
    return h("canvas", {
      className: "f-chart ".concat(this.className || ""),
      style: {
        width: "100%",
        height: "100%",
        display: "block",
        padding: 0,
        margin: 0
      }
    });
  },
  beforeUnmount: function beforeUnmount() {
    var canvas = this.canvas;
    canvas.destroy();
  }
};
export {
  es_default as default
};
//# sourceMappingURL=@antv_f-vue.js.map
