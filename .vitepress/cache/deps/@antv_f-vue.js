import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  _typeof
} from "./chunk-E7FFEZEH.js";
import {
  h,
  isVNode,
  toRaw
} from "./chunk-GOZHMCMR.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.js
var require_rbush = __commonJS({
  "node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.js"(exports, module) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = global2 || self, global2.RBush = factory2());
    })(exports, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare2) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare2 || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare2) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s2 = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s2 / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s2 / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare2);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare2(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare2(arr[i], t) < 0) {
              i++;
            }
            while (compare2(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare2(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swap(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var RBush2 = function RBush3(maxEntries) {
        if (maxEntries === void 0)
          maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush2.prototype.all = function all() {
        return this._all(this.data, []);
      };
      RBush2.prototype.search = function search(bbox) {
        var node = this.data;
        var result = [];
        if (!intersects(bbox, node)) {
          return result;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) {
                result.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush2.prototype.load = function load(data2) {
        if (!(data2 && data2.length)) {
          return this;
        }
        if (data2.length < this._minEntries) {
          for (var i = 0; i < data2.length; i++) {
            this.insert(data2[i]);
          }
          return this;
        }
        var node = this._build(data2.slice(), 0, data2.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush2.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush2.prototype.clear = function clear() {
        this.data = createNode([]);
        return this;
      };
      RBush2.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path = [];
        var indexes = [];
        var i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush2.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush2.prototype.compareMinX = function compareMinX(a, b) {
        return a.minX - b.minX;
      };
      RBush2.prototype.compareMinY = function compareMinY(a, b) {
        return a.minY - b.minY;
      };
      RBush2.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush2.prototype.fromJSON = function fromJSON(data2) {
        this.data = data2;
        return this;
      };
      RBush2.prototype._all = function _all(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result.push.apply(result, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype._build = function _build(items, left, right, height) {
        var N = right - left + 1;
        var M = this._maxEntries;
        var node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M);
        var N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (var i = left; i <= right; i += N1) {
          var right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (var j = i; j <= right2; j += N2) {
            var right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      };
      RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush2.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend2(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush2.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M = node.children.length;
        var m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      };
      RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {
        var index;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);
          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      };
      RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m, M, compareMinX);
        var yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush2.prototype._allDistMargin = function _allDistMargin(node, m, M, compare2) {
        node.children.sort(compare2);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m, toBBox);
        var rightBBox = distBBox(node, M - m, M, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend2(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend2(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend2(path[i], bbox);
        }
      };
      RBush2.prototype._condense = function _condense(path) {
        for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox(path[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend2(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend2(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX);
        var minY = Math.max(a.minY, b.minY);
        var maxX = Math.min(a.maxX, b.maxX);
        var maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare2) {
        var stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) {
            continue;
          }
          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare2);
          stack.push(left, mid, mid, right);
        }
      }
      return RBush2;
    });
  }
});

// node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE4(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE4(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length14 = listeners.length, j;
        for (i = 0; i < length14; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length14 = listeners.length; i < length14; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad2) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s2 = Math.sin(rad2), c = Math.cos(rad2);
  out[0] = c * a00 + s2 * a10;
  out[1] = c * a01 + s2 * a11;
  out[2] = c * a02 + s2 * a12;
  out[3] = c * a10 - s2 * a00;
  out[4] = c * a11 - s2 * a01;
  out[5] = c * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad2) {
  var s2 = Math.sin(rad2), c = Math.cos(rad2);
  out[0] = c;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad2, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s2, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c = Math.cos(rad2);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s2;
  b02 = z * x * t - y * s2;
  b10 = x * y * t - z * s2;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s2;
  b20 = x * z * t + y * s2;
  b21 = y * z * t - x * s2;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s2;
  out[5] = a11 * c + a21 * s2;
  out[6] = a12 * c + a22 * s2;
  out[7] = a13 * c + a23 * s2;
  out[8] = a20 * c - a10 * s2;
  out[9] = a21 * c - a11 * s2;
  out[10] = a22 * c - a12 * s2;
  out[11] = a23 * c - a13 * s2;
  return out;
}
function rotateY(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s2;
  out[1] = a01 * c - a21 * s2;
  out[2] = a02 * c - a22 * s2;
  out[3] = a03 * c - a23 * s2;
  out[8] = a00 * s2 + a20 * c;
  out[9] = a01 * s2 + a21 * c;
  out[10] = a02 * s2 + a22 * c;
  out[11] = a03 * s2 + a23 * c;
  return out;
}
function rotateZ(out, a, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s2;
  out[1] = a01 * c + a11 * s2;
  out[2] = a02 * c + a12 * s2;
  out[3] = a03 * c + a13 * s2;
  out[4] = a10 * c - a00 * s2;
  out[5] = a11 * c - a01 * s2;
  out[6] = a12 * c - a02 * s2;
  out[7] = a13 * c - a03 * s2;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad2, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s2, c, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c = Math.cos(rad2);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s2;
  out[2] = z * x * t - y * s2;
  out[3] = 0;
  out[4] = x * y * t - z * s2;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s2;
  out[7] = 0;
  out[8] = x * z * t + y * s2;
  out[9] = y * z * t - x * s2;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = c;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c = Math.cos(rad2);
  out[0] = c;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s2) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s2, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.hypot(x0, x1, x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.hypot(y0, y1, y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  out[9] = a[9] + b[9] * scale8;
  out[10] = a[10] + b[10] * scale8;
  out[11] = a[11] + b[11] * scale8;
  out[12] = a[12] + b[12] * scale8;
  out[13] = a[13] + b[13] * scale8;
  out[14] = a[14] + b[14] * scale8;
  out[15] = a[15] + b[15] * scale8;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len5 = x * x + y * y + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  out[2] = a[2] * len5;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d4, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d4[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d4[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d4[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d4, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d4[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d4[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d4[2] * factor4;
  return out;
}
function random(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad2) - p[2] * Math.sin(rad2);
  r[2] = p[1] * Math.sin(rad2) + p[2] * Math.cos(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad2) + p[0] * Math.cos(rad2);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad2) - p[0] * Math.sin(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad2) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad2) - p[1] * Math.sin(rad2);
  r[1] = p[0] * Math.sin(rad2) + p[1] * Math.cos(rad2);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len5 = x * x + y * y + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x * len5;
  out[1] = y * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A4 = v[0] * w[1] - v[1] * w[0], B4 = v[0] * w[2] - v[2] * w[0], C4 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C4 - J * B4;
  out[2] = G * E2 - H * C4 + J * A4;
  out[3] = -(G * D2) + H * B4 - I * A4;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale8) {
  scale8 = scale8 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d4 = Math.sqrt((1 - s1) / s2);
  out[0] = scale8 * v1;
  out[1] = scale8 * v2;
  out[2] = scale8 * v3 * d4;
  out[3] = scale8 * v4 * d4;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s2 = Math.sin(rad2);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad2);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad2 = Math.acos(q[3]) * 2;
  var s2 = Math.sin(rad2 / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q[0] / s2;
    out_axis[1] = q[1] / s2;
    out_axis[2] = q[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad2;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s2 = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s2;
  out[1] = y * s2;
  out[2] = z * s2;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot6 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot6 ? 1 / dot6 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot6 = dot(a, b);
    if (dot6 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot6 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot6;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d4, t) {
    slerp(temp1, a, d4, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone6,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues6(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set6(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len5 = x * x + y * y;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale8;
  out[1] = Math.sin(r) * scale8;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad2) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals6(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path) {
  return path.map(function(x) {
    return Array.isArray(x) ? [].concat(x) : x;
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi = pathArray[i];
    var ni = i;
    while (pi.length) {
      allPathCommands[i] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a) {
    var x = _a[0];
    return x === x.toUpperCase();
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a) {
    var pc = _a[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path) {
  var index = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "' + pathValue[index] + '", expecting 0 or 1 at index ' + index;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path) {
  var max4 = path.max, pathValue = path.pathValue, start = path.index;
  var index = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index >= max4) {
    path.err = "[path-util]: Invalid path value at index " + index + ', "pathValue" is missing param';
    return;
  }
  ch = pathValue.charCodeAt(index);
  if (ch === 43 || ch === 45) {
    index += 1;
    ch = pathValue.charCodeAt(index);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" is not a number';
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (zeroFirst && index < max4) {
      if (ch && isDigit(ch)) {
        path.err = "[path-util]: Invalid path value at index " + start + ', "' + pathValue[start] + '" illegal number';
        return;
      }
    }
    while (index < max4 && isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 46) {
    hasDot = true;
    index += 1;
    while (isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" invalid float exponent';
      return;
    }
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (ch === 43 || ch === 45) {
      index += 1;
    }
    if (index < max4 && isDigit(pathValue.charCodeAt(index))) {
      while (index < max4 && isDigit(pathValue.charCodeAt(index))) {
        index += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index " + index + ', "' + pathValue[index] + '" invalid integer exponent';
      return;
    }
  }
  path.index = index;
  path.param = +path.pathValue.slice(start, index);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path) {
  var pathValue = path.pathValue, max4 = path.max;
  while (path.index < max4 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path) {
  var max4 = path.max, pathValue = path.pathValue, index = path.index;
  var cmdCode = pathValue.charCodeAt(index);
  var reqParams = paramsCount[pathValue[index].toLowerCase()];
  path.segmentStart = index;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "' + pathValue[index] + '" is not a path command';
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max4 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = parsePathString(pathInput);
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x = values[0], y = values[1];
      mx = x;
      my = y;
      return ["M", x, y];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5] + x,
            values[6] + y
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values[0] + y];
          break;
        case "H":
          absoluteSegment = [absCommand, values[0] + x];
          break;
        default: {
          var absValues = values.map(function(n, j) {
            return n + (j % 2 ? y : x);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x = mx;
        y = my;
        break;
      case "H":
        x = absoluteSegment[1];
        break;
      case "V":
        y = absoluteSegment[1];
        break;
      default:
        x = absoluteSegment[segLength - 2];
        y = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x;
          my = y;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values);
  } else if (pathCommand === "Q") {
    var nqx = values[0], nqy = values[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return clonePath(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i = 0; i < path.length; i += 1) {
    path[i] = normalizeSegment(path[i], params);
    var segment = path[i];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a) {
    var pc = _a[0];
    return "MC".includes(pc);
  });
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x, y, rad2) {
  var X = x * Math.cos(rad2) - y * Math.sin(rad2);
  var Y = x * Math.sin(rad2) + y * Math.cos(rad2);
  return { x: X, y: Y };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x2 = X2;
  var y2 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad2 = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad2);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x2, y2, -rad2);
    x2 = xy.x;
    y2 = xy.y;
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h2 = x * x / (rx * rx) + y * y / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y2 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = arcToCubic(x2, y2, rx, ry, angle3, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return m2.concat(m3, m4, res);
  }
  res = m2.concat(m3, m4, res);
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad2).y : rotateVector(res[i], res[i + 1], rad2).x;
  }
  return newres;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x1, y1, qx, qy, x2, y2) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    r13 * y1 + r23 * qy,
    r13 * x2 + r23 * qx,
    r13 * y2 + r23 * qy,
    x2,
    y2
    // x,y
  ];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a, b) {
  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x1, y1, x2, y2, distance6) {
  var length14 = distanceSquareRoot([x1, y1], [x2, y2]);
  var point = { x: 0, y: 0 };
  if (typeof distance6 === "number") {
    if (distance6 <= 0) {
      point = { x: x1, y: y1 };
    } else if (distance6 >= length14) {
      point = { x: x2, y: y2 };
    } else {
      var _a = midPoint([x1, y1], [x2, y2], distance6 / length14), x = _a[0], y = _a[1];
      point = { x, y };
    }
  }
  return {
    length: length14,
    point,
    min: {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2)
    },
    max: {
      x: Math.max(x1, x2),
      y: Math.max(y1, y2)
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/line-2-cubic.js
function lineToCubic(x1, y1, x2, y2) {
  var t = 0.5;
  var p0 = [x1, y1];
  var p1 = [x2, y2];
  var p2 = midPoint(p0, p1, t);
  var p3 = midPoint(p1, p2, t);
  var p4 = midPoint(p2, p3, t);
  var p5 = midPoint(p3, p4, t);
  var p6 = midPoint(p4, p5, t);
  var cp1 = segmentLineFactory(p0[0], p0[1], p2[0], p2[1], p4[0]).point;
  var cp2 = segmentLineFactory(p6[0], p6[1], p5[0], p5[1], p3[0]).point;
  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values = segment.slice(1).map(Number);
  var x = values[0], y = values[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x;
      params.y = y;
      return segment;
    case "A":
      args = [px1, py1].concat(values);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x;
      params.qy = y;
      args = [px1, py1].concat(values);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x, y));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
    default:
  }
  return segment;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = clonePath(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (path[i])
      pathCommand = path[i][0];
    allPathCommands[i] = pathCommand;
    var curveSegment = segmentToCubic(path[i], params);
    path[i] = curveSegment;
    fixArc(path, allPathCommands, i);
    ii = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i);
    }
    segment = path[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x, i, curveOnly) {
    return !i ? pathArray[0].slice(1).concat(x.slice(1)) : curveOnly[i - 1].slice(-2).concat(x.slice(1));
  }).map(function(x) {
    return x.map(function(y, i) {
      return x[x.length - i - 2 * (1 - i % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x) {
    return ["C"].concat(x.slice(2));
  }));
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p = v0x * v1x + v0y * v1y;
  var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle3, LAF, SF, x, y, t) {
  var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, PI3 = Math.PI;
  var rx = abs(RX);
  var ry = abs(RY);
  var xRot = (angle3 % 360 + 360) % 360;
  var xRotRad = xRot * (PI3 / 180);
  if (x1 === x && y1 === y) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x, y, t).point;
  }
  var dx = (x1 - x) / 2;
  var dy = (y1 - y) / 2;
  var transformedPoint = {
    x: cos(xRotRad) * dx + sin(xRotRad) * dy,
    y: -sin(xRotRad) * dx + cos(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,
    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI3;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI3;
  }
  sweepAngle %= 2 * PI3;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos(alpha);
  var ellipseComponentY = ry * sin(alpha);
  var point = {
    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
  };
  return point;
}
function segmentArcFactory(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = X1;
  var y = Y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 3) * x1 + 3 * Math.pow(t12, 2) * t * c1x + 3 * t12 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x2,
    y: Math.pow(t12, 3) * y1 + 3 * Math.pow(t12, 2) * t * c1y + 3 * t12 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y2
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = x1;
  var y = y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 2) * x1 + 2 * t12 * t * cx + Math.pow(t, 2) * x2,
    y: Math.pow(t12, 2) * y1 + 2 * t12 * t * cy + Math.pow(t, 2) * y2
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance6, options) {
  var _a;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length14 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x = x1;
  var y = y1;
  var LENGTH = 0;
  var prev = [x, y, LENGTH];
  var cur = [x, y];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x, y }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x, y };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t), x = _a.x, y = _a.y;
    if (bbox) {
      POINTS.push({ x, y });
    }
    if (length14) {
      LENGTH += distanceSquareRoot(cur, [x, y]);
    }
    cur = [x, y];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance6, options) {
  var _a, _b, _c, _d, _e, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance6 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length14 = 0;
  var min4 = { x: 0, y: 0 };
  var max4 = min4;
  var point = min4;
  var POINT = min4;
  var LENGTH = 0;
  for (var i = 0, ll = path.length; i < ll; i += 1) {
    seg = path[i];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x, y].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min4 = { x: mx, y: my };
      max4 = min4;
      length14 = 0;
      if (distanceIsNumber && distance6 < 1e-3) {
        POINT = min4;
      }
    } else if (pathCommand === "L") {
      _a = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length14 = _a.length, min4 = _a.min, max4 = _a.max, point = _a.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance6 || 0) - LENGTH, options || {}), length14 = _b.length, min4 = _b.min, max4 = _b.max, point = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance6 || 0) - LENGTH, options || {}), length14 = _c.length, min4 = _c.min, max4 = _c.max, point = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance6 || 0) - LENGTH, options || {}), length14 = _d.length, min4 = _d.min, max4 = _d.max, point = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x, y, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length14 = _e.length, min4 = _e.min, max4 = _e.max, point = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance6 && LENGTH + length14 >= distance6) {
      POINT = point;
    }
    MAX.push(max4);
    MIN.push(min4);
    LENGTH += length14;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x = _f[0], y = _f[1];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x, y };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a) {
  var segCount = a.length;
  var pointCount = segCount - 1;
  return a.map(function(f, idx) {
    return a.map(function(p, i) {
      var oldSegIdx = idx + i;
      var seg;
      if (i === 0 || a[oldSegIdx] && a[oldSegIdx][0] === "M") {
        seg = a[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a[oldSegIdx];
    });
  });
}
function getRotatedCurve(a, b) {
  var segCount = a.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a);
  rotations.forEach(function(r, i) {
    a.slice(1).forEach(function(s2, j) {
      sumLensSqrd += distanceSquareRoot(a[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x2, y2) {
  return 3 * ((y2 - y1) * (c1x + c2x) - (x2 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y2 * (c2x + x1 / 3) - x2 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x = 0;
  var y = 0;
  var len5 = 0;
  return path2Curve(path).map(function(seg) {
    var _a;
    switch (seg[0]) {
      case "M":
        x = seg[1], y = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x2 = _b[4], y2 = _b[5];
        len5 = getCubicSegArea(x, y, c1x, c1y, c2x, c2y, x2, y2);
        _a = seg.slice(-2), x = _a[0], y = _a[1];
        return len5;
    }
  }).reduce(function(a, b) {
    return a + b;
  }, 0);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance6, options) {
  return pathLengthFactory(pathInput, distance6, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i, pathArray) {
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c2 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c2.length;
  var l1 = c1.filter(function(x) {
    return x.l;
  }).length;
  var l2 = c2.filter(function(x) {
    return x.l;
  }).length;
  var m1 = c1.filter(function(x) {
    return x.l;
  }).reduce(function(a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l1 || 0;
  var m2 = c2.filter(function(x) {
    return x.l;
  }).reduce(function(a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m2];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c2].map(function(x, i) {
    return x.l === tl ? x.map(function(y) {
      return y.s;
    }) : x.map(function(y, j) {
      canSplit = j && dif[i] && y.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y.ss : [y.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-function.js
var is_function_default = function(value) {
  return typeof value === "function";
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-nil.js
var isNil = function(value) {
  return value === null || value === void 0;
};
var is_nil_default = isNil;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value, type) {
  return toString.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-array.js
var is_array_default = function(value) {
  return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value) {
  if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/max.js
var max_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!is_array_default(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-string.js
var is_string_default = function(str7) {
  return is_type_default(str7, "String");
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a, min4, max4) {
  if (a < min4) {
    return min4;
  } else if (a > max4) {
    return max4;
  }
  return a;
};
var clamp_default = clamp;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-number.js
var isNumber = function(value) {
  return is_type_default(value, "Number");
};
var is_number_default = isNumber;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n, m) {
  return (n % m + m) % m;
};
var mod_default = mod;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value) {
  return is_type_default(value, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value) {
  return value === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/.pnpm/@antv+util@3.3.2/node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/component/index.js
var Component = (
  /** @class */
  function() {
    function Component2(props, context, updater) {
      this.isMounted = false;
      this.destroyed = false;
      this.props = props;
      this.state = {};
      this.context = context;
      this.updater = updater;
    }
    Component2.prototype.willMount = function() {
    };
    Component2.prototype.didMount = function() {
    };
    Component2.prototype.shouldUpdate = function(_nextProps) {
      return true;
    };
    Component2.prototype.willReceiveProps = function(_props, _context) {
    };
    Component2.prototype.willUpdate = function() {
    };
    Component2.prototype.didUpdate = function() {
    };
    Component2.prototype.render = function() {
      return null;
    };
    Component2.prototype.willUnmount = function() {
    };
    Component2.prototype.didUnmount = function() {
    };
    Component2.prototype.setState = function(partialState, callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueSetState(this, partialState, callback);
    };
    Component2.prototype.forceUpdate = function(callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueForceUpdate(this, {}, callback);
    };
    Component2.prototype.setAnimate = function(animate) {
      this.animate = animate;
    };
    Component2.prototype.destroy = function() {
      this.destroyed = true;
      this.animator = null;
    };
    return Component2;
  }()
);
Component.prototype.isF2Component = true;
var component_default = Component;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/children.js
function cloneElement(element, props) {
  if (!element)
    return element;
  return __assign(__assign({}, element), {
    props: __assign(__assign({}, element.props), props)
  });
}
function map(children, fn) {
  if (!children) {
    return fn(children);
  }
  if (is_array_default(children)) {
    return children.map(function(child) {
      return map(child, fn);
    });
  }
  return fn(children);
}
function compareArray(nextElements, lastElements, callback) {
  var keyed = {};
  var nextLength = nextElements.length;
  var lastLength = lastElements.length;
  for (var i = 0, len5 = lastLength; i < len5; i++) {
    var element = lastElements[i];
    if (element && !is_nil_default(element.key)) {
      var key = element.key;
      keyed[key] = element;
    }
  }
  var result = [];
  for (var i = 0, len5 = nextLength; i < len5; i++) {
    var element = nextElements[i];
    if (!element) {
      continue;
    }
    var key = element.key;
    var lastElement = void 0;
    if (!is_nil_default(element.key)) {
      lastElement = keyed[key];
      if (lastElement)
        delete keyed[key];
    } else {
      lastElement = lastElements[i];
    }
    if (!lastElement) {
      result.push(compare(element, null, callback));
      continue;
    }
    if (lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed) {
      result.push(compare(element, null, callback));
      continue;
    }
    lastElement.__processed = true;
    result.push(compare(element, lastElement, callback));
  }
  for (var i = 0, len5 = lastLength; i < len5; i++) {
    var lastElement = lastElements[i];
    if (!lastElement) {
      continue;
    }
    if (!(lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed)) {
      result.push(compare(null, lastElement, callback));
    } else {
      delete lastElement.__processed;
    }
  }
  return result;
}
function compare(nextElement, lastElement, callback) {
  if (!nextElement || !lastElement) {
    return callback(nextElement, lastElement);
  }
  if (is_array_default(nextElement) || is_array_default(lastElement)) {
    var nextElementArray = is_array_default(nextElement) ? nextElement : [nextElement];
    var lastElementArray = is_array_default(lastElement) ? lastElement : [lastElement];
    return compareArray(nextElementArray, lastElementArray, callback);
  }
  return callback(nextElement, lastElement);
}
function toArray(element) {
  if (!element) {
    return element;
  }
  if (!is_array_default(element)) {
    return [element];
  }
  var newArray = [];
  for (var i = 0, len5 = element.length; i < len5; i++) {
    var item = element[i];
    if (is_array_default(item)) {
      newArray = newArray.concat(toArray(item));
    } else {
      newArray.push(item);
    }
  }
  return newArray;
}
var Children = {
  cloneElement,
  map,
  toArray,
  compare
};
var children_default = Children;

// node_modules/.pnpm/@antv+g-lite@1.0.42/node_modules/@antv/g-lite/dist/index.esm.js
var import_rbush = __toESM(require_rbush());
var import_rbush2 = __toESM(require_rbush());

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/define.js
function define_default(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l, a) {
  if (a <= 0)
    h2 = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h2 = NaN, s2 = max4 - min4, l = (max4 + min4) / 2;
  if (s2) {
    if (r === max4)
      h2 = (g - b) / s2 + (g < b) * 6;
    else if (g === max4)
      h2 = (b - r) / s2 + 2;
    else
      h2 = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h2 *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l, o.opacity);
}
function hsl(h2, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h2, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h2, c, l, opacity) {
  this.h = +h2;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h2 = s2 ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l, o.opacity);
}
function cubehelix(h2, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h2), sinh = Math.sin(h2);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

// node_modules/.pnpm/@antv+g-math@1.7.42/node_modules/@antv/g-math/dist/index.esm.js
function distance4(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, xArr);
  var minY = Math.min.apply(Math, yArr);
  var maxX = Math.max.apply(Math, xArr);
  var maxY = Math.max.apply(Math, yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: Math.min(x1, x2),
    maxX: Math.max(x1, x2),
    minY: Math.min(y1, y2),
    maxY: Math.max(y1, y2)
  };
}
function piMod(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
var util = Object.freeze({
  __proto__: null,
  distance: distance4,
  isNumberEqual: isNumberEqual2,
  getBBoxByArray,
  getBBoxRange,
  piMod
});
var line = {
  /**
   * 计算线段的包围盒
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {object} 包围盒对象
   */
  box: function box(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 线段的长度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 距离
   */
  length: function length5(x1, y1, x2, y2) {
    return distance4(x1, y1, x2, y2);
  },
  /**
   * 根据比例获取点
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} t 指定比例
   * @return {object} 包含 x, y 的点
   */
  pointAt: function pointAt(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
    var cross4 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross4 < 0) {
      return distance4(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross4 > lengthSquare) {
      return distance4(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 点到直线的距离，而不是点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
    var d4 = [x2 - x1, y2 - y1];
    if (vec2_exports.exactEquals(d4, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d4[1], d4[0]];
    vec2_exports.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2_exports.dot(a, u));
  },
  /**
   * 线段的角度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 导数
   */
  tangentAngle: function tangentAngle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length14) {
  var t = -1;
  var d4 = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length14 && length14 > 200) {
    segNum = length14 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d4) {
      t = _t;
      d4 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d4 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval < EPSILON2) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
    var _d = distance4(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d4) {
      t = prev;
      d4 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d4) {
        t = next;
        d4 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, xArr.concat([t])),
    y: tCallback.apply(void 0, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance4(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);
  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance4(x1, y1, x2, y2) + distance4(x2, y2, x3, y3) + distance4(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(void 0, left) + quadraticLength.apply(void 0, right);
}
var quadratic = {
  box: function box2(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function length6(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function nearestPoint$1(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function pointDistance2(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance4(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function pointAt2(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function divide4(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function tangentAngle2(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle3 = Math.atan2(dy, dx);
    return piMod(angle3);
  }
};
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt$1(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema$1(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line.pointAt(x1, y1, x2, y2, t);
  var c2 = line.pointAt(x2, y2, x3, y3, t);
  var c3 = line.pointAt(x3, y3, x4, y4, t);
  var c12 = line.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = [].concat(cubics[0], [iterationCount - 1]);
  var right = [].concat(cubics[1], [iterationCount - 1]);
  return cubicLength.apply(void 0, left) + cubicLength.apply(void 0, right);
}
var cubic = {
  extrema: extrema$1,
  box: function box3(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema$1(x1, x2, x3, x4);
    var yExtrema2 = extrema$1(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var _i = 0; _i < yExtrema2.length; _i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[_i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function length7(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function nearestPoint$12(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length14);
  },
  pointDistance: function pointDistance3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14);
    return distance4(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function pointAt3(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function divide5(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function tangentAngle3(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt$1(x1, x2, x3, x4, t);
    var dy = derivativeAt$1(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse = {
  /**
   * 包围盒计算
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {object} 包围盒
   */
  box: function box4(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 计算周长，使用近似法
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {number} 椭圆周长
   */
  length: function length8(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 距离椭圆最近的点
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {object} 椭圆上距离指定点最近的点
   */
  nearestPoint: function nearestPoint2(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px2 = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX = 0;
    var nearestY = 0;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px2 - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  /**
   * 点到椭圆最近的距离
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {number} 点到椭圆的距离
   */
  pointDistance: function pointDistance4(x, y, rx, ry, x0, y0) {
    var nearestPoint5 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance4(nearestPoint5.x, nearestPoint5.y, x0, y0);
  },
  /**
   * 根据比例获取点
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例，x轴方向为 0
   * @return {object} 点
   */
  pointAt: function pointAt4(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle3),
      y: y + ry * Math.sin(angle3)
    };
  },
  /**
   * 根据比例计算切线角度
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整
   * @return {number} 角度，在 0 - 2PI 之间
   */
  tangentAngle: function tangentAngle4(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    var tangentAngle10 = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
    return piMod(tangentAngle10);
  }
};
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function getAngle2(rx, ry, x0, y0) {
  var angle3 = Math.atan2(y0 * rx, x0 * ry);
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle3) {
  return {
    x: rx * Math.cos(angle3),
    y: ry * Math.sin(angle3)
  };
}
function rotate4(x, y, angle3) {
  var cos = Math.cos(angle3);
  var sin = Math.sin(angle3);
  return [x * cos - y * sin, x * sin + y * cos];
}
var arc = {
  /**
   * 计算包围盒
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @return {object} 包围盒对象
   */
  box: function box5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var _i = 0; _i < xs.length; _i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
      var yAngle = yDim + _i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var _i3 = 0; _i3 < ys.length; _i3++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  /**
   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，
   * 仅跟 rx, ry, startAngle, endAngle 相关
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   */
  length: function length9(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 获取指定点到圆弧的最近距离的点
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @param {number} x0         指定点的 x
   * @param {number} y0         指定点的 y
   * @return {object} 到指定点最近距离的点
   */
  nearestPoint: function nearestPoint3(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate4(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle3 = getAngle2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle3 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle3 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate4(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function pointDistance5(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint5 = this.nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0);
    return distance4(nearestPoint5.x, nearestPoint5.y, x0, y0);
  },
  pointAt: function pointAt5(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle3),
      y: yAt(cx, cy, rx, ry, xRotation, angle3)
    };
  },
  tangentAngle: function tangentAngle5(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    return piMod(Math.atan2(dy, dx));
  }
};
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length14 = distance4(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length14
    };
    segments.push(seg);
    totalLength += length14;
  }
  return {
    segments,
    totalLength
  };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _analyzePoints = analyzePoints(points), segments = _analyzePoints.segments, totalLength = _analyzePoints.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _analyzePoints2 = analyzePoints(points), segments = _analyzePoints2.segments, totalLength = _analyzePoints2.totalLength;
  var startRatio = 0;
  var angle3 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle3 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle3;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];
    var _distance = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
    if (_distance < minDistance) {
      minDistance = _distance;
    }
  }
  return minDistance;
}
var polyline = {
  /**
   * 计算多折线的包围盒
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 包围盒
   */
  box: function box6(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 计算多折线的长度
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 多条边的长度
   */
  length: function length10(points) {
    return lengthOfSegment(points);
  },
  /**
   * 根据比例获取多折线的点
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的点
   */
  pointAt: function pointAt6(points, t) {
    return pointAtSegments(points, t);
  },
  /**
   * 指定点到多折线的距离
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} x 指定点的 x
   * @param {number} y 指定点的 y
   * @return {number} 点到多折线的距离
   */
  pointDistance: function pointDistance6(points, x, y) {
    return distanceAtSegment(points, x, y);
  },
  /**
   * 根据比例获取多折线的切线角度
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的角度
   */
  tangentAngle: function tangentAngle6(points, t) {
    return angleAtSegments(points, t);
  }
};

// node_modules/.pnpm/@antv+g-lite@1.0.42/node_modules/@antv/g-lite/dist/index.esm.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var PropertySyntax;
(function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
})(PropertySyntax || (PropertySyntax = {}));
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i = 0, arr2 = new Array(len5); i < len5; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var UnitType;
(function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
})(UnitType || (UnitType = {}));
var UnitCategory;
(function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
})(UnitCategory || (UnitCategory = {}));
var ValueRange;
(function(ValueRange2) {
  ValueRange2[ValueRange2["kAll"] = 0] = "kAll";
  ValueRange2[ValueRange2["kNonNegative"] = 1] = "kNonNegative";
  ValueRange2[ValueRange2["kInteger"] = 2] = "kInteger";
  ValueRange2[ValueRange2["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
  ValueRange2[ValueRange2["kPositiveInteger"] = 4] = "kPositiveInteger";
})(ValueRange || (ValueRange = {}));
var Nested;
(function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
})(Nested || (Nested = {}));
var ParenLess;
(function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
})(ParenLess || (ParenLess = {}));
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType;
(function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
})(CSSStyleValueType || (CSSStyleValueType = {}));
var stringToUnitType = function stringToUnitType2(name) {
  return data.find(function(item) {
    return item.name === name;
  }).unit_type;
};
var unitFromName = function unitFromName2(name) {
  if (!name) {
    return UnitType.kUnknown;
  }
  if (name === "number") {
    return UnitType.kNumber;
  }
  if (name === "percent" || name === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = function() {
  function CSSStyleValue2() {
  }
  CSSStyleValue2.isAngle = function isAngle(unit) {
    return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
  };
  CSSStyleValue2.isLength = function isLength(type) {
    return type >= UnitType.kEms && type < UnitType.kDegrees;
  };
  CSSStyleValue2.isRelativeUnit = function isRelativeUnit(type) {
    return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
    type === UnitType.kRems;
  };
  CSSStyleValue2.isTime = function isTime(unit) {
    return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
  };
  var _proto = CSSStyleValue2.prototype;
  _proto.toString = function toString3() {
    return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
  };
  _proto.isNumericValue = function isNumericValue() {
    return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
  };
  return CSSStyleValue2;
}();
var CSSColorValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSColorValue2, _CSSStyleValue);
  function CSSColorValue2(colorSpace) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.colorSpace = void 0;
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  var _proto = CSSColorValue2.prototype;
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  };
  _proto.to = function to(colorSpace) {
    return this;
  };
  return CSSColorValue2;
}(CSSStyleValue);
var GradientType;
(function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
})(GradientType || (GradientType = {}));
var CSSGradientValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSGradientValue2, _CSSStyleValue);
  function CSSGradientValue2(type, value) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.type = void 0;
    _this2.value = void 0;
    _this2.type = type;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSGradientValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSGradientValue2(this.type, this.value);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  };
  return CSSGradientValue2;
}(CSSStyleValue);
var CSSKeywordValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSKeywordValue2, _CSSStyleValue);
  function CSSKeywordValue2(value) {
    var _this2;
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.value = void 0;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSKeywordValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSKeywordValue2(this.value);
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kKeywordType;
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + this.value;
  };
  return CSSKeywordValue2;
}(CSSStyleValue);
function memoize(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var memoized = function memoized2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized2.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized2.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || Map)();
  return memoized;
}
memoize.Cache = Map;
var camelCase = memoize(function(str7) {
  if (str7 === void 0) {
    str7 = "";
  }
  return str7.replace(/-([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
});
var kebabize = function kebabize2(str7) {
  return str7.split("").map(function(letter, idx) {
    return letter.toUpperCase() === letter ? (idx !== 0 ? "-" : "") + letter.toLowerCase() : letter;
  }).join("");
};
function DCHECK(bool) {
  if (!bool) {
    throw new Error();
  }
}
function isFunction(func) {
  return typeof func === "function";
}
function isSymbol(value) {
  return typeof value === "symbol";
}
var FORMAT_ATTR_MAP = {
  d: {
    alias: "path"
  },
  strokeDasharray: {
    alias: "lineDash"
  },
  strokeWidth: {
    alias: "lineWidth"
  },
  textAnchor: {
    alias: "textAlign"
  },
  src: {
    alias: "img"
  }
};
var formatAttributeName = memoize(function(name) {
  var attributeName = camelCase(name);
  var map3 = FORMAT_ATTR_MAP[attributeName];
  attributeName = (map3 === null || map3 === void 0 ? void 0 : map3.alias) || attributeName;
  return attributeName;
});
var formatInfinityOrNaN = function formatInfinityOrNaN2(number2, suffix) {
  if (suffix === void 0) {
    suffix = "";
  }
  var result = "";
  if (!Number.isFinite(number2)) {
    if (number2 > 0)
      result = "infinity";
    else
      result = "-infinity";
  } else {
    DCHECK(Number.isNaN(number2));
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = function(_CSSStyleValue) {
  _inheritsLoose(CSSUnitValue2, _CSSStyleValue);
  function CSSUnitValue2(value, unitOrName) {
    var _this2;
    if (unitOrName === void 0) {
      unitOrName = UnitType.kNumber;
    }
    _this2 = _CSSStyleValue.call(this) || this;
    _this2.unit = void 0;
    _this2.value = void 0;
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value;
    return _this2;
  }
  var _proto = CSSUnitValue2.prototype;
  _proto.clone = function clone7() {
    return new CSSUnitValue2(this.value, this.unit);
  };
  _proto.equals = function equals7(other) {
    var other_unit_value = other;
    return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kUnitType;
  };
  _proto.convertTo = function convertTo(target_unit) {
    if (this.unit === target_unit) {
      return new CSSUnitValue2(this.value, this.unit);
    }
    var canonical_unit = toCanonicalUnit(this.unit);
    if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
      return null;
    }
    var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
    return new CSSUnitValue2(this.value * scale_factor, target_unit);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    var text;
    switch (this.unit) {
      case UnitType.kUnknown:
        break;
      case UnitType.kInteger:
        text = Number(this.value).toFixed(0);
        break;
      case UnitType.kNumber:
      case UnitType.kPercentage:
      case UnitType.kEms:
      case UnitType.kRems:
      case UnitType.kPixels:
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
      case UnitType.kTurns: {
        var kMinInteger = -999999;
        var kMaxInteger = 999999;
        var value = this.value;
        var unit = unitTypeToString(this.unit);
        if (value < kMinInteger || value > kMaxInteger) {
          var _unit = unitTypeToString(this.unit);
          if (!Number.isFinite(value) || Number.isNaN(value)) {
            text = formatInfinityOrNaN(value, _unit);
          } else {
            text = value + (_unit || "");
          }
        } else {
          text = "" + value + unit;
        }
      }
    }
    result += text;
    return result;
  };
  return CSSUnitValue2;
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
var Lpx = new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = function(_CSSColorValue) {
  _inheritsLoose(CSSRGB2, _CSSColorValue);
  function CSSRGB2(r, g, b, alpha, isNone) {
    var _this2;
    if (alpha === void 0) {
      alpha = 1;
    }
    if (isNone === void 0) {
      isNone = false;
    }
    _this2 = _CSSColorValue.call(this, "rgb") || this;
    _this2.r = void 0;
    _this2.g = void 0;
    _this2.b = void 0;
    _this2.alpha = void 0;
    _this2.isNone = void 0;
    _this2.r = r;
    _this2.g = g;
    _this2.b = b;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  var _proto = CSSRGB2.prototype;
  _proto.clone = function clone7() {
    return new CSSRGB2(this.r, this.g, this.b, this.alpha);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + ("rgba(" + this.r + "," + this.g + "," + this.b + "," + this.alpha + ")");
  };
  return CSSRGB2;
}(CSSColorValue);
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n) {
    return new CSSUnitValue(n, "%");
  },
  /**
   * <length>
   */
  px: function px(n) {
    return new CSSUnitValue(n, "px");
  },
  /**
   * <length>
   */
  em: function em(n) {
    return new CSSUnitValue(n, "em");
  },
  rem: function rem(n) {
    return new CSSUnitValue(n, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n) {
    return new CSSUnitValue(n, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n) {
    return new CSSUnitValue(n, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n) {
    return new CSSUnitValue(n, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n) {
    return new CSSUnitValue(n, "turn");
  },
  /**
   * <time>
   */
  s: function s(n) {
    return new CSSUnitValue(n, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n) {
    return new CSSUnitValue(n, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name,
      inh: inherits,
      int: interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name, clazz) {
    runtime.layoutRegistry.registerLayout(name, clazz);
  }
};
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name) {
  if (!keywordCache[name]) {
    keywordCache[name] = new CSSKeywordValue(name);
  }
  return keywordCache[name];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize(function(r, g, b, a) {
  return new CSSRGB(r, g, b, a);
}, function(r, g, b, a) {
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value, unitOrName) {
  if (unitOrName === void 0) {
    unitOrName = UnitType.kNumber;
  }
  return new CSSUnitValue(value, unitOrName);
};
var canvasMap = {};
var defaultCanvasIdCounter = 0;
function cleanExistedCanvas(container, canvas) {
  if (container) {
    var id2 = typeof container === "string" ? container : container.id || defaultCanvasIdCounter++;
    if (canvasMap[id2]) {
      canvasMap[id2].destroy();
    }
    canvasMap[id2] = canvas;
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.style.zIndex);
  var zIndex2 = Number(o2.style.zIndex);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$style;
    var clipPath = (_el$style = el.style) === null || _el$style === void 0 ? void 0 : _el$style.clipPath;
    if (clipPath)
      return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
function copyVec3(a, b) {
  a[0] = b[0];
  a[1] = b[1];
  a[2] = b[2];
  return a;
}
function subVec3(o, a, b) {
  o[0] = a[0] - b[0];
  o[1] = a[1] - b[1];
  o[2] = a[2] - b[2];
  return o;
}
function addVec3(o, a, b) {
  o[0] = a[0] + b[0];
  o[1] = a[1] + b[1];
  o[2] = a[2] + b[2];
  return o;
}
function scaleVec3(o, a, b) {
  o[0] = a[0] * b;
  o[1] = a[1] * b;
  o[2] = a[2] * b;
  return o;
}
function maxVec3(o, a, b) {
  o[0] = Math.max(a[0], b[0]);
  o[1] = Math.max(a[1], b[1]);
  o[2] = Math.max(a[2], b[2]);
  return o;
}
function minVec3(o, a, b) {
  o[0] = Math.min(a[0], b[0]);
  o[1] = Math.min(a[1], b[1]);
  o[2] = Math.min(a[2], b[2]);
  return o;
}
function getAngle3(angle3) {
  if (angle3 === void 0) {
    return 0;
  } else if (angle3 > 360 || angle3 < -360) {
    return angle3 % 360;
  }
  return angle3;
}
function createVec3(x, y, z) {
  if (y === void 0) {
    y = 0;
  }
  if (z === void 0) {
    z = 0;
  }
  if (is_number_default(x)) {
    return vec3_exports.fromValues(x, y, z);
  }
  if (Array.isArray(x) && x.length === 3) {
    return vec3_exports.clone(x);
  }
  return vec3_exports.fromValues(x[0], x[1] || y, x[2] || z);
}
function deg2rad2(deg2) {
  return deg2 * (Math.PI / 180);
}
function rad2deg2(rad2) {
  return rad2 * (180 / Math.PI);
}
function turn2deg(turn2) {
  return 360 * turn2;
}
function getEulerFromQuat(out, quat2) {
  var x = quat2[0];
  var y = quat2[1];
  var z = quat2[2];
  var w = quat2[3];
  var x2 = x * x;
  var y2 = y * y;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x2 + y2 + z2 + w2;
  var test = x * w - y * z;
  if (test > 0.499995 * unit) {
    out[0] = Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x * z - w * y));
    out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m) {
  var x;
  var z;
  var halfPi = Math.PI * 0.5;
  var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m), sx = _mat4$getScaling[0], sy = _mat4$getScaling[1], sz = _mat4$getScaling[2];
  var y = Math.asin(-m[2] / sx);
  if (y < halfPi) {
    if (y > -halfPi) {
      x = Math.atan2(m[6] / sy, m[10] / sz);
      z = Math.atan2(m[1] / sx, m[0] / sx);
    } else {
      z = 0;
      x = -Math.atan2(m[4] / sy, m[5] / sy);
    }
  } else {
    z = 0;
    x = Math.atan2(m[4] / sy, m[5] / sy);
  }
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  } else {
    return getEulerFromQuat(out, quat2);
  }
}
function fromRotationTranslationScale2(rotation, x, y, scaleX, scaleY) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var x = 2 * near / (right - left);
  var y = 2 * near / (top - bottom);
  var a = (right + left) / (right - left);
  var b = (top + bottom) / (top - bottom);
  var c = -(far + near) / (far - near);
  var d4 = -2 * far * near / (far - near);
  out[0] = x;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y;
  out[6] = 0;
  out[7] = 0;
  out[8] = a;
  out[9] = b;
  out[10] = c;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d4;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    row0x *= 1 / scalingX;
    row0y *= 1 / scalingX;
  }
  if (scalingY) {
    row1x *= 1 / scalingY;
    row1y *= 1 / scalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle3 = rad2deg2(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle3];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix, translation, scale8, skew, perspective2, quaternion) {
  if (!normalize5(tmp, matrix))
    return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8)
    return false;
  var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret)
      return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale8[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew[0] = vec3_exports.dot(row[0], row[1]);
  combine(row[1], row[1], row[0], 1, -skew[0]);
  scale8[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew[0] /= scale8[1];
  skew[1] = vec3_exports.dot(row[0], row[2]);
  combine(row[2], row[2], row[0], 1, -skew[1]);
  skew[2] = vec3_exports.dot(row[1], row[2]);
  combine(row[2], row[2], row[1], 1, -skew[2]);
  scale8[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew[1] /= scale8[2];
  skew[2] /= scale8[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale8[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2];
  return true;
}
function normalize5(out, mat) {
  var m44 = mat[15];
  if (m44 === 0)
    return false;
  var scale8 = 1 / m44;
  for (var i = 0; i < 16; i++) {
    out[i] = mat[i] * scale8;
  }
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine(out, a, b, scale1, scale22) {
  out[0] = a[0] * scale1 + b[0] * scale22;
  out[1] = a[1] * scale1 + b[1] * scale22;
  out[2] = a[2] * scale1 + b[2] * scale22;
}
var tmpMat4 = mat4_exports.create();
function parsedTransformToMat4(transform, object) {
  if (transform && transform.length) {
    var defX = 0;
    var defY = 0;
    if (object) {
      defX = object.parsedStyle.defX || 0;
      defY = object.parsedStyle.defY || 0;
      object.resetLocalTransform();
      object.setLocalPosition(defX, defY);
    } else {
      object = new DisplayObject({});
    }
    transform.forEach(function(parsed) {
      var t = parsed.t, d4 = parsed.d;
      if (t === "scale") {
        var newScale = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1, 1];
        object.scaleLocal(newScale[0], newScale[1], 1);
      } else if (t === "scalex") {
        var _newScale = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(_newScale[0], 1, 1);
      } else if (t === "scaley") {
        var _newScale2 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(1, _newScale2[0], 1);
      } else if (t === "scalez") {
        var _newScale3 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1];
        object.scaleLocal(1, 1, _newScale3[0]);
      } else if (t === "scale3d") {
        var _newScale4 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [1, 1, 1];
        object.scaleLocal(_newScale4[0], _newScale4[1], _newScale4[2]);
      } else if (t === "translate") {
        var newTranslation = d4 || [Opx, Opx];
        object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
      } else if (t === "translatex") {
        var _newTranslation = d4 || [Opx];
        object.translateLocal(_newTranslation[0].value, 0, 0);
      } else if (t === "translatey") {
        var _newTranslation2 = d4 || [Opx];
        object.translateLocal(0, _newTranslation2[0].value, 0);
      } else if (t === "translatez") {
        var _newTranslation3 = d4 || [Opx];
        object.translateLocal(0, 0, _newTranslation3[0].value);
      } else if (t === "translate3d") {
        var _newTranslation4 = d4 || [Opx, Opx, Opx];
        object.translateLocal(_newTranslation4[0].value, _newTranslation4[1].value, _newTranslation4[2].value);
      } else if (t === "rotate") {
        var newAngles = d4 || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
      } else if (t === "rotatex") {
        var _newAngles = d4 || [Odeg];
        object.rotateLocal(convertAngleUnit(_newAngles[0]), 0, 0);
      } else if (t === "rotatey") {
        var _newAngles2 = d4 || [Odeg];
        object.rotateLocal(0, convertAngleUnit(_newAngles2[0]), 0);
      } else if (t === "rotatez") {
        var _newAngles3 = d4 || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(_newAngles3[0]));
      } else if (t === "rotate3d")
        ;
      else if (t === "skew") {
        var newSkew = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0, 0];
        object.setLocalSkew(deg2rad2(newSkew[0]), deg2rad2(newSkew[1]));
      } else if (t === "skewx") {
        var _newSkew = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0];
        object.setLocalSkew(deg2rad2(_newSkew[0]), object.getLocalSkew()[1]);
      } else if (t === "skewy") {
        var _newSkew2 = (d4 === null || d4 === void 0 ? void 0 : d4.map(function(s2) {
          return s2.value;
        })) || [0];
        object.setLocalSkew(object.getLocalSkew()[0], deg2rad2(_newSkew2[0]));
      } else if (t === "matrix") {
        var _d$map = d4.map(function(s2) {
          return s2.value;
        }), a = _d$map[0], b = _d$map[1], c = _d$map[2], dd = _d$map[3], tx = _d$map[4], ty = _d$map[5];
        object.setLocalTransform(mat4_exports.set(tmpMat4, a, b, 0, 0, c, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
      } else if (t === "matrix3d") {
        mat4_exports.set.apply(mat4_exports, [tmpMat4].concat(d4.map(function(s2) {
          return s2.value;
        })));
        tmpMat4[12] += defX;
        tmpMat4[13] += defY;
        object.setLocalTransform(tmpMat4);
      }
    });
  }
  return object.getLocalTransform();
}
function colorStopToString(colorStop) {
  var type = colorStop.type, value = colorStop.value;
  if (type === "hex") {
    return "#" + value;
  } else if (type === "literal") {
    return value;
  } else if (type === "rgb") {
    return "rgb(" + value.join(",") + ")";
  } else {
    return "rgba(" + value.join(",") + ")";
  }
}
var parseGradient = function() {
  var tokens = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error(msg) {
    throw new Error(input + ": " + msg);
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle2 = match("shape", /^(circle)/i, 0);
    if (circle2) {
      circle2.style = matchLength() || matchExtentKeyword();
    }
    return circle2;
  }
  function matchEllipse() {
    var ellipse2 = match("shape", /^(ellipse)/i, 0);
    if (ellipse2) {
      ellipse2.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse2;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size2) {
    input = input.substring(size2);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(width, height, angle3) {
  var rad2 = deg2rad2(angle3.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length14 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
  var x1 = rcx - Math.cos(rad2) * length14 / 2;
  var y1 = rcy - Math.sin(rad2) * length14 / 2;
  var x2 = rcx + Math.cos(rad2) * length14 / 2;
  var y2 = rcy + Math.sin(rad2) * length14 / 2;
  return {
    x1,
    y1,
    x2,
    y2
  };
}
function computeRadialGradient(width, height, cx, cy, size2) {
  var x = cx.value;
  var y = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y = cy.value / 100 * height;
  }
  var r = Math.max(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
  if (size2) {
    if (size2 instanceof CSSUnitValue) {
      r = size2.value;
    } else if (size2 instanceof CSSKeywordValue) {
      if (size2.value === "closest-side") {
        r = Math.min(x, width - x, y, height - y);
      } else if (size2.value === "farthest-side") {
        r = Math.max(x, width - x, y, height - y);
      } else if (size2.value === "closest-corner") {
        r = Math.min(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
      }
    }
  }
  return {
    x,
    y,
    r
  };
}
var Shape;
(function(Shape3) {
  Shape3["GROUP"] = "g";
  Shape3["CIRCLE"] = "circle";
  Shape3["ELLIPSE"] = "ellipse";
  Shape3["IMAGE"] = "image";
  Shape3["RECT"] = "rect";
  Shape3["LINE"] = "line";
  Shape3["POLYLINE"] = "polyline";
  Shape3["POLYGON"] = "polygon";
  Shape3["TEXT"] = "text";
  Shape3["PATH"] = "path";
  Shape3["HTML"] = "html";
  Shape3["MESH"] = "mesh";
})(Shape || (Shape = {}));
function getOrCalculatePathTotalLength(path) {
  if (path.parsedStyle.path.totalLength === 0) {
    path.parsedStyle.path.totalLength = getTotalLength(path.parsedStyle.path.absolutePath);
  }
  return path.parsedStyle.path.totalLength;
}
function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box10 = void 0;
    switch (segment.command) {
      case "Q":
        box10 = quadratic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box10 = cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box10 = arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box10) {
      segment.box = box10;
      xArr.push(box10.x, box10.x + box10.width);
      yArr.push(box10.y, box10.y + box10.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (_currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
var angleBetween2 = function angleBetween3(v0, v1) {
  var p = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad2(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx = Math.sqrt(radiiCheck) * rx;
    ry = Math.sqrt(radiiCheck) * ry;
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween2({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween2(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle3 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle3);
  var ellipseComponentY = ry * Math.sin(angle3);
  var point = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle3,
    ellipticalArcCenter: center,
    resultantRx: rx,
    resultantRy: ry
  };
  return point;
};
function path2Segments(path) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio, sign) {
  if (sign === void 0) {
    sign = true;
  }
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist4 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist4,
    y: -yDist / dist4
  };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad2(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform) {
  var _object$parsedStyle = object.parsedStyle, _object$parsedStyle$d = _object$parsedStyle.defX, defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d, _object$parsedStyle$d2 = _object$parsedStyle.defY, defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
  return commands.reduce(function(prev, cur) {
    var path = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(p, p, transform);
      }
      path = "" + cur[0] + p[0] + "," + p[1];
    } else if (cur[0] === "Z") {
      path = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var p2 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      var p3 = vec3_exports.fromValues(cur[5] - defX, cur[6] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(p1, p1, transform);
        vec3_exports.transformMat4(p2, p2, transform);
        vec3_exports.transformMat4(p3, p3, transform);
      }
      path = "" + cur[0] + p1[0] + "," + p1[1] + "," + p2[0] + "," + p2[1] + "," + p3[0] + "," + p3[1];
    } else if (cur[0] === "A") {
      var c = vec3_exports.fromValues(cur[6] - defX, cur[7] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(c, c, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "," + cur[5] + "," + c[0] + "," + c[1];
    } else if (cur[0] === "Q") {
      var _p = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var _p2 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      if (transform) {
        vec3_exports.transformMat4(_p, _p, transform);
        vec3_exports.transformMat4(_p2, _p2, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "}";
    }
    return prev += path;
  }, "");
}
function lineToCommands(x1, y1, x2, y2) {
  return [["M", x1, y1], ["L", x2, y2]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left = cx - rx;
  var right = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [["M", left, cy], ["C", left, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right, cy - dy, right, cy], ["C", right, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left, cy + dy, left, cy], ["Z"]];
}
function polygonToCommands(points, closed) {
  var result = points.map(function(point, i) {
    return [i === 0 ? "M" : "L", point[0], point[1]];
  });
  if (closed) {
    result.push(["Z"]);
  }
  return result;
}
function rectToCommands(width, height, x, y, radius) {
  if (radius) {
    var tlr = radius[0], trr = radius[1], brr = radius[2], blr = radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [["M", signX * tlr + x, y], ["L", width - signX * trr + x, y], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x, signY * trr + y] : null, ["L", width + x, height - signY * brr + y], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x - signX * brr, height + y] : null, ["L", x + signX * blr, height + y], blr ? ["A", blr, blr, 0, 0, sweepFlag, x, height + y - signY * blr] : null, ["L", x, signY * tlr + y], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x, y] : null, ["Z"]].filter(function(command) {
      return command;
    });
  }
  return [["M", x, y], ["L", x + width, y], ["L", x + width, y + height], ["L", x, y + height], ["Z"]];
}
function convertToPath(object, transform) {
  if (transform === void 0) {
    transform = object.getLocalTransform();
  }
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _object$parsedStyle2 = object.parsedStyle, x1 = _object$parsedStyle2.x1, y1 = _object$parsedStyle2.y1, x2 = _object$parsedStyle2.x2, y2 = _object$parsedStyle2.y2;
      commands = lineToCommands(x1, y1, x2, y2);
      break;
    case Shape.CIRCLE: {
      var _object$parsedStyle3 = object.parsedStyle, r = _object$parsedStyle3.r, cx = _object$parsedStyle3.cx, cy = _object$parsedStyle3.cy;
      commands = ellipseToCommands(r, r, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _object$parsedStyle4 = object.parsedStyle, rx = _object$parsedStyle4.rx, ry = _object$parsedStyle4.ry, _cx = _object$parsedStyle4.cx, _cy = _object$parsedStyle4.cy;
      commands = ellipseToCommands(rx, ry, _cx, _cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _object$parsedStyle5 = object.parsedStyle, width = _object$parsedStyle5.width, height = _object$parsedStyle5.height, x = _object$parsedStyle5.x, y = _object$parsedStyle5.y, radius = _object$parsedStyle5.radius;
      var hasRadius = radius && radius.some(function(r2) {
        return r2 !== 0;
      });
      commands = rectToCommands(width, height, x, y, hasRadius && radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.path.absolutePath;
      commands = [].concat(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform);
  }
}
function isFillOrStrokeAffected(pointerEvents, fill, stroke) {
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var CALL_DELEGATE = function CALL_DELEGATE2() {
  this.call = this._createCall("sync");
  return this.call.apply(this, arguments);
};
var CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE2() {
  this.callAsync = this._createCall("async");
  return this.callAsync.apply(this, arguments);
};
var PROMISE_DELEGATE = function PROMISE_DELEGATE2() {
  this.promise = this._createCall("promise");
  return this.promise.apply(this, arguments);
};
var Hook = function() {
  function Hook2(args, name) {
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    this.name = void 0;
    this.taps = void 0;
    this.promise = void 0;
    this._promise = void 0;
    this._args = args;
    this.name = name;
    this.taps = [];
    this.interceptors = [];
    this._call = CALL_DELEGATE;
    this.call = CALL_DELEGATE;
    this._callAsync = CALL_ASYNC_DELEGATE;
    this.callAsync = CALL_ASYNC_DELEGATE;
    this._promise = PROMISE_DELEGATE;
    this.promise = PROMISE_DELEGATE;
    this._x = void 0;
  }
  var _proto = Hook2.prototype;
  _proto.compile = function compile(options) {
    throw new Error("Abstract: should be overridden");
  };
  _proto._createCall = function _createCall(type) {
    return this.compile({
      taps: this.taps,
      interceptors: this.interceptors,
      args: this._args,
      type
    });
  };
  _proto._tap = function _tap(type, options, fn) {
    if (typeof options === "string") {
      options = {
        name: options.trim()
      };
    } else if (typeof options !== "object" || options === null) {
      throw new Error("Invalid tap options");
    }
    if (typeof options.name !== "string" || options.name === "") {
      throw new Error("Missing name for tap");
    }
    options = Object.assign({
      type,
      fn
    }, options);
    options = this._runRegisterInterceptors(options);
    this._insert(options);
  };
  _proto.tap = function tap(options, fn) {
    this._tap("sync", options, fn);
  };
  _proto.tapAsync = function tapAsync(options, fn) {
    this._tap("async", options, fn);
  };
  _proto.tapPromise = function tapPromise(options, fn) {
    this._tap("promise", options, fn);
  };
  _proto._runRegisterInterceptors = function _runRegisterInterceptors(options) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.interceptors), _step; !(_step = _iterator()).done; ) {
      var interceptor = _step.value;
      if (interceptor.register) {
        var newOptions = interceptor.register(options);
        if (newOptions !== void 0) {
          options = newOptions;
        }
      }
    }
    return options;
  };
  _proto.withOptions = function withOptions(options) {
    var _this2 = this;
    var mergeOptions = function mergeOptions2(opt) {
      return Object.assign({}, options, typeof opt === "string" ? {
        name: opt
      } : opt);
    };
    return {
      name: this.name,
      tap: function tap(opt, fn) {
        return _this2.tap(mergeOptions(opt), fn);
      },
      tapAsync: function tapAsync(opt, fn) {
        return _this2.tapAsync(mergeOptions(opt), fn);
      },
      tapPromise: function tapPromise(opt, fn) {
        return _this2.tapPromise(mergeOptions(opt), fn);
      },
      // intercept: (interceptor) => this.intercept(interceptor),
      isUsed: function isUsed() {
        return _this2.isUsed();
      },
      withOptions: function withOptions2(opt) {
        return _this2.withOptions(mergeOptions(opt));
      }
    };
  };
  _proto.isUsed = function isUsed() {
    return this.taps.length > 0 || this.interceptors.length > 0;
  };
  _proto._resetCompilation = function _resetCompilation() {
    this.call = this._call;
    this.callAsync = this._callAsync;
    this.promise = this._promise;
  };
  _proto._insert = function _insert(item) {
    this._resetCompilation();
    var before;
    if (typeof item.before === "string") {
      before = /* @__PURE__ */ new Set([item.before]);
    } else if (Array.isArray(item.before)) {
      before = new Set(item.before);
    }
    var stage = 0;
    if (typeof item.stage === "number") {
      stage = item.stage;
    }
    var i = this.taps.length;
    while (i > 0) {
      i--;
      var x = this.taps[i];
      this.taps[i + 1] = x;
      var xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) {
          continue;
        }
      }
      if (xStage > stage) {
        continue;
      }
      i++;
      break;
    }
    this.taps[i] = item;
  };
  return Hook2;
}();
var HookCodeFactory = function() {
  function HookCodeFactory2(config) {
    this.config = config;
    this.options = void 0;
    this._args = void 0;
  }
  var _proto = HookCodeFactory2.prototype;
  _proto.create = function create8(options) {
    this.init(options);
    var fn;
    switch (this.options.type) {
      case "sync":
        fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "throw " + err + ";\n";
          },
          onResult: function onResult(result) {
            return "return " + result + ";\n";
          },
          resultReturns: true,
          onDone: function onDone() {
            return "";
          },
          rethrowIfPossible: true
        }));
        break;
      case "async":
        fn = new Function(this.args({
          after: "_callback"
        }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "_callback(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_callback(null, " + result + ");\n";
          },
          onDone: function onDone() {
            return "_callback();\n";
          }
        }));
        break;
      case "promise":
        var errorHelperUsed = false;
        var content = this.contentWithInterceptors({
          onError: function onError(err) {
            errorHelperUsed = true;
            return "_error(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_resolve(" + result + ");\n";
          },
          onDone: function onDone() {
            return "_resolve();\n";
          }
        });
        var code = "";
        code += '"use strict";\n';
        code += this.header();
        code += "return new Promise((function(_resolve, _reject) {\n";
        if (errorHelperUsed) {
          code += "var _sync = true;\n";
          code += "function _error(_err) {\n";
          code += "if(_sync)\n";
          code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
          code += "else\n";
          code += "_reject(_err);\n";
          code += "};\n";
        }
        code += content;
        if (errorHelperUsed) {
          code += "_sync = false;\n";
        }
        code += "}));\n";
        fn = new Function(this.args(), code);
        break;
    }
    this.deinit();
    return fn;
  };
  _proto.setup = function setup(instance, options) {
    instance._x = options.taps.map(function(t) {
      return t.fn;
    });
  };
  _proto.init = function init(options) {
    this.options = options;
    this._args = options.args.slice();
  };
  _proto.deinit = function deinit() {
    this.options = void 0;
    this._args = void 0;
  };
  _proto.contentWithInterceptors = function contentWithInterceptors(options) {
    var _this2 = this;
    if (this.options.interceptors.length > 0) {
      var onError = options.onError;
      var onResult = options.onResult;
      var onDone = options.onDone;
      var code = "";
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.call) {
          code += this.getInterceptor(i) + ".call(" + this.args({
            before: interceptor.context ? "_context" : void 0
          }) + ");\n";
        }
      }
      code += this.content(Object.assign(options, {
        onError: onError && function(err) {
          var code2 = "";
          for (var _i = 0; _i < _this2.options.interceptors.length; _i++) {
            var _interceptor = _this2.options.interceptors[_i];
            if (_interceptor.error) {
              code2 += _this2.getInterceptor(_i) + ".error(" + err + ");\n";
            }
          }
          code2 += onError(err);
          return code2;
        },
        onResult: onResult && function(result) {
          var code2 = "";
          for (var _i2 = 0; _i2 < _this2.options.interceptors.length; _i2++) {
            var _interceptor2 = _this2.options.interceptors[_i2];
            if (_interceptor2.result) {
              code2 += _this2.getInterceptor(_i2) + ".result(" + result + ");\n";
            }
          }
          code2 += onResult(result);
          return code2;
        },
        onDone: onDone && function() {
          var code2 = "";
          for (var _i3 = 0; _i3 < _this2.options.interceptors.length; _i3++) {
            var _interceptor3 = _this2.options.interceptors[_i3];
            if (_interceptor3.done) {
              code2 += _this2.getInterceptor(_i3) + ".done();\n";
            }
          }
          code2 += onDone();
          return code2;
        }
      }));
      return code;
    } else {
      return this.content(options);
    }
  };
  _proto.header = function header() {
    var code = "";
    if (this.needContext()) {
      code += "var _context = {};\n";
    } else {
      code += "var _context;\n";
    }
    code += "var _x = this._x;\n";
    if (this.options.interceptors.length > 0) {
      code += "var _taps = this.taps;\n";
      code += "var _interceptors = this.interceptors;\n";
    }
    return code;
  };
  _proto.needContext = function needContext() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.options.taps), _step; !(_step = _iterator()).done; ) {
      var tap = _step.value;
      if (tap.context)
        return true;
    }
    return false;
  };
  _proto.callTap = function callTap(tapIndex, _ref) {
    var onError = _ref.onError, onResult = _ref.onResult, onDone = _ref.onDone, rethrowIfPossible = _ref.rethrowIfPossible;
    var code = "";
    var hasTapCached = false;
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.tap) {
        if (!hasTapCached) {
          code += "var _tap" + tapIndex + " = " + this.getTap(tapIndex) + ";\n";
          hasTapCached = true;
        }
        code += this.getInterceptor(i) + ".tap(" + (interceptor.context ? "_context, " : "") + "_tap" + tapIndex + ");\n";
      }
    }
    code += "var _fn" + tapIndex + " = " + this.getTapFn(tapIndex) + ";\n";
    var tap = this.options.taps[tapIndex];
    switch (tap.type) {
      case "sync":
        if (!rethrowIfPossible) {
          code += "var _hasError" + tapIndex + " = false;\n";
          code += "try {\n";
        }
        if (onResult) {
          code += "var _result" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
            before: tap.context ? "_context" : void 0
          }) + ");\n";
        } else {
          code += "_fn" + tapIndex + "(" + this.args({
            before: tap.context ? "_context" : void 0
          }) + ");\n";
        }
        if (!rethrowIfPossible) {
          code += "} catch(_err) {\n";
          code += "_hasError" + tapIndex + " = true;\n";
          code += onError("_err");
          code += "}\n";
          code += "if(!_hasError" + tapIndex + ") {\n";
        }
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        if (!rethrowIfPossible) {
          code += "}\n";
        }
        break;
      case "async":
        var cbCode = "";
        if (onResult)
          cbCode += "(function(_err" + tapIndex + ", _result" + tapIndex + ") {\n";
        else
          cbCode += "(function(_err" + tapIndex + ") {\n";
        cbCode += "if(_err" + tapIndex + ") {\n";
        cbCode += onError("_err" + tapIndex);
        cbCode += "} else {\n";
        if (onResult) {
          cbCode += onResult("_result" + tapIndex);
        }
        if (onDone) {
          cbCode += onDone();
        }
        cbCode += "}\n";
        cbCode += "})";
        code += "_fn" + tapIndex + "(" + this.args({
          before: tap.context ? "_context" : void 0,
          after: cbCode
        }) + ");\n";
        break;
      case "promise":
        code += "var _hasResult" + tapIndex + " = false;\n";
        code += "var _promise" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
          before: tap.context ? "_context" : void 0
        }) + ");\n";
        code += "if (!_promise" + tapIndex + " || !_promise" + tapIndex + ".then)\n";
        code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise" + tapIndex + " + ')');\n";
        code += "_promise" + tapIndex + ".then((function(_result" + tapIndex + ") {\n";
        code += "_hasResult" + tapIndex + " = true;\n";
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        code += "}), function(_err" + tapIndex + ") {\n";
        code += "if(_hasResult" + tapIndex + ") throw _err" + tapIndex + ";\n";
        code += onError("_err" + tapIndex);
        code += "});\n";
        break;
    }
    return code;
  };
  _proto.callTapsSeries = function callTapsSeries(_ref2) {
    var _this2 = this;
    var _onError = _ref2.onError, onResult = _ref2.onResult, resultReturns = _ref2.resultReturns, onDone = _ref2.onDone, doneReturns = _ref2.doneReturns, rethrowIfPossible = _ref2.rethrowIfPossible;
    if (this.options.taps.length === 0)
      return onDone();
    var firstAsync = this.options.taps.findIndex(function(t) {
      return t.type !== "sync";
    });
    var somethingReturns = resultReturns || doneReturns;
    var code = "";
    var current = onDone;
    var unrollCounter = 0;
    var _loop = function _loop2(j2) {
      var i = j2;
      var unroll = current !== onDone && (_this2.options.taps[i].type !== "sync" || unrollCounter++ > 20);
      if (unroll) {
        unrollCounter = 0;
        code += "function _next" + i + "() {\n";
        code += current();
        code += "}\n";
        current = function current2() {
          return (somethingReturns ? "return " : "") + "_next" + i + "();\n";
        };
      }
      var done = current;
      var doneBreak = function doneBreak2(skipDone) {
        if (skipDone)
          return "";
        return onDone();
      };
      var content = _this2.callTap(i, {
        onError: function onError(error) {
          return _onError(i, error, done, doneBreak);
        },
        onResult: onResult && function(result) {
          return onResult(i, result, done, doneBreak);
        },
        onDone: !onResult && done,
        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
      });
      current = function current2() {
        return content;
      };
    };
    for (var j = this.options.taps.length - 1; j >= 0; j--) {
      _loop(j);
    }
    code += current();
    return code;
  };
  _proto.callTapsLooping = function callTapsLooping(_ref3) {
    var onError = _ref3.onError, onDone = _ref3.onDone, rethrowIfPossible = _ref3.rethrowIfPossible;
    if (this.options.taps.length === 0)
      return onDone();
    var syncOnly = this.options.taps.every(function(t) {
      return t.type === "sync";
    });
    var code = "";
    if (!syncOnly) {
      code += "var _looper = (function() {\n";
      code += "var _loopAsync = false;\n";
    }
    code += "var _loop;\n";
    code += "do {\n";
    code += "_loop = false;\n";
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.loop) {
        code += this.getInterceptor(i) + ".loop(" + this.args({
          before: interceptor.context ? "_context" : void 0
        }) + ");\n";
      }
    }
    code += this.callTapsSeries({
      onError,
      onResult: function onResult(i2, result, next, doneBreak) {
        var code2 = "";
        code2 += "if(" + result + " !== undefined) {\n";
        code2 += "_loop = true;\n";
        if (!syncOnly)
          code2 += "if(_loopAsync) _looper();\n";
        code2 += doneBreak(true);
        code2 += "} else {\n";
        code2 += next();
        code2 += "}\n";
        return code2;
      },
      onDone: onDone && function() {
        var code2 = "";
        code2 += "if(!_loop) {\n";
        code2 += onDone();
        code2 += "}\n";
        return code2;
      },
      rethrowIfPossible: rethrowIfPossible && syncOnly
    });
    code += "} while(_loop);\n";
    if (!syncOnly) {
      code += "_loopAsync = true;\n";
      code += "});\n";
      code += "_looper();\n";
    }
    return code;
  };
  _proto.callTapsParallel = function callTapsParallel(_ref4) {
    var _this3 = this;
    var _onError2 = _ref4.onError, onResult = _ref4.onResult, onDone = _ref4.onDone, rethrowIfPossible = _ref4.rethrowIfPossible, _ref4$onTap = _ref4.onTap, onTap = _ref4$onTap === void 0 ? function(i2, run) {
      return run();
    } : _ref4$onTap;
    if (this.options.taps.length <= 1) {
      return this.callTapsSeries({
        onError: _onError2,
        onResult,
        onDone,
        rethrowIfPossible
      });
    }
    var code = "";
    code += "do {\n";
    code += "var _counter = " + this.options.taps.length + ";\n";
    if (onDone) {
      code += "var _done = (function() {\n";
      code += onDone();
      code += "});\n";
    }
    var _loop2 = function _loop22(i2) {
      var done = function done2() {
        if (onDone)
          return "if(--_counter === 0) _done();\n";
        else
          return "--_counter;";
      };
      var doneBreak = function doneBreak2(skipDone) {
        if (skipDone || !onDone)
          return "_counter = 0;\n";
        else
          return "_counter = 0;\n_done();\n";
      };
      code += "if(_counter <= 0) break;\n";
      code += onTap(i2, function() {
        return _this3.callTap(i2, {
          onError: function onError(error) {
            var code2 = "";
            code2 += "if(_counter > 0) {\n";
            code2 += _onError2(i2, error, done, doneBreak);
            code2 += "}\n";
            return code2;
          },
          onResult: onResult && function(result) {
            var code2 = "";
            code2 += "if(_counter > 0) {\n";
            code2 += onResult(i2, result, done, doneBreak);
            code2 += "}\n";
            return code2;
          },
          onDone: !onResult && function() {
            return done();
          },
          rethrowIfPossible
        });
      }, done, doneBreak);
    };
    for (var i = 0; i < this.options.taps.length; i++) {
      _loop2(i);
    }
    code += "} while(false);\n";
    return code;
  };
  _proto.args = function args(_temp) {
    var _ref5 = _temp === void 0 ? {} : _temp, before = _ref5.before, after = _ref5.after;
    var allArgs = this._args;
    if (before)
      allArgs = [before].concat(allArgs);
    if (after)
      allArgs = allArgs.concat(after);
    if (allArgs.length === 0) {
      return "";
    } else {
      return allArgs.join(", ");
    }
  };
  _proto.getTapFn = function getTapFn(idx) {
    return "_x[" + idx + "]";
  };
  _proto.getTap = function getTap(idx) {
    return "_taps[" + idx + "]";
  };
  _proto.getInterceptor = function getInterceptor(idx) {
    return "_interceptors[" + idx + "]";
  };
  return HookCodeFactory2;
}();
var AsyncParallelHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(AsyncParallelHookCodeFactory2, _HookCodeFactory);
  function AsyncParallelHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncParallelHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError, onDone = _ref.onDone;
    return this.callTapsParallel({
      onError: function onError(i, err, done, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onDone
    });
  };
  return AsyncParallelHookCodeFactory2;
}(HookCodeFactory);
var factory = new AsyncParallelHookCodeFactory();
var COMPILE = function COMPILE2(options) {
  factory.setup(this, options);
  return factory.create(options);
};
var AsyncParallelHook = function(_Hook) {
  _inheritsLoose(AsyncParallelHook2, _Hook);
  function AsyncParallelHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.compile = COMPILE;
    _this2._call = void 0;
    _this2.call = void 0;
    return _this2;
  }
  return AsyncParallelHook2;
}(Hook);
var AsyncSeriesWaterfallHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(AsyncSeriesWaterfallHookCodeFactory2, _HookCodeFactory);
  function AsyncSeriesWaterfallHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncSeriesWaterfallHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _this2 = this;
    var _onError = _ref.onError, onResult = _ref.onResult, onDone = _ref.onDone;
    return this.callTapsSeries({
      onError: function onError(i, err, next, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onResult: function onResult2(i, result, next) {
        var code = "";
        code += "if(" + result + " !== undefined) {\n";
        code += _this2._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone2() {
        return onResult(_this2._args[0]);
      }
    });
  };
  return AsyncSeriesWaterfallHookCodeFactory2;
}(HookCodeFactory);
var factory$1 = new AsyncSeriesWaterfallHookCodeFactory();
var COMPILE$1 = function COMPILE3(options) {
  factory$1.setup(this, options);
  return factory$1.create(options);
};
var AsyncSeriesWaterfallHook = function(_Hook) {
  _inheritsLoose(AsyncSeriesWaterfallHook2, _Hook);
  function AsyncSeriesWaterfallHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.compile = COMPILE$1;
    _this2._call = void 0;
    _this2.call = void 0;
    return _this2;
  }
  return AsyncSeriesWaterfallHook2;
}(Hook);
var SyncHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(SyncHookCodeFactory2, _HookCodeFactory);
  function SyncHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError, onDone = _ref.onDone, rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onDone,
      rethrowIfPossible
    });
  };
  return SyncHookCodeFactory2;
}(HookCodeFactory);
var factory$2 = new SyncHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC2() {
  throw new Error("tapAsync is not supported on a SyncHook");
};
var TAP_PROMISE = function TAP_PROMISE2() {
  throw new Error("tapPromise is not supported on a SyncHook");
};
var COMPILE$2 = function COMPILE4(options) {
  factory$2.setup(this, options);
  return factory$2.create(options);
};
var SyncHook = function(_Hook) {
  _inheritsLoose(SyncHook2, _Hook);
  function SyncHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.tapAsync = TAP_ASYNC;
    _this2.tapPromise = TAP_PROMISE;
    _this2.compile = COMPILE$2;
    return _this2;
  }
  return SyncHook2;
}(Hook);
var SyncWaterfallHookCodeFactory = function(_HookCodeFactory) {
  _inheritsLoose(SyncWaterfallHookCodeFactory2, _HookCodeFactory);
  function SyncWaterfallHookCodeFactory2() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncWaterfallHookCodeFactory2.prototype;
  _proto.content = function content(_ref) {
    var _this2 = this;
    var _onError = _ref.onError, onResult = _ref.onResult, resultReturns = _ref.resultReturns, rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onResult: function onResult2(i, result, next) {
        var code = "";
        code += "if(" + result + " !== undefined) {\n";
        code += _this2._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone() {
        return onResult(_this2._args[0]);
      },
      doneReturns: resultReturns,
      rethrowIfPossible
    });
  };
  return SyncWaterfallHookCodeFactory2;
}(HookCodeFactory);
var factory$3 = new SyncWaterfallHookCodeFactory();
var TAP_ASYNC$1 = function TAP_ASYNC3() {
  throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
var TAP_PROMISE$1 = function TAP_PROMISE3() {
  throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
var COMPILE$3 = function COMPILE5(options) {
  factory$3.setup(this, options);
  return factory$3.create(options);
};
var SyncWaterfallHook = function(_SyncHook) {
  _inheritsLoose(SyncWaterfallHook2, _SyncHook);
  function SyncWaterfallHook2(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = void 0;
    }
    _this2 = _SyncHook.call(this, args, name) || this;
    _this2.tapAsync = TAP_ASYNC$1;
    _this2.tapPromise = TAP_PROMISE$1;
    _this2.compile = COMPILE$3;
    return _this2;
  }
  return SyncWaterfallHook2;
}(SyncHook);
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function toFontString(attributes) {
  var fontSize = attributes.fontSize, fontFamily = attributes.fontFamily, fontStyle = attributes.fontStyle, fontVariant = attributes.fontVariant, fontWeight = attributes.fontWeight;
  var fontSizeString = is_number_default(fontSize) && fontSize + "px" || "16px";
  var fontFamilies = is_string_default(fontFamily) ? fontFamily.split(",") : [fontFamily];
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    var _fontFamily = fontFamilies[i].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"' + _fontFamily + '"';
    }
    fontFamilies[i] = _fontFamily;
  }
  return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = typeof self === "object" && self.self == self ? self : (
  // @ts-ignore
  typeof global === "object" && global.global == global ? (
    // @ts-ignore
    global
  ) : {}
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id2 = uniqueId();
  reservedCBs[id2] = callback;
  if (Object.keys(reservedCBs).length > 1)
    return id2;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id2;
};
var polyfillCaf = function polyfillCaf2(id2) {
  delete reservedCBs[id2];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillRaf;
  if (vp2 === "")
    return root["requestAnimationFrame"];
  return root[vp2 + "RequestAnimationFrame"];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillCaf;
  if (vp2 === "")
    return root["cancelAnimationFrame"];
  return root[vp2 + "CancelAnimationFrame"] || root[vp2 + "CancelRequestAnimationFrame"];
};
var find = function find2(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i]))
      return arr[i];
    i = i + 1;
  }
};
var vp = find(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length14 = colorStops.length;
  colorStops[length14 - 1].length = (_colorStops$length = colorStops[length14 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length14 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length14; i++) {
    var _colorStops$i$length;
    var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!is_nil_default(offset) && !is_nil_default(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++) {
        colorStops[previousIndex + j].length = {
          type: "%",
          value: "" + (previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
        };
      }
      previousIndex = i;
      previousOffset = Number(offset);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize(function(orientation) {
  var angle3;
  if (orientation.type === "angular") {
    angle3 = Number(orientation.value);
  } else {
    angle3 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle3, "deg");
});
var positonToCSSUnitValue = memoize(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _position$value = position.value, x = _position$value.x, y = _position$value.y;
    if ((x === null || x === void 0 ? void 0 : x.type) === "position-keyword") {
      if (x.value === "left") {
        cx = 0;
      } else if (x.value === "center") {
        cx = 50;
      } else if (x.value === "right") {
        cx = 100;
      } else if (x.value === "top") {
        cy = 0;
      } else if (x.value === "bottom") {
        cy = 100;
      }
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === "position-keyword") {
      if (y.value === "left") {
        cx = 0;
      } else if (y.value === "center") {
        cy = 50;
      } else if (y.value === "right") {
        cx = 100;
      } else if (y.value === "top") {
        cy = 0;
      } else if (y.value === "bottom") {
        cy = 100;
      }
    }
    if ((x === null || x === void 0 ? void 0 : x.type) === "px" || (x === null || x === void 0 ? void 0 : x.type) === "%" || (x === null || x === void 0 ? void 0 : x.type) === "em") {
      unitX = x === null || x === void 0 ? void 0 : x.type;
      cx = Number(x.value);
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === "px" || (y === null || y === void 0 ? void 0 : y.type) === "%" || (y === null || y === void 0 ? void 0 : y.type) === "em") {
      unitY = y === null || y === void 0 ? void 0 : y.type;
      cy = Number(y.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient$1 = memoize(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      } else if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size2;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size2 = getOrCreateKeyword(value);
            } else {
              size2 = getOrCreateUnitValue(value, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size2,
            steps: steps2
          });
        }
      }
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var offset = _ref2[0], color2 = _ref2[1];
            return {
              offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
              color: color2
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (is_string_default(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref3) {
        var offset = _ref3[0], color2 = _ref3[1];
        return {
          offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
          color: color2
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return is_object_default(object) && !!object.image;
}
function isCSSRGB(object) {
  return is_object_default(object) && !is_nil_default(object.r) && !is_nil_default(object.g) && !is_nil_default(object.b);
}
var parseColor = memoize(function(colorStr) {
  if (isPattern(colorStr)) {
    return _extends({
      repetition: "repeat"
    }, colorStr);
  }
  if (is_nil_default(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  } else if (colorStr === "currentColor") {
    colorStr = "black";
  }
  var g = parseGradient$1(colorStr);
  if (g) {
    return g;
  }
  var color$1 = color(colorStr);
  var rgba2 = [0, 0, 0, 0];
  if (color$1 !== null) {
    rgba2[0] = color$1.r || 0;
    rgba2[1] = color$1.g || 0;
    rgba2[2] = color$1.b || 0;
    rgba2[3] = color$1.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba2);
});
function mergeColors(left, right) {
  if (!isCSSRGB(left) || !isCSSRGB(right)) {
    return;
  }
  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color2) {
    var rgba2 = color2.slice();
    if (rgba2[3]) {
      for (var i = 0; i < 3; i++) {
        rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
      }
    }
    rgba2[3] = clamp_default(rgba2[3], 0, 1);
    return "rgba(" + rgba2.join(",") + ")";
  }];
}
var AABB = function() {
  AABB2.isEmpty = function isEmpty(aabb) {
    return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
  };
  function AABB2(center, halfExtents) {
    if (center === void 0) {
      center = [0, 0, 0];
    }
    if (halfExtents === void 0) {
      halfExtents = [0, 0, 0];
    }
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
    this.update(center, halfExtents);
  }
  var _proto = AABB2.prototype;
  _proto.update = function update(center, halfExtents) {
    copyVec3(this.center, center);
    copyVec3(this.halfExtents, halfExtents);
    subVec3(this.min, this.center, this.halfExtents);
    addVec3(this.max, this.center, this.halfExtents);
  };
  _proto.setMinMax = function setMinMax(min4, max4) {
    addVec3(this.center, max4, min4);
    scaleVec3(this.center, this.center, 0.5);
    subVec3(this.halfExtents, max4, min4);
    scaleVec3(this.halfExtents, this.halfExtents, 0.5);
    copyVec3(this.min, min4);
    copyVec3(this.max, max4);
  };
  _proto.getMin = function getMin() {
    return this.min;
  };
  _proto.getMax = function getMax() {
    return this.max;
  };
  _proto.add = function add7(aabb) {
    if (AABB2.isEmpty(aabb)) {
      return;
    }
    if (AABB2.isEmpty(this)) {
      this.setMinMax(aabb.getMin(), aabb.getMax());
      return;
    }
    var tc = this.center;
    var tcx = tc[0];
    var tcy = tc[1];
    var tcz = tc[2];
    var th = this.halfExtents;
    var thx = th[0];
    var thy = th[1];
    var thz = th[2];
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = aabb.center;
    var ocx = oc[0];
    var ocy = oc[1];
    var ocz = oc[2];
    var oh = aabb.halfExtents;
    var ohx = oh[0];
    var ohy = oh[1];
    var ohz = oh[2];
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;
    if (ominx < tminx) {
      tminx = ominx;
    }
    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }
    if (ominy < tminy) {
      tminy = ominy;
    }
    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }
    if (ominz < tminz) {
      tminz = ominz;
    }
    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }
    tc[0] = (tminx + tmaxx) * 0.5;
    tc[1] = (tminy + tmaxy) * 0.5;
    tc[2] = (tminz + tmaxz) * 0.5;
    th[0] = (tmaxx - tminx) * 0.5;
    th[1] = (tmaxy - tminy) * 0.5;
    th[2] = (tmaxz - tminz) * 0.5;
    this.min[0] = tminx;
    this.min[1] = tminy;
    this.min[2] = tminz;
    this.max[0] = tmaxx;
    this.max[1] = tmaxy;
    this.max[2] = tmaxz;
  };
  _proto.setFromTransformedAABB = function setFromTransformedAABB(aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center;
    var ar = aabb.halfExtents;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
    bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
    bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
    br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
    br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
    br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
    subVec3(this.min, bc, br);
    addVec3(this.max, bc, br);
  };
  _proto.intersects = function intersects(aabb) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = aabb.getMax();
    var bMin = aabb.getMin();
    return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
  };
  _proto.intersection = function intersection(aabb) {
    if (!this.intersects(aabb)) {
      return null;
    }
    var intersection2 = new AABB2();
    var min4 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
    var max4 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
    intersection2.setMinMax(min4, max4);
    return intersection2;
  };
  _proto.getNegativeFarPoint = function getNegativeFarPoint(plane) {
    if (plane.pnVertexFlag === 273) {
      return copyVec3([0, 0, 0], this.min);
    } else if (plane.pnVertexFlag === 272) {
      return [this.min[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 257) {
      return [this.min[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 256) {
      return [this.min[0], this.max[1], this.max[2]];
    } else if (plane.pnVertexFlag === 17) {
      return [this.max[0], this.min[1], this.min[2]];
    } else if (plane.pnVertexFlag === 16) {
      return [this.max[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 1) {
      return [this.max[0], this.max[1], this.min[2]];
    } else {
      return [this.max[0], this.max[1], this.max[2]];
    }
  };
  _proto.getPositiveFarPoint = function getPositiveFarPoint(plane) {
    if (plane.pnVertexFlag === 273) {
      return copyVec3([0, 0, 0], this.max);
    } else if (plane.pnVertexFlag === 272) {
      return [this.max[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 257) {
      return [this.max[0], this.min[1], this.max[2]];
    } else if (plane.pnVertexFlag === 256) {
      return [this.max[0], this.min[1], this.min[2]];
    } else if (plane.pnVertexFlag === 17) {
      return [this.min[0], this.max[1], this.max[2]];
    } else if (plane.pnVertexFlag === 16) {
      return [this.min[0], this.max[1], this.min[2]];
    } else if (plane.pnVertexFlag === 1) {
      return [this.min[0], this.min[1], this.max[2]];
    } else {
      return [this.min[0], this.min[1], this.min[2]];
    }
  };
  return AABB2;
}();
var Plane = function() {
  function Plane2(distance6, normal) {
    this.distance = void 0;
    this.normal = void 0;
    this.pnVertexFlag = void 0;
    this.distance = distance6 || 0;
    this.normal = normal || vec3_exports.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  var _proto = Plane2.prototype;
  _proto.updatePNVertexFlag = function updatePNVertexFlag() {
    this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
  };
  _proto.distanceToPoint = function distanceToPoint(point) {
    return vec3_exports.dot(point, this.normal) - this.distance;
  };
  _proto.normalize = function normalize6() {
    var invLen = 1 / vec3_exports.len(this.normal);
    vec3_exports.scale(this.normal, this.normal, invLen);
    this.distance *= invLen;
  };
  _proto.intersectsLine = function intersectsLine(start, end, point) {
    var d0 = this.distanceToPoint(start);
    var d1 = this.distanceToPoint(end);
    var t = d0 / (d0 - d1);
    var intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      vec3_exports.lerp(point, start, end, t);
    }
    return intersects;
  };
  return Plane2;
}();
var Mask;
(function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
})(Mask || (Mask = {}));
var Frustum = function() {
  function Frustum2(planes) {
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i = 0; i < 6; i++) {
        this.planes.push(new Plane());
      }
    }
  }
  var _proto = Frustum2.prototype;
  _proto.extractFromVPMatrix = function extractFromVPMatrix(projectionMatrix) {
    var m0 = projectionMatrix[0], m1 = projectionMatrix[1], m2 = projectionMatrix[2], m3 = projectionMatrix[3], m4 = projectionMatrix[4], m5 = projectionMatrix[5], m6 = projectionMatrix[6], m7 = projectionMatrix[7], m8 = projectionMatrix[8], m9 = projectionMatrix[9], m10 = projectionMatrix[10], m11 = projectionMatrix[11], m12 = projectionMatrix[12], m13 = projectionMatrix[13], m14 = projectionMatrix[14], m15 = projectionMatrix[15];
    vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
    this.planes[0].distance = m15 - m12;
    vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
    this.planes[1].distance = m15 + m12;
    vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
    this.planes[2].distance = m15 + m13;
    vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
    this.planes[3].distance = m15 - m13;
    vec3_exports.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
    this.planes[4].distance = m15 - m14;
    vec3_exports.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
    this.planes[5].distance = m15 + m14;
    this.planes.forEach(function(plane) {
      plane.normalize();
      plane.updatePNVertexFlag();
    });
  };
  return Frustum2;
}();
var Point = function() {
  function Point2(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point2.prototype;
  _proto.clone = function clone7() {
    return new Point2(this.x, this.y);
  };
  _proto.copyFrom = function copyFrom(p) {
    this.x = p.x;
    this.y = p.y;
  };
  return Point2;
}();
var Rectangle = function() {
  function Rectangle2(x, y, width, height) {
    this.x = void 0;
    this.y = void 0;
    this.width = void 0;
    this.height = void 0;
    this.left = void 0;
    this.right = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.left = x;
    this.right = x + width;
    this.top = y;
    this.bottom = y + height;
  }
  var _proto = Rectangle2.prototype;
  _proto.toJSON = function toJSON() {
  };
  return Rectangle2;
}();
function parseDimension(unitRegExp, string) {
  if (is_nil_default(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = ("" + string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    } else if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U" + match;
  });
  var taggedUnitRegExp = "U(" + unitRegExp.source + ")";
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U" + unit, "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLength = memoize(function(css) {
  return parseDimension(new RegExp("px", "g"), css);
});
var parserPercentage = memoize(function(css) {
  return parseDimension(new RegExp("%", "g"), css);
});
var parseLengthOrPercentage = function parseLengthOrPercentage2(css) {
  if (is_number_default(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css), "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseAngle = memoize(function(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
});
function mergeDimensions(left, right, target, nonNegative, index) {
  if (index === void 0) {
    index = 0;
  }
  var unit = "";
  var leftValue = left.value || 0;
  var rightValue = right.value || 0;
  var canonicalUnit = toCanonicalUnit(left.unit);
  var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left.unit);
  } else {
    if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
      leftValue = convertPercentUnit(left, index, target);
      rightValue = convertPercentUnit(right, index, target);
      unit = "px";
    }
  }
  return [leftValue, rightValue, function(value) {
    if (nonNegative) {
      value = Math.max(value, 0);
    }
    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg2 = 0;
  if (value.unit === UnitType.kDegrees) {
    deg2 = value.value;
  } else if (value.unit === UnitType.kRadians) {
    deg2 = rad2deg2(Number(value.value));
  } else if (value.unit === UnitType.kTurns) {
    deg2 = turn2deg(Number(value.value));
  }
  return deg2;
}
function parseDimensionArrayFormat(string, size2) {
  var parsed;
  if (is_string_default(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (is_number_default(string)) {
    parsed = [string];
  } else {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  }
  if (size2 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    } else {
      return [parsed[0], parsed[1]];
    }
  } else {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
  }
}
function parseDimensionArray(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(function(segment) {
      return parseLengthOrPercentage(segment);
    });
  } else {
    return string.map(function(segment) {
      return parseLengthOrPercentage(segment.toString());
    });
  }
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    var size2 = 0;
    if (!AABB.isEmpty(bounds)) {
      size2 = bounds.halfExtents[vec3Index] * 2;
    }
    return Number(valueWithUnit.value) / 100 * size2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter(filterStr) {
  if (filterStr === void 0) {
    filterStr = "";
  }
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(" ").map(function(p) {
          return parseParam(p) || parseColor(p);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x) {
  return x.toString();
}
var parseNumber = memoize(function(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  } else {
    return getOrCreateUnitValue(0);
  }
});
var parseNumberList = memoize(function(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(parseNumber);
  } else {
    return string.map(parseNumber);
  }
});
function mergeNumbers(left, right) {
  return [left, right, numberToString];
}
function clampedMergeNumbers(min4, max4) {
  return function(left, right) {
    return [left, right, function(x) {
      return numberToString(clamp_default(x, min4, max4));
    }];
  };
}
function mergeNumberLists(left, right) {
  if (left.length !== right.length) {
    return;
  }
  return [left, right, function(numberList) {
    return numberList;
  }];
}
var internalParsePath = function internalParsePath2(path) {
  if (path === "" || Array.isArray(path) && path.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path);
  } catch (e2) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: " + path);
  }
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox2(segments, 0), x = _getPathBBox.x, y = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x) ? x : 0,
      y: Number.isFinite(y) ? y : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize(internalParsePath);
function parsePath(path, object) {
  var result = is_string_default(path) ? memoizedParsePath(path) : internalParsePath(path);
  if (object) {
    object.parsedStyle.defX = result.rect.x;
    object.parsedStyle.defY = result.rect.y;
  }
  return result;
}
function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left.absolutePath, false);
    left.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right.absolutePath, false);
    right.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (is_string_default(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), x = _pointStr$split[0], y = _pointStr$split[1];
      return [Number(x), Number(y)];
    });
  } else {
    points = pointsOrStr;
  }
  var segments = [];
  var tempLength = 0;
  var segmentT;
  var segmentL;
  var totalLength = polyline.length(points);
  points.forEach(function(p, i) {
    if (points[i + 1]) {
      segmentT = [0, 0];
      segmentT[0] = tempLength / totalLength;
      segmentL = line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
      tempLength += segmentL;
      segmentT[1] = tempLength / totalLength;
      segments.push(segmentT);
    }
  });
  var minX = Math.min.apply(Math, points.map(function(point) {
    return point[0];
  }));
  var minY = Math.min.apply(Math, points.map(function(point) {
    return point[1];
  }));
  if (object) {
    object.parsedStyle.defX = minX;
    object.parsedStyle.defY = minY;
  }
  return {
    points,
    totalLength,
    segments
  };
}
var _ = null;
function cast(pattern) {
  return function(contents) {
    var i = 0;
    return pattern.map(function(x) {
      return x === _ ? contents[i++] : x;
    });
  };
}
function id(x) {
  return x;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotatex: ["A"],
  rotatey: ["A"],
  rotatez: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scalex: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaley: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scalez: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewx: ["A", null, cast([_, Odeg])],
  skewy: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translatex: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translatey: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translatez: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseTransform(string) {
  string = (string || "none").toLowerCase().trim();
  if (string === "none") {
    return [];
  }
  var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = transformRegExp.exec(string)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A4(s2) {
            return s2.trim() === "0" ? Odeg : parseAngle(s2);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (transformRegExp.lastIndex === string.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x;
  var y;
  var z;
  var angle3;
  switch (item.t) {
    case "rotatex":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotatey":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), 0, -Math.sin(angle3), 0, 0, 1, 0, 0, Math.sin(angle3), 0, Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotatez":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x = item.d[0].value;
      y = item.d[1].value;
      z = item.d[2].value;
      angle3 = deg2rad2(convertAngleUnit(item.d[3]));
      var sqrLength = x * x + y * y + z * z;
      if (sqrLength === 0) {
        x = 1;
        y = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length14 = Math.sqrt(sqrLength);
        x /= length14;
        y /= length14;
        z /= length14;
      }
      var s2 = Math.sin(angle3 / 2);
      var sc = s2 * Math.cos(angle3 / 2);
      var sq = s2 * s2;
      return [1 - 2 * (y * y + z * z) * sq, 2 * (x * y * sq + z * sc), 2 * (x * z * sq - y * sc), 0, 2 * (x * y * sq - z * sc), 1 - 2 * (x * x + z * z) * sq, 2 * (y * z * sq + x * sc), 0, 2 * (x * z * sq + y * sc), 2 * (y * z * sq - x * sc), 1 - 2 * (x * x + y * y) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scalex":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaley":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scalez":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad2(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad2(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewx":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle3), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewy":
      angle3 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle3), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, 0, 1];
    case "translatex":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
    case "translatey":
      y = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
    case "translatez":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d4) {
        return d4.value;
      });
  }
}
function multiplyMatrices(a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate3 = [0, 0, 0];
  var scale8 = [1, 1, 1];
  var skew = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(convertToMatrix(transformList), translate3, scale8, skew, perspective2, quaternion);
  return [[translate3, scale8, skew, quaternion, perspective2]];
}
var composeMatrix = function() {
  function multiply7(a, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k = 0; k < 4; k++) {
          result[i][j] += b[i][k] * a[k][j];
        }
      }
    }
    return result;
  }
  function is2D(m) {
    return m[0][2] == 0 && m[0][3] == 0 && m[1][2] == 0 && m[1][3] == 0 && m[2][0] == 0 && m[2][1] == 0 && m[2][2] == 1 && m[2][3] == 0 && m[3][2] == 0 && m[3][3] == 1;
  }
  function composeMatrix2(translate3, scale8, skew, quat2, perspective2) {
    var matrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i = 0; i < 4; i++) {
      matrix[i][3] = perspective2[i];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix[3][_i] += translate3[j] * matrix[j][_i];
      }
    }
    var x = quat2[0], y = quat2[1], z = quat2[2], w = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y * y + z * z);
    rotMatrix[0][1] = 2 * (x * y - z * w);
    rotMatrix[0][2] = 2 * (x * z + y * w);
    rotMatrix[1][0] = 2 * (x * y + z * w);
    rotMatrix[1][1] = 1 - 2 * (x * x + z * z);
    rotMatrix[1][2] = 2 * (y * z - x * w);
    rotMatrix[2][0] = 2 * (x * z - y * w);
    rotMatrix[2][1] = 2 * (y * z + x * w);
    rotMatrix[2][2] = 1 - 2 * (x * x + y * y);
    matrix = multiply7(matrix, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew[2]) {
      temp[2][1] = skew[2];
      matrix = multiply7(matrix, temp);
    }
    if (skew[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew[0];
      matrix = multiply7(matrix, temp);
    }
    if (skew[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew[0];
      matrix = multiply7(matrix, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix[_i2][_j] *= scale8[_i2];
      }
    }
    if (is2D(matrix)) {
      return [matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1], matrix[3][0], matrix[3][1]];
    }
    return matrix[0].concat(matrix[1], matrix[2], matrix[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x) {
  return x.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left, right) {
  var leftArgs;
  var rightArgs;
  if (left.decompositionPair !== right) {
    left.decompositionPair = right;
    leftArgs = makeMatrixDecomposition(left);
  }
  if (right.decompositionPair !== left) {
    right.decompositionPair = left;
    rightArgs = makeMatrixDecomposition(right);
  }
  if (leftArgs[0] === null || rightArgs[0] === null)
    return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x) {
        return x ? right[0].d : left[0].d;
      }
    ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result = 0;
  for (var i = 0; i < v1.length; i++) {
    result += v1[i] * v2[i];
  }
  return result;
}
function quat(fromQ, toQ, f) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[xy]/, "");
}
function typeTo3D(type) {
  return type.replace(/(x|y|z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left, right, target) {
  var flipResults = false;
  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }
    var _loop = function _loop2(i2) {
      var _left$i = left[i2], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i = 0; i < left.length; i++) {
      _loop(i);
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left.length !== right.length) {
    var merged = mergeMatrices(left, right);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left.length; _i3++) {
      var leftType = left[_i3].t;
      var rightType = right[_i3].t;
      var leftArgs = left[_i3].d;
      var rightArgs = right[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left, right);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list) {
    return list.map(function(args, i2) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i2][1][j2](arg);
      }).join(",");
      if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i2][0] = "matrix3d";
      }
      if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i2][0] = "matrix";
      }
      return types[i2][0] + "(" + stringifiedArgs + ")";
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize(function(value) {
  if (is_string_default(value)) {
    if (value === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values = value.split(" ");
    if (values.length === 1) {
      if (values[0] === "top" || values[0] === "bottom") {
        values[1] = values[0];
        values[0] = "center";
      } else {
        values[1] = "center";
      }
    }
    if (values.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
  } else {
    return [getOrCreateUnitValue(value[0] || 0, "px"), getOrCreateUnitValue(value[1] || 0, "px")];
  }
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  } else if (keyword === "left" || keyword === "top") {
    return "0";
  } else if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var CSSPropertyAngle = function() {
  function CSSPropertyAngle2() {
    this.parser = parseAngle;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyAngle2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    return convertAngleUnit(parsed);
  };
  return CSSPropertyAngle2;
}();
var CSSPropertyClipPath = function() {
  function CSSPropertyClipPath2() {
  }
  var _proto = CSSPropertyClipPath2.prototype;
  _proto.calculator = function calculator(name, oldPath, newPath, object) {
    if (newPath instanceof CSSKeywordValue) {
      newPath = null;
    }
    runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
    if (name === "clipPath") {
      object.forEach(function(leaf) {
        if (leaf.childNodes.length === 0) {
          runtime.sceneGraphService.dirtifyToRoot(leaf);
        }
      });
    }
    return newPath;
  };
  return CSSPropertyClipPath2;
}();
var CSSPropertyColor = function() {
  function CSSPropertyColor2() {
    this.parser = parseColor;
    this.parserWithCSSDisabled = parseColor;
    this.mixer = mergeColors;
  }
  var _proto = CSSPropertyColor2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      return parsed.value === "none" ? noneColor : transparentColor;
    }
    return parsed;
  };
  return CSSPropertyColor2;
}();
var CSSPropertyFilter = function() {
  function CSSPropertyFilter2() {
    this.parser = parseFilter;
  }
  var _proto = CSSPropertyFilter2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  return CSSPropertyFilter2;
}();
function getFontSize(object) {
  var fontSize = object.parsedStyle.fontSize;
  return is_nil_default(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = function() {
  function CSSPropertyLengthOrPercentage2() {
    this.parser = parseLengthOrPercentage;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyLengthOrPercentage2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed, object, registry) {
    if (is_number_default(computed)) {
      return computed;
    }
    if (CSSUnitValue.isRelativeUnit(computed.unit)) {
      if (computed.unit === UnitType.kPercentage) {
        return 0;
      } else if (computed.unit === UnitType.kEms) {
        if (object.parentNode) {
          var fontSize = getFontSize(object.parentNode);
          if (fontSize) {
            fontSize *= computed.value;
            return fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      } else if (computed.unit === UnitType.kRems) {
        var _object$ownerDocument;
        if (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.documentElement) {
          var _fontSize = getFontSize(object.ownerDocument.documentElement);
          if (_fontSize) {
            _fontSize *= computed.value;
            return _fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      }
    } else {
      return computed.value;
    }
  };
  return CSSPropertyLengthOrPercentage2;
}();
var CSSPropertyLengthOrPercentage12 = function() {
  function CSSPropertyLengthOrPercentage122() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage122.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
    var formatted;
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0]];
    } else {
      formatted = [parsed[0], parsed[1]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function(c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage122;
}();
var CSSPropertyLengthOrPercentage14 = function() {
  function CSSPropertyLengthOrPercentage142() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage142.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
    var formatted;
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function(c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage142;
}();
var CSSPropertyLocalPosition = function(_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyLocalPosition2, _CSSPropertyLengthOrP);
  function CSSPropertyLocalPosition2() {
    return _CSSPropertyLengthOrP.apply(this, arguments) || this;
  }
  var _proto = CSSPropertyLocalPosition2.prototype;
  _proto.postProcessor = function postProcessor(object, attributes) {
    var x;
    var y;
    var z;
    switch (object.nodeName) {
      case Shape.CIRCLE:
      case Shape.ELLIPSE:
        var _object$parsedStyle = object.parsedStyle, cx = _object$parsedStyle.cx, cy = _object$parsedStyle.cy;
        if (!is_nil_default(cx)) {
          x = cx;
        }
        if (!is_nil_default(cy)) {
          y = cy;
        }
        break;
      case Shape.LINE:
        var _object$parsedStyle2 = object.parsedStyle, x1 = _object$parsedStyle2.x1, x2 = _object$parsedStyle2.x2, y1 = _object$parsedStyle2.y1, y2 = _object$parsedStyle2.y2;
        var minX = Math.min(x1, x2);
        var minY = Math.min(y1, y2);
        x = minX;
        y = minY;
        z = 0;
        break;
      case Shape.RECT:
      case Shape.IMAGE:
      case Shape.GROUP:
      case Shape.HTML:
      case Shape.TEXT:
      case Shape.MESH:
        if (!is_nil_default(object.parsedStyle.x)) {
          x = object.parsedStyle.x;
        }
        if (!is_nil_default(object.parsedStyle.y)) {
          y = object.parsedStyle.y;
        }
        break;
    }
    if (object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE && object.nodeName !== Shape.POLYGON) {
      object.parsedStyle.defX = x || 0;
      object.parsedStyle.defY = y || 0;
    }
    var needResetLocalPosition = !is_nil_default(x) || !is_nil_default(y) || !is_nil_default(z);
    if (needResetLocalPosition && attributes.indexOf("transform") === -1) {
      var transform = object.parsedStyle.transform;
      if (transform && transform.length) {
        parsedTransformToMat4(transform, object);
      } else {
        var _object$getLocalPosit = object.getLocalPosition(), ox = _object$getLocalPosit[0], oy = _object$getLocalPosit[1], oz = _object$getLocalPosit[2];
        object.setLocalPosition(is_nil_default(x) ? ox : x, is_nil_default(y) ? oy : y, is_nil_default(z) ? oz : z);
      }
    }
  };
  return CSSPropertyLocalPosition2;
}(CSSPropertyLengthOrPercentage);
var CSSPropertyMarker = function() {
  function CSSPropertyMarker2() {
  }
  var _proto = CSSPropertyMarker2.prototype;
  _proto.calculator = function calculator(name, oldMarker, newMarker, object) {
    var _newMarker;
    if (newMarker instanceof CSSKeywordValue) {
      newMarker = null;
    }
    var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
    if (cloned) {
      cloned.style.isMarker = true;
    }
    return cloned;
  };
  return CSSPropertyMarker2;
}();
var CSSPropertyNumber = function() {
  function CSSPropertyNumber2() {
    this.mixer = mergeNumbers;
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
  }
  var _proto = CSSPropertyNumber2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyNumber2;
}();
var CSSPropertyOffsetDistance = function() {
  function CSSPropertyOffsetDistance2() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOffsetDistance2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
    if (!offsetPath) {
      return;
    }
    var nodeName = offsetPath.nodeName;
    if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
      var point = offsetPath.getPoint(offsetDistance);
      if (point) {
        object.parsedStyle.defX = point.x;
        object.parsedStyle.defY = point.y;
        object.setLocalPosition(point.x, point.y);
      }
    }
  };
  return CSSPropertyOffsetDistance2;
}();
var CSSPropertyOpacity = function() {
  function CSSPropertyOpacity2() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOpacity2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyOpacity2;
}();
var CSSPropertyPath = function() {
  function CSSPropertyPath2() {
    this.parser = parsePath;
    this.parserWithCSSDisabled = parsePath;
    this.mixer = mergePaths;
  }
  var _proto = CSSPropertyPath2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: new Rectangle(0, 0, 0, 0)
      };
    }
    return parsed;
  };
  _proto.postProcessor = function postProcessor(object, attributes) {
    if (object.nodeName === Shape.PATH && attributes.indexOf("transform") === -1) {
      var _object$parsedStyle = object.parsedStyle, _object$parsedStyle$d = _object$parsedStyle.defX, defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d, _object$parsedStyle$d2 = _object$parsedStyle.defY, defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPath2;
}();
var CSSPropertyPoints = function() {
  function CSSPropertyPoints2() {
    this.parser = parsePoints;
  }
  var _proto = CSSPropertyPoints2.prototype;
  _proto.postProcessor = function postProcessor(object, attributes) {
    if ((object.nodeName === Shape.POLYGON || object.nodeName === Shape.POLYLINE) && attributes.indexOf("transform") === -1) {
      var _object$parsedStyle = object.parsedStyle, defX = _object$parsedStyle.defX, defY = _object$parsedStyle.defY;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPoints2;
}();
var CSSPropertyShadowBlur = function(_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  function CSSPropertyShadowBlur2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _CSSPropertyLengthOrP.call.apply(_CSSPropertyLengthOrP, [this].concat(args)) || this;
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  return CSSPropertyShadowBlur2;
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = function() {
  function CSSPropertyText2() {
  }
  var _proto = CSSPropertyText2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      if (parsed.value === "unset") {
        return "";
      } else {
        return parsed.value;
      }
    }
    return "" + parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    object.nodeValue = "" + object.parsedStyle.text || "";
  };
  return CSSPropertyText2;
}();
var CSSPropertyTextTransform = function() {
  function CSSPropertyTextTransform2() {
  }
  var _proto = CSSPropertyTextTransform2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    var rawText = object.getAttribute("text");
    if (rawText) {
      var transformedText = rawText;
      if (parsed.value === "capitalize") {
        transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
      } else if (parsed.value === "lowercase") {
        transformedText = rawText.toLowerCase();
      } else if (parsed.value === "uppercase") {
        transformedText = rawText.toUpperCase();
      }
      object.parsedStyle.text = transformedText;
    }
    return parsed.value;
  };
  return CSSPropertyTextTransform2;
}();
var CSSPropertyTransform = function() {
  function CSSPropertyTransform2() {
    this.parser = parseTransform;
    this.parserWithCSSDisabled = parseTransform;
    this.mixer = mergeTransforms;
  }
  var _proto = CSSPropertyTransform2.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    var transform = object.parsedStyle.transform;
    parsedTransformToMat4(transform, object);
  };
  return CSSPropertyTransform2;
}();
var CSSPropertyTransformOrigin = function CSSPropertyTransformOrigin2() {
  this.parser = parseTransformOrigin;
};
var CSSPropertyZIndex = function() {
  function CSSPropertyZIndex2() {
    this.parser = parseNumber;
  }
  var _proto = CSSPropertyZIndex2.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed, object) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    if (object.parentNode) {
      var parentEntity = object.parentNode;
      var parentRenderable = parentEntity.renderable;
      var parentSortable = parentEntity.sortable;
      if (parentRenderable) {
        parentRenderable.dirty = true;
      }
      if (parentSortable) {
        parentSortable.dirty = true;
      }
    }
  };
  return CSSPropertyZIndex2;
}();
var CustomElementRegistry = function() {
  function CustomElementRegistry2() {
    this.registry = {};
    this.define(Shape.CIRCLE, Circle);
    this.define(Shape.ELLIPSE, Ellipse);
    this.define(Shape.RECT, Rect);
    this.define(Shape.IMAGE, Image);
    this.define(Shape.LINE, Line);
    this.define(Shape.GROUP, Group);
    this.define(Shape.PATH, Path);
    this.define(Shape.POLYGON, Polygon);
    this.define(Shape.POLYLINE, Polyline);
    this.define(Shape.TEXT, Text);
    this.define(Shape.HTML, HTML);
  }
  var _proto = CustomElementRegistry2.prototype;
  _proto.define = function define2(name, constructor) {
    this.registry[name] = constructor;
  };
  _proto.get = function get(name) {
    return this.registry[name];
  };
  return CustomElementRegistry2;
}();
function isFederatedEvent(value) {
  return !!value.type;
}
var FederatedEvent = function() {
  function FederatedEvent2(manager) {
    this.type = void 0;
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.target = void 0;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.currentTarget = void 0;
    this.defaultPrevented = false;
    this.timeStamp = void 0;
    this.nativeEvent = void 0;
    this.originalEvent = void 0;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.manager = void 0;
    this.detail = void 0;
    this.layer = new Point();
    this.page = new Point();
    this.canvas = new Point();
    this.viewport = new Point();
    this.path = void 0;
    this.view = void 0;
    this.which = void 0;
    this.returnValue = void 0;
    this.srcElement = void 0;
    this.composed = false;
    this.isTrusted = void 0;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  var _proto = FederatedEvent2.prototype;
  _proto.composedPath = function composedPath() {
    if (this.manager && (!this.path || this.path[0] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  };
  _proto.preventDefault = function preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  };
  _proto.stopImmediatePropagation = function stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  };
  _proto.stopPropagation = function stopPropagation() {
    this.propagationStopped = true;
  };
  _proto.initEvent = function initEvent() {
  };
  _proto.initUIEvent = function initUIEvent() {
  };
  _proto.clone = function clone7() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get() {
        return this.type;
      }
    )
    /**
     * The propagation phase.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
     */
  }, {
    key: "layerX",
    get: function get() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get() {
      return this.layer.y;
    }
    /**
     * The coordinates of the event relative to the DOM document.
     * This is a non-standard property.
     * relative to the DOM document.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX
     */
  }, {
    key: "pageX",
    get: function get() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get() {
      return this.page.y;
    }
    /**
     * relative to Canvas, origin is left-top
     */
  }, {
    key: "x",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get() {
      return this.canvas.y;
    }
    /**
     * relative to Viewport, account for Camera
     */
  }, {
    key: "viewportX",
    get: function get() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get() {
      return this.viewport.y;
    }
  }, {
    key: "propagationPath",
    get: function get() {
      return this.composedPath();
    }
  }]);
  return FederatedEvent2;
}();
var CustomEvent = function(_FederatedEvent) {
  _inheritsLoose(CustomEvent2, _FederatedEvent);
  function CustomEvent2(eventName, object) {
    var _this2;
    _this2 = _FederatedEvent.call(this, null) || this;
    _this2.type = eventName;
    _this2.detail = object;
    Object.assign(_assertThisInitialized(_this2), object);
    return _this2;
  }
  return CustomEvent2;
}(FederatedEvent);
var DELEGATION_SPLITTER = ":";
var EventTarget = function() {
  function EventTarget2() {
    this.emitter = new import_eventemitter3.default();
  }
  var _proto = EventTarget2.prototype;
  _proto.on = function on(type, listener, options) {
    this.addEventListener(type, listener, options);
    return this;
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
    var once = is_object_default(options) && options.once;
    var context = isFunction(listener) ? void 0 : listener;
    var useDelegatedName = false;
    var delegatedName = "";
    if (type.indexOf(DELEGATION_SPLITTER) > -1) {
      var _type$split = type.split(DELEGATION_SPLITTER), name = _type$split[0], eventType = _type$split[1];
      type = eventType;
      delegatedName = name;
      useDelegatedName = true;
    }
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : listener.handleEvent;
    if (useDelegatedName) {
      var originListener = listener;
      listener = function listener2() {
        var _args$0$target;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (((_args$0$target = args[0].target) === null || _args$0$target === void 0 ? void 0 : _args$0$target.name) !== delegatedName) {
          return;
        }
        originListener.apply(void 0, args);
      };
    }
    if (once) {
      this.emitter.once(type, listener, context);
    } else {
      this.emitter.on(type, listener, context);
    }
    return this;
  };
  _proto.off = function off(type, listener, options) {
    if (type) {
      this.removeEventListener(type, listener, options);
    } else {
      this.removeAllEventListeners();
    }
    return this;
  };
  _proto.removeAllEventListeners = function removeAllEventListeners() {
    this.emitter.removeAllListeners();
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    var _listener;
    var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
    var context = isFunction(listener) ? void 0 : listener;
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
    this.emitter.off(type, listener, context);
    return this;
  };
  _proto.emit = function emit(eventName, object) {
    this.dispatchEvent(new CustomEvent(eventName, object));
  };
  _proto.dispatchEvent = function dispatchEvent(e2, skipPropagate) {
    if (skipPropagate === void 0) {
      skipPropagate = false;
    }
    if (!isFederatedEvent(e2)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    var canvas;
    if (this.document) {
      canvas = this;
    } else if (this.defaultView) {
      canvas = this.defaultView;
    } else {
      var _this$ownerDocument;
      canvas = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView;
    }
    if (canvas) {
      var _e$manager;
      e2.manager = canvas.getEventService() || null;
      if (!e2.manager) {
        return false;
      }
      e2.defaultPrevented = false;
      e2.path = [];
      if (!skipPropagate) {
        e2.target = this;
      }
      (_e$manager = e2.manager) === null || _e$manager === void 0 ? void 0 : _e$manager.dispatchEvent(e2, e2.type, skipPropagate);
    }
    return !e2.defaultPrevented;
  };
  return EventTarget2;
}();
var Node2 = function(_EventTarget) {
  _inheritsLoose(Node3, _EventTarget);
  function Node3() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.parentNode = null;
    return _this2;
  }
  Node3.isNode = function isNode(target) {
    return !!target.childNodes;
  };
  var _proto = Node3.prototype;
  _proto.getRootNode = function getRootNode(opts) {
    if (opts === void 0) {
      opts = {};
    }
    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }
    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }
    return this;
  };
  _proto.hasChildNodes = function hasChildNodes() {
    return this.childNodes.length > 0;
  };
  _proto.isDefaultNamespace = function isDefaultNamespace(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupNamespaceURI = function lookupNamespaceURI(prefix) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupPrefix = function lookupPrefix(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.normalize = function normalize6() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.isEqualNode = function isEqualNode(otherNode) {
    return this === otherNode;
  };
  _proto.isSameNode = function isSameNode(otherNode) {
    return this.isEqualNode(otherNode);
  };
  _proto.compareDocumentPosition = function compareDocumentPosition(other) {
    if (other === this) {
      return 0;
    }
    if (!(other instanceof Node3)) {
      throw new TypeError("Node.compareDocumentPosition: Argument 1 does not implement interface Node.");
    }
    var node1Root = other;
    var node2Root = this;
    var node1Hierarchy = [node1Root];
    var node2Hierarchy = [node2Root];
    while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
      var _node1Root$parentNode;
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    }
    if (node1Root !== node2Root) {
      return Node3.DOCUMENT_POSITION_DISCONNECTED | Node3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node3.DOCUMENT_POSITION_PRECEDING;
    }
    var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ? (
        // other is a child of this
        Node3.DOCUMENT_POSITION_CONTAINED_BY | Node3.DOCUMENT_POSITION_FOLLOWING
      ) : (
        // this is a child of other
        Node3.DOCUMENT_POSITION_CONTAINS | Node3.DOCUMENT_POSITION_PRECEDING
      );
    }
    var longerStart = longerHierarchy.length - shorterHierarchy.length;
    for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
      var shorterHierarchyNode = shorterHierarchy[i];
      var longerHierarchyNode = longerHierarchy[longerStart + i];
      if (longerHierarchyNode !== shorterHierarchyNode) {
        var siblings = shorterHierarchyNode.parentNode.childNodes;
        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          if (shorterHierarchy === node1Hierarchy) {
            return Node3.DOCUMENT_POSITION_PRECEDING;
          } else {
            return Node3.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          if (longerHierarchy === node1Hierarchy) {
            return Node3.DOCUMENT_POSITION_PRECEDING;
          } else {
            return Node3.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    return Node3.DOCUMENT_POSITION_FOLLOWING;
  };
  _proto.contain = function contain(other) {
    return this.contains(other);
  };
  _proto.contains = function contains(other) {
    var tmp2 = other;
    while (tmp2 && this !== tmp2) {
      tmp2 = tmp2.parentNode;
    }
    return !!tmp2;
  };
  _proto.getAncestor = function getAncestor(n) {
    var temp = this;
    while (n > 0 && temp) {
      temp = temp.parentNode;
      n--;
    }
    return temp;
  };
  _proto.forEach = function forEach4(callback, assigned) {
    if (assigned === void 0) {
      assigned = false;
    }
    if (!callback(this)) {
      (assigned ? this.childNodes.slice() : this.childNodes).forEach(function(child) {
        child.forEach(callback);
      });
    }
  };
  _createClass(Node3, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        for (var _iterator = _createForOfIteratorHelperLoose(this.childNodes), _step; !(_step = _iterator()).done; ) {
          var child = _step.value;
          if (child.nodeName === Shape.TEXT) {
            out += child.nodeValue;
          } else {
            out += child.textContent;
          }
        }
        return out;
      }
    ),
    set: function set7(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "" + content;
      }
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
  }]);
  return Node3;
}(EventTarget);
Node2.DOCUMENT_POSITION_DISCONNECTED = 1;
Node2.DOCUMENT_POSITION_PRECEDING = 2;
Node2.DOCUMENT_POSITION_FOLLOWING = 4;
Node2.DOCUMENT_POSITION_CONTAINS = 8;
Node2.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var Document = function(_Node) {
  _inheritsLoose(Document2, _Node);
  function Document2() {
    var _this2;
    _this2 = _Node.call(this) || this;
    _this2.defaultView = null;
    _this2.documentElement = void 0;
    _this2.timeline = void 0;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_assertThisInitialized(_this2));
    } catch (e2) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n = _ref.n, inh = _ref.inh, d4 = _ref.d;
      if (inh && d4) {
        initialStyle[n] = isFunction(d4) ? d4(Shape.GROUP) : d4;
      }
    });
    _this2.documentElement = new Group({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _assertThisInitialized(_this2);
    _this2.documentElement.parentNode = _assertThisInitialized(_this2);
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  var _proto = Document2.prototype;
  _proto.createElement = function createElement2(tagName, options) {
    if (tagName === "svg") {
      return this.documentElement;
    }
    var clazz = this.defaultView.customElements.get(tagName);
    if (!clazz) {
      console.warn("Unsupported tagName: ", tagName);
      clazz = tagName === "tspan" ? Text : Group;
    }
    var shape = new clazz(options);
    shape.ownerDocument = this;
    return shape;
  };
  _proto.createElementNS = function createElementNS(namespaceURI, tagName, options) {
    return this.createElement(tagName, options);
  };
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.destroy = function destroy() {
    try {
      this.documentElement.destroyChildren();
      this.timeline.destroy();
    } catch (e2) {
    }
  };
  _proto.elementsFromBBox = function elementsFromBBox(minX, minY, maxX, maxY) {
    var rBush = this.defaultView.context.rBushRoot;
    var rBushNodes = rBush.search({
      minX,
      minY,
      maxX,
      maxY
    });
    var hitTestList = [];
    rBushNodes.forEach(function(_ref2) {
      var id2 = _ref2.id;
      var displayObject = runtime.displayObjectPool.getByEntity(id2);
      var pointerEvents = displayObject.parsedStyle.pointerEvents;
      var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
      if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
        hitTestList.push(displayObject);
      }
    });
    hitTestList.sort(function(a, b) {
      return b.sortable.renderOrder - a.sortable.renderOrder;
    });
    return hitTestList;
  };
  _proto.elementFromPointSync = function elementFromPointSync(x, y) {
    var _this$defaultView$can = this.defaultView.canvas2Viewport({
      x,
      y
    }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
    var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return null;
    }
    var _this$defaultView$vie = this.defaultView.viewport2Client({
      x: viewportX,
      y: viewportY
    }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
    var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
      topmost: true,
      position: {
        x,
        y,
        viewportX,
        viewportY,
        clientX,
        clientY
      },
      picked: []
    }), picked = _this$defaultView$get2.picked;
    return picked && picked[0] || this.documentElement;
  };
  _proto.elementFromPoint = function() {
    var _elementFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x, y) {
      var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x,
                y
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", null);
            case 4:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x,
                  y,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function elementFromPoint(_x, _x2) {
      return _elementFromPoint.apply(this, arguments);
    }
    return elementFromPoint;
  }();
  _proto.elementsFromPointSync = function elementsFromPointSync(x, y) {
    var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
      x,
      y
    }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
    var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return [];
    }
    var _this$defaultView$vie3 = this.defaultView.viewport2Client({
      x: viewportX,
      y: viewportY
    }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
    var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
      topmost: false,
      position: {
        x,
        y,
        viewportX,
        viewportY,
        clientX,
        clientY
      },
      picked: []
    }), picked = _this$defaultView$get5.picked;
    if (picked[picked.length - 1] !== this.documentElement) {
      picked.push(this.documentElement);
    }
    return picked;
  };
  _proto.elementsFromPoint = function() {
    var _elementsFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(x, y) {
      var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x,
                y
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", []);
            case 4:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x,
                  y,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function elementsFromPoint(_x3, _x4) {
      return _elementsFromPoint.apply(this, arguments);
    }
    return elementsFromPoint;
  }();
  _proto.appendChild = function appendChild(newChild, index) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.removeChild = function removeChild(oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.append = function append() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.prepend = function prepend() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.getElementById = function getElementById(id2) {
    return this.documentElement.getElementById(id2);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return this.documentElement.getElementsByName(name);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return this.documentElement.getElementsByTagName(tagName);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return this.documentElement.getElementsByClassName(className);
  };
  _proto.querySelector = function querySelector(selectors) {
    return this.documentElement.querySelector(selectors);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return this.documentElement.querySelectorAll(selectors);
  };
  _proto.find = function find3(filter) {
    return this.documentElement.find(filter);
  };
  _proto.findAll = function findAll(filter) {
    return this.documentElement.findAll(filter);
  };
  _createClass(Document2, [{
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
    /**
     * only document has defaultView, points to canvas,
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView
     */
  }]);
  return Document2;
}(Node2);
var Strategy;
(function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
})(Strategy || (Strategy = {}));
var ElementEvent;
(function(ElementEvent2) {
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["RENDER_ORDER_CHANGED"] = "render-order-changed";
  ElementEvent2["CULLED"] = "culled";
})(ElementEvent || (ElementEvent = {}));
var MutationEvent = function(_FederatedEvent) {
  _inheritsLoose(MutationEvent2, _FederatedEvent);
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _this2 = _FederatedEvent.call(this, null) || this;
    _this2.relatedNode = void 0;
    _this2.prevValue = void 0;
    _this2.newValue = void 0;
    _this2.attrName = void 0;
    _this2.attrChange = void 0;
    _this2.prevParsedValue = void 0;
    _this2.newParsedValue = void 0;
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  return MutationEvent2;
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = function(_Node) {
  _inheritsLoose(Element3, _Node);
  function Element3() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _Node.call.apply(_Node, [this].concat(args)) || this;
    _this2.entity = entityCounter++;
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false,
      proxyNodeName: void 0
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      frozen: false,
      // localPosition: vec3.fromValues(0, 0, 0),
      // localRotation: quat.fromValues(0, 0, 0, 1),
      // localScale: vec3.fromValues(1, 1, 1),
      // localTransform: mat4.create(),
      // localSkew: vec2.fromValues(0, 0),
      // position: vec3.fromValues(0, 0, 0),
      // rotation: quat.fromValues(0, 0, 0, 1),
      // scaling: vec3.fromValues(1, 1, 1),
      // worldTransform: mat4.create(),
      // origin: vec3.fromValues(0, 0, 0),
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: mat4_exports.create(),
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: mat4_exports.create(),
      origin: [0, 0, 0]
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      lastSortedIndex: void 0,
      renderOrder: 0
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0
    };
    _this2.rBushNode = {
      aabb: void 0
    };
    _this2.id = void 0;
    _this2.name = void 0;
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.destroyed = false;
    _this2.style = {};
    _this2.computedStyle = runtime.enableCSSParsing ? {
      anchor: unsetKeywordValue,
      opacity: unsetKeywordValue,
      fillOpacity: unsetKeywordValue,
      strokeOpacity: unsetKeywordValue,
      fill: unsetKeywordValue,
      stroke: unsetKeywordValue,
      transform: unsetKeywordValue,
      transformOrigin: unsetKeywordValue,
      visibility: unsetKeywordValue,
      pointerEvents: unsetKeywordValue,
      lineWidth: unsetKeywordValue,
      lineCap: unsetKeywordValue,
      lineJoin: unsetKeywordValue,
      increasedLineWidthForHitTesting: unsetKeywordValue,
      fontSize: unsetKeywordValue,
      fontFamily: unsetKeywordValue,
      fontStyle: unsetKeywordValue,
      fontWeight: unsetKeywordValue,
      fontVariant: unsetKeywordValue,
      textAlign: unsetKeywordValue,
      textBaseline: unsetKeywordValue,
      textTransform: unsetKeywordValue,
      zIndex: unsetKeywordValue,
      filter: unsetKeywordValue,
      shadowType: unsetKeywordValue
    } : null;
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  Element3.isElement = function isElement(target) {
    return !!target.getAttribute;
  };
  var _proto = Element3.prototype;
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.appendChild = function appendChild(child, index) {
    var _this$ownerDocument;
    if (child.destroyed) {
      throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
    }
    runtime.sceneGraphService.attach(child, this, index);
    if ((_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView) {
      this.ownerDocument.defaultView.mountChildren(child);
    }
    insertedEvent.relatedNode = this;
    child.dispatchEvent(insertedEvent);
    return child;
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    if (!refChild) {
      this.appendChild(newChild);
    } else {
      var index = this.childNodes.indexOf(refChild);
      this.appendChild(newChild, index - 1);
    }
    return newChild;
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild) {
    var index = this.childNodes.indexOf(oldChild);
    this.removeChild(oldChild);
    this.appendChild(newChild, index);
    return oldChild;
  };
  _proto.removeChild = function removeChild(child) {
    var _child$ownerDocument;
    removedEvent.relatedNode = this;
    child.dispatchEvent(removedEvent);
    if ((_child$ownerDocument = child.ownerDocument) === null || _child$ownerDocument === void 0 ? void 0 : _child$ownerDocument.defaultView) {
      child.ownerDocument.defaultView.unmountChildren(child);
    }
    runtime.sceneGraphService.detach(child);
    return child;
  };
  _proto.removeChildren = function removeChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      this.removeChild(child);
    }
  };
  _proto.destroyChildren = function destroyChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      if (child.childNodes.length) {
        child.destroyChildren();
      }
      child.destroy();
    }
  };
  _proto.matches = function matches(selector) {
    return runtime.sceneGraphService.matches(selector, this);
  };
  _proto.getElementById = function getElementById(id2) {
    return runtime.sceneGraphService.querySelector("#" + id2, this);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return runtime.sceneGraphService.querySelectorAll('[name="' + name + '"]', this);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return runtime.sceneGraphService.querySelectorAll("." + className, this);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return runtime.sceneGraphService.querySelectorAll(tagName, this);
  };
  _proto.querySelector = function querySelector(selectors) {
    return runtime.sceneGraphService.querySelector(selectors, this);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return runtime.sceneGraphService.querySelectorAll(selectors, this);
  };
  _proto.closest = function closest(selectors) {
    var el = this;
    do {
      if (runtime.sceneGraphService.matches(selectors, el))
        return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  };
  _proto.find = function find3(filter) {
    var _this2 = this;
    var target = null;
    this.forEach(function(object) {
      if (object !== _this2 && filter(object)) {
        target = object;
        return true;
      }
      return false;
    });
    return target;
  };
  _proto.findAll = function findAll(filter) {
    var _this3 = this;
    var objects = [];
    this.forEach(function(object) {
      if (object !== _this3 && filter(object)) {
        objects.push(object);
      }
    });
    return objects;
  };
  _proto.after = function after() {
    var _this4 = this;
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nodes[_key2] = arguments[_key2];
      }
      nodes.forEach(function(node, i) {
        var _this4$parentNode;
        return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index + i + 1);
      });
    }
  };
  _proto.before = function before() {
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nodes[_key3] = arguments[_key3];
      }
      var first = nodes[0], rest = nodes.slice(1);
      this.parentNode.appendChild(first, index);
      first.after.apply(first, rest);
    }
  };
  _proto.replaceWith = function replaceWith() {
    this.after.apply(this, arguments);
    this.remove();
  };
  _proto.append = function append() {
    var _this5 = this;
    for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      nodes[_key4] = arguments[_key4];
    }
    nodes.forEach(function(node) {
      return _this5.appendChild(node);
    });
  };
  _proto.prepend = function prepend() {
    var _this6 = this;
    for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      nodes[_key5] = arguments[_key5];
    }
    nodes.forEach(function(node, i) {
      return _this6.appendChild(node, i);
    });
  };
  _proto.replaceChildren = function replaceChildren() {
    while (this.childNodes.length && this.firstChild) {
      this.removeChild(this.firstChild);
    }
    this.append.apply(this, arguments);
  };
  _proto.remove = function remove() {
    if (this.parentNode) {
      return this.parentNode.removeChild(this);
    }
    return this;
  };
  _proto.destroy = function destroy() {
    this.dispatchEvent(destroyEvent);
    this.remove();
    this.emitter.removeAllListeners();
    this.destroyed = true;
  };
  _proto.getGeometryBounds = function getGeometryBounds() {
    return runtime.sceneGraphService.getGeometryBounds(this);
  };
  _proto.getRenderBounds = function getRenderBounds() {
    return runtime.sceneGraphService.getBounds(this, true);
  };
  _proto.getBounds = function getBounds() {
    return runtime.sceneGraphService.getBounds(this);
  };
  _proto.getLocalBounds = function getLocalBounds() {
    return runtime.sceneGraphService.getLocalBounds(this);
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return runtime.sceneGraphService.getBoundingClientRect(this);
  };
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  };
  _proto.computedStyleMap = function computedStyleMap() {
    return new Map(Object.entries(this.computedStyle));
  };
  _proto.getAttributeNames = function getAttributeNames() {
    return Object.keys(this.attributes);
  };
  _proto.getAttribute = function getAttribute(name) {
    if (isSymbol(name)) {
      return runtime.enableCSSParsing ? null : void 0;
    }
    var value = this.attributes[name];
    if (value === void 0) {
      var attributeName = formatAttributeName(name);
      value = this.attributes[attributeName];
      return runtime.enableCSSParsing ? is_nil_default(value) ? null : value : value;
    } else {
      return value;
    }
  };
  _proto.hasAttribute = function hasAttribute(qualifiedName) {
    return this.getAttributeNames().includes(qualifiedName);
  };
  _proto.hasAttributes = function hasAttributes() {
    return !!this.getAttributeNames().length;
  };
  _proto.removeAttribute = function removeAttribute(attributeName) {
    this.setAttribute(attributeName, null);
    delete this.attributes[attributeName];
  };
  _proto.setAttribute = function setAttribute(attributeName, value, force) {
    this.attributes[attributeName] = value;
  };
  _proto.getAttributeNS = function getAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNode = function getAttributeNode(qualifiedName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNodeNS = function getAttributeNodeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.hasAttributeNS = function hasAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNS = function removeAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNode = function removeAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNS = function setAttributeNS(namespace, qualifiedName, value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNode = function setAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNodeNS = function setAttributeNodeNS(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.toggleAttribute = function toggleAttribute(qualifiedName, force) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(Element3, [{
    key: "className",
    get: (
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set7(className) {
      this.setAttribute("class", className);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get() {
        return this.className.split(" ").filter(function(c) {
          return c !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index - 1] || null;
      }
      return null;
    }
  }]);
  return Element3;
}(Node2);
var FederatedMouseEvent = function(_FederatedEvent) {
  _inheritsLoose(FederatedMouseEvent2, _FederatedEvent);
  function FederatedMouseEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedEvent.call.apply(_FederatedEvent, [this].concat(args)) || this;
    _this2.altKey = void 0;
    _this2.button = void 0;
    _this2.buttons = void 0;
    _this2.ctrlKey = void 0;
    _this2.metaKey = void 0;
    _this2.relatedTarget = void 0;
    _this2.shiftKey = void 0;
    _this2.client = new Point();
    _this2.movement = new Point();
    _this2.offset = new Point();
    _this2.global = new Point();
    _this2.screen = new Point();
    return _this2;
  }
  var _proto = FederatedMouseEvent2.prototype;
  _proto.getModifierState = function getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  };
  _proto.initMouseEvent = function initMouseEvent() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get() {
      return this.client.y;
    }
    /**
     * The movement in this pointer relative to the last `mousemove` event.
     */
  }, {
    key: "movementX",
    get: function get() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get() {
      return this.movement.y;
    }
    /**
     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
     * not supported at the moment.
     */
  }, {
    key: "offsetX",
    get: function get() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get() {
      return this.offset.y;
    }
    /**
     * The pointer coordinates in world space.
     */
  }, {
    key: "globalX",
    get: function get() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get() {
      return this.global.y;
    }
    /**
     * The pointer coordinates in sceen space.
     */
  }, {
    key: "screenX",
    get: function get() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get() {
      return this.screen.y;
    }
  }]);
  return FederatedMouseEvent2;
}(FederatedEvent);
var FederatedPointerEvent = function(_FederatedMouseEvent) {
  _inheritsLoose(FederatedPointerEvent2, _FederatedMouseEvent);
  function FederatedPointerEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this2.pointerId = void 0;
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    _this2.pointerType = void 0;
    _this2.pressure = void 0;
    _this2.tangentialPressure = void 0;
    _this2.tiltX = void 0;
    _this2.tiltY = void 0;
    _this2.twist = void 0;
    return _this2;
  }
  var _proto = FederatedPointerEvent2.prototype;
  _proto.getCoalescedEvents = function getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  };
  _proto.getPredictedEvents = function getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  };
  _proto.clone = function clone7() {
    return this.manager.clonePointerEvent(this);
  };
  return FederatedPointerEvent2;
}(FederatedMouseEvent);
var FederatedWheelEvent = function(_FederatedMouseEvent) {
  _inheritsLoose(FederatedWheelEvent2, _FederatedMouseEvent);
  function FederatedWheelEvent2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this2.deltaMode = void 0;
    _this2.deltaX = void 0;
    _this2.deltaY = void 0;
    _this2.deltaZ = void 0;
    _this2.DOM_DELTA_LINE = 0;
    _this2.DOM_DELTA_PAGE = 1;
    _this2.DOM_DELTA_PIXEL = 2;
    return _this2;
  }
  var _proto = FederatedWheelEvent2.prototype;
  _proto.clone = function clone7() {
    return this.manager.cloneWheelEvent(this);
  };
  return FederatedWheelEvent2;
}(FederatedMouseEvent);
function isDisplayObject(value) {
  return !!(value === null || value === void 0 ? void 0 : value.nodeName);
}
var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var DEFAULT_STYLE_PROPS = {
  anchor: "",
  opacity: "",
  fillOpacity: "",
  strokeOpacity: "",
  fill: "",
  stroke: "",
  transform: "",
  transformOrigin: "",
  visibility: "",
  pointerEvents: "",
  lineWidth: "",
  lineCap: "",
  lineJoin: "",
  increasedLineWidthForHitTesting: "",
  fontSize: "",
  fontFamily: "",
  fontStyle: "",
  fontWeight: "",
  fontVariant: "",
  textAlign: "",
  textBaseline: "",
  textTransform: "",
  zIndex: "",
  filter: "",
  shadowType: ""
};
var DEFAULT_PARSED_STYLE_PROPS = {
  anchor: [0, 0],
  fill: noneColor,
  stroke: noneColor,
  transform: [],
  zIndex: 0,
  filter: [],
  shadowType: "outer",
  miterLimit: 10
};
var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = _extends({}, DEFAULT_PARSED_STYLE_PROPS, {
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  visibility: "visible",
  pointerEvents: "auto",
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  increasedLineWidthForHitTesting: 0,
  fillRule: "nonzero"
  // TODO: transformOrigin
});
var INHERITABLE_BASE_STYLE_PROPS = ["opacity", "fillOpacity", "strokeOpacity", "transformOrigin", "visibility", "pointerEvents", "lineWidth", "lineCap", "lineJoin", "increasedLineWidthForHitTesting"];
var INHERITABLE_STYLE_PROPS = [].concat(INHERITABLE_BASE_STYLE_PROPS, ["fontSize", "fontFamily", "fontStyle", "fontWeight", "fontVariant", "textAlign", "textBaseline", "textTransform"]);
var DATASET_PREFIX = "data-";
var DisplayObject = function(_Element) {
  _inheritsLoose(DisplayObject2, _Element);
  function DisplayObject2(config) {
    var _this$config$capture;
    var _this2;
    _this2 = _Element.call(this) || this;
    _this2.config = void 0;
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.dataset = void 0;
    _this2.getClip = function() {
      return this.style.clipPath || null;
    };
    _this2.config = config;
    _this2.config.interactive = (_this$config$capture = _this2.config.capture) !== null && _this$config$capture !== void 0 ? _this$config$capture : _this2.config.interactive;
    _this2.id = _this2.config.id || "";
    _this2.name = _this2.config.name || "";
    if (_this2.config.className || _this2.config.class) {
      _this2.className = _this2.config.className || _this2.config.class;
    }
    _this2.nodeName = _this2.config.type || Shape.GROUP;
    _this2.config.style = _this2.config.style || _this2.config.attrs || {};
    Object.assign(_this2.config.style, _this2.config.attrs);
    if (_this2.config.visible != null) {
      _this2.config.style.visibility = _this2.config.visible === false ? "hidden" : "visible";
    }
    if (_this2.config.interactive != null) {
      _this2.config.style.pointerEvents = _this2.config.interactive === false ? "none" : "auto";
    }
    Object.assign(_this2.parsedStyle, runtime.enableCSSParsing ? DEFAULT_PARSED_STYLE_PROPS : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this2.config.initialParsedStyle);
    if (runtime.enableCSSParsing) {
      Object.assign(_this2.attributes, DEFAULT_STYLE_PROPS);
    }
    _this2.initAttributes(_this2.config.style);
    _this2.dataset = new Proxy({}, {
      get: function get(target, name) {
        var formattedName = "" + DATASET_PREFIX + kebabize(name);
        if (target[formattedName] !== void 0) {
          return target[formattedName];
        }
        return _this2.getAttribute(formattedName);
      },
      set: function set7(_2, prop, value) {
        _this2.setAttribute("" + DATASET_PREFIX + kebabize(prop), value);
        return true;
      }
    });
    _this2.style = new Proxy(
      // @ts-ignore
      {
        // ...this.attributes,
        setProperty: function setProperty(propertyName, value) {
          _this2.setAttribute(propertyName, value);
        },
        getPropertyValue: function getPropertyValue(propertyName) {
          return _this2.getAttribute(propertyName);
        },
        removeProperty: function removeProperty(propertyName) {
          _this2.removeAttribute(propertyName);
        },
        item: function item() {
          return "";
        }
      },
      {
        get: function get(target, name) {
          if (target[name] !== void 0) {
            return target[name];
          }
          return _this2.getAttribute(name);
        },
        set: function set7(_2, prop, value) {
          _this2.setAttribute(prop, value);
          return true;
        }
      }
    );
    runtime.displayObjectPool.add(_this2.entity, _assertThisInitialized(_this2));
    return _this2;
  }
  var _proto = DisplayObject2.prototype;
  _proto.destroy = function destroy() {
    _Element.prototype.destroy.call(this);
    runtime.displayObjectPool.remove(this.entity);
    this.getAnimations().forEach(function(animation) {
      animation.cancel();
    });
  };
  _proto.cloneNode = function cloneNode(deep, customCloneFunc) {
    var clonedStyle = _extends({}, this.attributes);
    for (var attributeName in clonedStyle) {
      var attribute = clonedStyle[attributeName];
      if (isDisplayObject(attribute) && // share the same clipPath if possible
      attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
        clonedStyle[attributeName] = attribute.cloneNode(deep);
      }
      if (customCloneFunc) {
        clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
      }
    }
    var cloned = new this.constructor({
      // copy id & name
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
      id: this.id,
      name: this.name,
      className: this.name,
      interactive: this.interactive,
      style: clonedStyle
    });
    cloned.setLocalTransform(this.getLocalTransform());
    if (deep) {
      this.children.forEach(function(child) {
        if (!child.style.isMarker) {
          var clonedChild = child.cloneNode(deep);
          cloned.appendChild(clonedChild);
        }
      });
    }
    return cloned;
  };
  _proto.initAttributes = function initAttributes(attributes) {
    if (attributes === void 0) {
      attributes = {};
    }
    var renderable = this.renderable;
    var options = {
      forceUpdateGeometry: true
      // usedAttributes:
      //   // only Group / Text should account for text relative props
      //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
      //     ? INHERITABLE_STYLE_PROPS
      //     : INHERITABLE_BASE_STYLE_PROPS,
    };
    if (runtime.enableCSSParsing) {
      options.usedAttributes = INHERITABLE_STYLE_PROPS;
    }
    runtime.styleValueRegistry.processProperties(this, attributes, options);
    renderable.dirty = true;
  };
  _proto.setAttribute = function setAttribute(name, value, force) {
    if (force === void 0) {
      force = false;
    }
    var attributeName = formatAttributeName(name);
    if (is_undefined_default(value)) {
      return;
    }
    if (force || value !== this.attributes[attributeName]) {
      this.internalSetAttribute(attributeName, value);
      _Element.prototype.setAttribute.call(this, attributeName, value);
    }
  };
  _proto.internalSetAttribute = function internalSetAttribute(name, value, parseOptions) {
    var _runtime$styleValueRe;
    if (parseOptions === void 0) {
      parseOptions = {};
    }
    var renderable = this.renderable;
    var oldValue = this.attributes[name];
    var oldParsedValue = this.parsedStyle[name];
    runtime.styleValueRegistry.processProperties(this, (_runtime$styleValueRe = {}, _runtime$styleValueRe[name] = value, _runtime$styleValueRe), parseOptions);
    renderable.dirty = true;
    var newParsedValue = this.parsedStyle[name];
    if (this.isConnected) {
      mutationEvent.relatedNode = this;
      mutationEvent.prevValue = oldValue;
      mutationEvent.newValue = value;
      mutationEvent.attrName = name;
      mutationEvent.prevParsedValue = oldParsedValue;
      mutationEvent.newParsedValue = newParsedValue;
      if (this.isMutationObserved) {
        this.dispatchEvent(mutationEvent);
      } else {
        mutationEvent.target = this;
        this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
      }
    }
    if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
      this.attributeChangedCallback(name, oldValue, value, oldParsedValue, newParsedValue);
    }
  };
  _proto.getBBox = function getBBox() {
    var aabb = this.getBounds();
    var _aabb$getMin = aabb.getMin(), left = _aabb$getMin[0], top = _aabb$getMin[1];
    var _aabb$getMax = aabb.getMax(), right = _aabb$getMax[0], bottom = _aabb$getMax[1];
    return new Rectangle(left, top, right - left, bottom - top);
  };
  _proto.setOrigin = function setOrigin(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z));
    return this;
  };
  _proto.getOrigin = function getOrigin() {
    return runtime.sceneGraphService.getOrigin(this);
  };
  _proto.setPosition = function setPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setPosition(this, createVec3(position, y, z));
    return this;
  };
  _proto.setLocalPosition = function setLocalPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z));
    return this;
  };
  _proto.translate = function translate3(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translate(this, createVec3(position, y, z));
    return this;
  };
  _proto.translateLocal = function translateLocal(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z));
    return this;
  };
  _proto.getPosition = function getPosition2() {
    return runtime.sceneGraphService.getPosition(this);
  };
  _proto.getLocalPosition = function getLocalPosition() {
    return runtime.sceneGraphService.getLocalPosition(this);
  };
  _proto.scale = function scale8(scaling, y, z) {
    return this.scaleLocal(scaling, y, z);
  };
  _proto.scaleLocal = function scaleLocal(scaling, y, z) {
    if (typeof scaling === "number") {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.scaleLocal(this, scaling);
    return this;
  };
  _proto.setLocalScale = function setLocalScale(scaling, y, z) {
    if (typeof scaling === "number") {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.setLocalScale(this, scaling);
    return this;
  };
  _proto.getLocalScale = function getLocalScale() {
    return runtime.sceneGraphService.getLocalScale(this);
  };
  _proto.getScale = function getScale() {
    return runtime.sceneGraphService.getScale(this);
  };
  _proto.getEulerAngles = function getEulerAngles() {
    var _getEuler = getEuler(vec3_exports.create(), runtime.sceneGraphService.getWorldTransform(this)), ez = _getEuler[2];
    return rad2deg2(ez);
  };
  _proto.getLocalEulerAngles = function getLocalEulerAngles() {
    var _getEuler2 = getEuler(vec3_exports.create(), runtime.sceneGraphService.getLocalRotation(this)), ez = _getEuler2[2];
    return rad2deg2(ez);
  };
  _proto.setEulerAngles = function setEulerAngles(z) {
    runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
    return this;
  };
  _proto.setLocalEulerAngles = function setLocalEulerAngles(z) {
    runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
    return this;
  };
  _proto.rotateLocal = function rotateLocal(x, y, z) {
    if (is_nil_default(y) && is_nil_default(z)) {
      runtime.sceneGraphService.rotateLocal(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotateLocal(this, x, y, z);
    }
    return this;
  };
  _proto.rotate = function rotate5(x, y, z) {
    if (is_nil_default(y) && is_nil_default(z)) {
      runtime.sceneGraphService.rotate(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotate(this, x, y, z);
    }
    return this;
  };
  _proto.setRotation = function setRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalRotation = function setLocalRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalSkew = function setLocalSkew(skew, y) {
    runtime.sceneGraphService.setLocalSkew(this, skew, y);
    return this;
  };
  _proto.getRotation = function getRotation2() {
    return runtime.sceneGraphService.getRotation(this);
  };
  _proto.getLocalRotation = function getLocalRotation() {
    return runtime.sceneGraphService.getLocalRotation(this);
  };
  _proto.getLocalSkew = function getLocalSkew() {
    return runtime.sceneGraphService.getLocalSkew(this);
  };
  _proto.getLocalTransform = function getLocalTransform() {
    return runtime.sceneGraphService.getLocalTransform(this);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return runtime.sceneGraphService.getWorldTransform(this);
  };
  _proto.setLocalTransform = function setLocalTransform(transform) {
    runtime.sceneGraphService.setLocalTransform(this, transform);
    return this;
  };
  _proto.resetLocalTransform = function resetLocalTransform() {
    runtime.sceneGraphService.resetLocalTransform(this);
  };
  _proto.getAnimations = function getAnimations() {
    return this.activeAnimations;
  };
  _proto.animate = function animate(keyframes, options) {
    var _this$ownerDocument;
    var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
    if (timeline) {
      return timeline.play(this, keyframes, options);
    }
    return null;
  };
  _proto.isVisible = function isVisible() {
    var _this$parsedStyle;
    return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) === "visible";
  };
  _proto.isInteractive = function isInteractive() {
    var _this$parsedStyle2;
    return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
  };
  _proto.isCulled = function isCulled() {
    return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
  };
  _proto.toFront = function toFront() {
    if (this.parentNode) {
      this.style.zIndex = Math.max.apply(Math, this.parentNode.children.map(function(child) {
        return Number(child.style.zIndex);
      })) + 1;
    }
    return this;
  };
  _proto.toBack = function toBack() {
    if (this.parentNode) {
      this.style.zIndex = Math.min.apply(Math, this.parentNode.children.map(function(child) {
        return Number(child.style.zIndex);
      })) - 1;
    }
    return this;
  };
  _proto.getConfig = function getConfig() {
    return this.config;
  };
  _proto.attr = function attr() {
    var _this2 = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var name = args[0], value = args[1];
    if (!name) {
      return this.attributes;
    }
    if (is_object_default(name)) {
      Object.keys(name).forEach(function(key) {
        _this2.setAttribute(key, name[key]);
      });
      return this;
    }
    if (args.length === 2) {
      this.setAttribute(name, value);
      return this;
    }
    return this.attributes[name];
  };
  _proto.getMatrix = function getMatrix(transformMat44) {
    var transform = transformMat44 || this.getWorldTransform();
    var _mat4$getTranslation = mat4_exports.getTranslation(vec3_exports.create(), transform), tx = _mat4$getTranslation[0], ty = _mat4$getTranslation[1];
    var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), transform), sx = _mat4$getScaling[0], sy = _mat4$getScaling[1];
    var rotation = mat4_exports.getRotation(quat_exports.create(), transform);
    var _getEuler3 = getEuler(vec3_exports.create(), rotation), eux = _getEuler3[0], euz = _getEuler3[2];
    return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
  };
  _proto.getLocalMatrix = function getLocalMatrix() {
    return this.getMatrix(this.getLocalTransform());
  };
  _proto.setMatrix = function setMatrix(mat) {
    var _decompose = decompose(mat), tx = _decompose[0], ty = _decompose[1], scalingX = _decompose[2], scalingY = _decompose[3], angle3 = _decompose[4];
    this.setEulerAngles(angle3).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
  };
  _proto.setLocalMatrix = function setLocalMatrix(mat) {
    var _decompose2 = decompose(mat), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle3 = _decompose2[4];
    this.setLocalEulerAngles(angle3).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
  };
  _proto.show = function show() {
    this.style.visibility = "visible";
  };
  _proto.hide = function hide() {
    this.style.visibility = "hidden";
  };
  _proto.getCount = function getCount() {
    return this.childElementCount;
  };
  _proto.getParent = function getParent() {
    return this.parentElement;
  };
  _proto.getChildren = function getChildren() {
    return this.children;
  };
  _proto.getFirst = function getFirst() {
    return this.firstElementChild;
  };
  _proto.getLast = function getLast() {
    return this.lastElementChild;
  };
  _proto.getChildByIndex = function getChildByIndex(index) {
    return this.children[index] || null;
  };
  _proto.add = function add7(child, index) {
    return this.appendChild(child, index);
  };
  _proto.setClip = function setClip(clipPath) {
    this.style.clipPath = clipPath;
  };
  _proto.set = function set7(name, value) {
    this.config[name] = value;
  };
  _proto.get = function get(name) {
    return this.config[name];
  };
  _proto.moveTo = function moveTo(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  };
  _proto.move = function move(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  };
  _proto.setZIndex = function setZIndex(zIndex) {
    this.style.zIndex = zIndex;
    return this;
  };
  _createClass(DisplayObject2, [{
    key: "interactive",
    get: function get() {
      return this.isInteractive();
    },
    set: function set7(b) {
      this.style.pointerEvents = b ? "auto" : "none";
    }
  }]);
  return DisplayObject2;
}(Element2);
var _excluded = ["style"];
var Circle = function(_DisplayObject) {
  _inheritsLoose(Circle2, _DisplayObject);
  function Circle2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _DisplayObject.call(this, _extends({
      type: Shape.CIRCLE,
      style: runtime.enableCSSParsing ? _extends({
        cx: "",
        cy: "",
        r: ""
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, "%"), getOrCreateUnitValue(50, "%")]
      }
    }, rest)) || this;
  }
  return Circle2;
}(DisplayObject);
var _excluded$1 = ["style"];
var CustomElement = function(_DisplayObject) {
  _inheritsLoose(CustomElement2, _DisplayObject);
  function CustomElement2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    _this2 = _DisplayObject.call(this, _extends({
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this2.isCustomElement = true;
    return _this2;
  }
  return CustomElement2;
}(DisplayObject);
var pool = {};
var htmlPool = [];
var DisplayObjectPool = function() {
  function DisplayObjectPool2() {
  }
  var _proto = DisplayObjectPool2.prototype;
  _proto.getByEntity = function getByEntity(entity) {
    return pool[entity];
  };
  _proto.getAll = function getAll() {
    return Object.keys(pool).map(function(entity) {
      return pool[entity];
    });
  };
  _proto.add = function add7(entity, groupOrShape) {
    pool[entity] = groupOrShape;
    if (groupOrShape.nodeName === Shape.HTML) {
      htmlPool.push(groupOrShape);
    }
  };
  _proto.remove = function remove(entity) {
    var existed = pool[entity];
    if (existed) {
      delete pool[entity];
      if (existed.nodeName === Shape.HTML) {
        var index = htmlPool.indexOf(existed);
        htmlPool.splice(index, 1);
      }
    }
  };
  _proto.getHTMLs = function getHTMLs() {
    return htmlPool;
  };
  return DisplayObjectPool2;
}();
var _excluded$2 = ["style"];
var Ellipse = function(_DisplayObject) {
  _inheritsLoose(Ellipse2, _DisplayObject);
  function Ellipse2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    return _DisplayObject.call(this, _extends({
      type: Shape.ELLIPSE,
      style: runtime.enableCSSParsing ? _extends({
        cx: "",
        cy: "",
        rx: "",
        ry: ""
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, "%"), getOrCreateUnitValue(50, "%")]
      }
    }, rest)) || this;
  }
  return Ellipse2;
}(DisplayObject);
var _excluded$3 = ["style"];
var Group = function(_DisplayObject) {
  _inheritsLoose(Group2, _DisplayObject);
  function Group2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
    return _DisplayObject.call(this, _extends({
      type: Shape.GROUP,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "",
        height: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Group2;
}(DisplayObject);
var _excluded$4 = ["style"];
var HTML = function(_DisplayObject) {
  _inheritsLoose(HTML2, _DisplayObject);
  function HTML2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.HTML,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "auto",
        height: "auto",
        innerHTML: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this2.cullable.enable = false;
    return _this2;
  }
  var _proto = HTML2.prototype;
  _proto.getDomElement = function getDomElement() {
    return this.parsedStyle.$el;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return this.parsedStyle.$el.getBoundingClientRect();
  };
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  };
  _proto.getBounds = function getBounds() {
    var _this$ownerDocument, _this$ownerDocument$d;
    var clientRect = this.getBoundingClientRect();
    var canvasRect = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : (_this$ownerDocument$d = _this$ownerDocument.defaultView) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.getContextService().getBoundingClientRect();
    if (canvasRect) {
      var minX = clientRect.left - canvasRect.left;
      var minY = clientRect.top - canvasRect.top;
      var aabb = new AABB();
      aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
      return aabb;
    }
    return null;
  };
  _proto.getLocalBounds = function getLocalBounds() {
    if (this.parentNode) {
      var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
      var bounds = this.getBounds();
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds();
  };
  return HTML2;
}(DisplayObject);
var _excluded$5 = ["style"];
var Image = function(_DisplayObject) {
  _inheritsLoose(Image2, _DisplayObject);
  function Image2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$5);
    return _DisplayObject.call(this, _extends({
      type: Shape.IMAGE,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        img: "",
        width: "",
        height: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Image2;
}(DisplayObject);
var _excluded$6 = ["style"];
var Line = function(_DisplayObject) {
  _inheritsLoose(Line2, _DisplayObject);
  function Line2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$6);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.LINE,
      style: _extends({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0,
        isBillboard: false
      }, style)
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Line2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x2 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y2 = _this$parsedStyle2.y2, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      ox = x1 - defX;
      oy = y1 - defY;
      x = x2 - x1;
      y = y2 - y1;
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      ox = x2 - defX;
      oy = y2 - defY;
      x = x1 - x2;
      y = y1 - y2;
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x2 = _this$parsedStyle3.x2, y2 = _this$parsedStyle3.y2, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    var _LineUtil$pointAt = line.pointAt(x1, y1, x2, y2, ratio), x = _LineUtil$pointAt.x, y = _LineUtil$pointAt.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getPointAtLength = function getPointAtLength2(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
  };
  _proto.getTotalLength = function getTotalLength2() {
    var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x2 = _this$parsedStyle4.x2, y2 = _this$parsedStyle4.y2;
    return line.length(x1, y1, x2, y2);
  };
  return Line2;
}(DisplayObject);
var _excluded$7 = ["style"];
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var Path = function(_DisplayObject) {
  _inheritsLoose(Path2, _DisplayObject);
  function Path2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$7);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.PATH,
      style: runtime.enableCSSParsing ? _extends({
        path: "",
        miterLimit: ""
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        miterLimit: 4,
        path: _extends({}, EMPTY_PARSED_PATH)
      }
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Path2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "path") {
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === "markerMid") {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      var _this$getStartTangent = this.getStartTangent(), p1 = _this$getStartTangent[0], p2 = _this$getStartTangent[1];
      ox = p2[0] - defX;
      oy = p2[1] - defY;
      x = p1[0] - p2[0];
      y = p1[1] - p2[1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var _this$getEndTangent = this.getEndTangent(), _p = _this$getEndTangent[0], _p2 = _this$getEndTangent[1];
      ox = _p2[0] - defX;
      oy = _p2[1] - defY;
      x = _p[0] - _p2[0];
      y = _p[1] - _p2[1];
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle, segments = _this$parsedStyle3.path.segments, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    this.markerMidList.forEach(function(marker2) {
      marker2.remove();
    });
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < segments.length - 1; i++) {
        var _segments$i$currentPo = segments[i].currentPoint, ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox - defX, oy - defY);
      }
    }
  };
  _proto.getTotalLength = function getTotalLength2() {
    return getOrCalculatePathTotalLength(this);
  };
  _proto.getPointAtLength = function getPointAtLength$1(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle4 = this.parsedStyle, defX = _this$parsedStyle4.defX, defY = _this$parsedStyle4.defY, absolutePath = _this$parsedStyle4.path.absolutePath;
    var _getPointAtLength2 = getPointAtLength(absolutePath, distance6), x = _getPointAtLength2.x, y = _getPointAtLength2.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
  };
  _proto.getStartTangent = function getStartTangent() {
    var segments = this.parsedStyle.path.segments;
    var result = [];
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  _proto.getEndTangent = function getEndTangent() {
    var segments = this.parsedStyle.path.segments;
    var length14 = segments.length;
    var result = [];
    if (length14 > 1) {
      var startPoint = segments[length14 - 2].currentPoint;
      var endPoint = segments[length14 - 1].currentPoint;
      var tangent = segments[length14 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path2;
}(DisplayObject);
var _excluded$8 = ["style"];
var Polygon = function(_DisplayObject) {
  _inheritsLoose(Polygon2, _DisplayObject);
  function Polygon2(_temp) {
    var _this2;
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$8);
    _this2 = _DisplayObject.call(this, _extends({
      type: Shape.POLYGON,
      style: runtime.enableCSSParsing ? _extends({
        points: "",
        miterLimit: "",
        isClosed: true
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)) || this;
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  var _proto = Polygon2.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === "points") {
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === "markerStart") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === "markerEnd") {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === "markerMid") {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, points = _this$parsedStyle2.points.points, defX = _this$parsedStyle2.defX, defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad2 = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    ox = points[0][0] - defX;
    oy = points[0][1] - defY;
    if (isStart) {
      x = points[1][0] - points[0][0];
      y = points[1][1] - points[0][1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var length14 = points.length;
      if (!this.parsedStyle.isClosed) {
        ox = points[length14 - 1][0] - defX;
        oy = points[length14 - 1][1] - defY;
        x = points[length14 - 2][0] - points[length14 - 1][0];
        y = points[length14 - 2][1] - points[length14 - 1][1];
      } else {
        x = points[length14 - 1][0] - points[0][0];
        y = points[length14 - 1][1] - points[0][1];
      }
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad2 = Math.atan2(y, x);
    marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle, points = _this$parsedStyle3.points.points, defX = _this$parsedStyle3.defX, defY = _this$parsedStyle3.defY;
    this.markerMidList.forEach(function(marker2) {
      marker2.remove();
    });
    this.markerMidList = [];
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
        var ox = points[i][0] - defX;
        var oy = points[i][1] - defY;
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox, oy);
      }
    }
  };
  return Polygon2;
}(DisplayObject);
var _excluded$9 = ["style"];
var Polyline = function(_Polygon) {
  _inheritsLoose(Polyline2, _Polygon);
  function Polyline2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$9);
    return _Polygon.call(this, _extends({
      type: Shape.POLYLINE,
      style: runtime.enableCSSParsing ? _extends({
        points: "",
        miterLimit: "",
        isClosed: false
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)) || this;
  }
  var _proto = Polyline2.prototype;
  _proto.getTotalLength = function getTotalLength2() {
    return this.parsedStyle.points.totalLength;
  };
  _proto.getPointAtLength = function getPointAtLength2(distance6, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
  };
  _proto.getPoint = function getPoint3(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle = this.parsedStyle, defX = _this$parsedStyle.defX, defY = _this$parsedStyle.defY, _this$parsedStyle$poi = _this$parsedStyle.points, points = _this$parsedStyle$poi.points, segments = _this$parsedStyle$poi.segments;
    var subt = 0;
    var index = 0;
    segments.forEach(function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var _LineUtil$pointAt = line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt), x = _LineUtil$pointAt.x, y = _LineUtil$pointAt.y;
    var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getStartTangent = function getStartTangent() {
    var points = this.parsedStyle.points.points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  _proto.getEndTangent = function getEndTangent() {
    var points = this.parsedStyle.points.points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return Polyline2;
}(Polygon);
var _excluded$a = ["style"];
var Rect = function(_DisplayObject) {
  _inheritsLoose(Rect2, _DisplayObject);
  function Rect2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$a);
    return _DisplayObject.call(this, _extends({
      type: Shape.RECT,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        width: "",
        height: "",
        radius: ""
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Rect2;
}(DisplayObject);
var _excluded$b = ["style"];
var Text = function(_DisplayObject) {
  _inheritsLoose(Text2, _DisplayObject);
  function Text2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, style = _ref.style, rest = _objectWithoutPropertiesLoose(_ref, _excluded$b);
    return _DisplayObject.call(this, _extends({
      type: Shape.TEXT,
      style: runtime.enableCSSParsing ? _extends({
        x: "",
        y: "",
        text: "",
        fontSize: "",
        fontFamily: "",
        fontStyle: "",
        fontWeight: "",
        fontVariant: "",
        textAlign: "",
        textBaseline: "",
        textTransform: "",
        fill: "black",
        letterSpacing: "",
        lineHeight: "",
        miterLimit: "",
        // whiteSpace: 'pre',
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: "",
        dy: ""
      }, style) : _extends({
        fill: "black"
      }, style),
      initialParsedStyle: runtime.enableCSSParsing ? {} : {
        x: 0,
        y: 0,
        fontSize: 16,
        fontFamily: "sans-serif",
        fontStyle: "normal",
        fontWeight: "normal",
        fontVariant: "normal",
        lineHeight: 0,
        letterSpacing: 0,
        textBaseline: "alphabetic",
        textAlign: "start",
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: 0,
        dy: 0
      }
    }, rest)) || this;
  }
  var _proto = Text2.prototype;
  _proto.getComputedTextLength = function getComputedTextLength() {
    var _this$parsedStyle$met;
    return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
  };
  _proto.getLineBoundingRects = function getLineBoundingRects() {
    var _this$parsedStyle$met2;
    return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
  };
  _proto.isOverflowing = function isOverflowing() {
    return !!this.parsedStyle.isOverflowing;
  };
  return Text2;
}(DisplayObject);
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    int: true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    int: true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    int: true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    int: true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    int: true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    int: true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    int: true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    // int: true,
    d: function d(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "center";
      }
      if (nodeName === Shape.TEXT) {
        return "text-anchor";
      }
      return "left top";
    },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "anchor",
    p: 99,
    d: function d2(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "0.5 0.5";
      }
      return "0 0";
    },
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  // <circle> & <ellipse>
  {
    n: "cx",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "path",
    int: true,
    l: true,
    d: "",
    a: ["d"],
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    int: true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d3(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  }
];
var propertyMetadataCache = {};
var unresolvedProperties = /* @__PURE__ */ new WeakMap();
var isPropertyResolved = function isPropertyResolved2(object, name) {
  var properties = unresolvedProperties.get(object);
  if (!properties || properties.length === 0) {
    return true;
  }
  return properties.includes(name);
};
var DefaultStyleValueRegistry = function() {
  function DefaultStyleValueRegistry2() {
    var _this2 = this;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  var _proto = DefaultStyleValueRegistry2.prototype;
  _proto.registerMetadata = function registerMetadata(metadata) {
    [metadata.n].concat(metadata.a || []).forEach(function(name) {
      propertyMetadataCache[name] = metadata;
    });
  };
  _proto.unregisterMetadata = function unregisterMetadata(name) {
    delete propertyMetadataCache[name];
  };
  _proto.getPropertySyntax = function getPropertySyntax(syntax) {
    return runtime.CSSPropertySyntaxFactory[syntax];
  };
  _proto.processProperties = function processProperties(object, attributes, options) {
    var _this2 = this;
    if (options === void 0) {
      options = {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: []
      };
    }
    if (!runtime.enableCSSParsing) {
      if (attributes.src) {
        attributes.img = attributes.src;
      }
      if (attributes.d) {
        attributes.path = attributes.d;
      }
      if (attributes.strokeDasharray) {
        attributes.lineDash = attributes.strokeDasharray;
      }
      if (attributes.strokeWidth) {
        attributes.lineWidth = attributes.strokeWidth;
      }
      if (attributes.textAnchor) {
        attributes.textAlign = attributes.textAnchor;
      }
      Object.assign(object.attributes, attributes);
      var _attributeNames = Object.keys(attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      object.parsedStyle = Object.assign(object.parsedStyle, attributes);
      if (attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (!is_nil_default(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (!is_nil_default(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
      }
      if (attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points, object);
      }
      if (attributes.path === "") {
        object.parsedStyle.path = _extends({}, EMPTY_PARSED_PATH);
      }
      if (attributes.path) {
        object.parsedStyle.path = parsePath(
          // @ts-ignore
          attributes.path,
          object
        );
      }
      if (attributes.textTransform) {
        runtime.CSSPropertySyntaxFactory["<text-transform>"].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (attributes.clipPath) {
        runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("clipPath", oldClipPath, attributes.clipPath, object, this);
      }
      if (attributes.offsetPath) {
        runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this);
      }
      if (attributes.anchor) {
        object.parsedStyle.anchor = parseDimensionArrayFormat(
          // @ts-ignorex
          attributes.anchor,
          2
        );
      }
      if (attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (attributes.markerStart) {
        object.parsedStyle.markerStart = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (attributes.markerEnd) {
        object.parsedStyle.markerEnd = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (attributes.markerMid) {
        object.parsedStyle.markerMid = runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (
        // Circle & Ellipse
        (object.nodeName === Shape.CIRCLE || object.nodeName === Shape.ELLIPSE) && // @ts-ignore
        (!is_nil_default(attributes.cx) || // @ts-ignore
        !is_nil_default(attributes.cy)) || (object.nodeName === Shape.RECT || object.nodeName === Shape.IMAGE || object.nodeName === Shape.GROUP || object.nodeName === Shape.HTML || object.nodeName === Shape.TEXT || object.nodeName === Shape.MESH) && // @ts-ignore
        (!is_nil_default(attributes.x) || // @ts-ignore
        !is_nil_default(attributes.y) || // @ts-ignore
        !is_nil_default(attributes.z)) || // Line
        object.nodeName === Shape.LINE && // @ts-ignore
        (!is_nil_default(attributes.x1) || // @ts-ignore
        !is_nil_default(attributes.y1) || // @ts-ignore
        !is_nil_default(attributes.z1) || // @ts-ignore
        !is_nil_default(attributes.x2) || // @ts-ignore
        !is_nil_default(attributes.y2) || // @ts-ignore
        !is_nil_default(attributes.z2))
      ) {
        runtime.CSSPropertySyntaxFactory["<coordinate>"].postProcessor(object, _attributeNames);
      }
      if (!is_nil_default(attributes.zIndex)) {
        runtime.CSSPropertySyntaxFactory["<z-index>"].postProcessor(object, _attributeNames);
      }
      if (attributes.path) {
        runtime.CSSPropertySyntaxFactory["<path>"].postProcessor(object, _attributeNames);
      }
      if (attributes.points) {
        runtime.CSSPropertySyntaxFactory["<list-of-points>"].postProcessor(object, _attributeNames);
      }
      if (!is_nil_default(attributes.offsetDistance)) {
        runtime.CSSPropertySyntaxFactory["<offset-distance>"].postProcessor(object, _attributeNames);
      }
      if (attributes.transform) {
        runtime.CSSPropertySyntaxFactory["<transform>"].postProcessor(object, _attributeNames);
      }
      this.updateGeometry(object);
      return;
    }
    var _options = options, skipUpdateAttribute = _options.skipUpdateAttribute, skipParse = _options.skipParse, forceUpdateGeometry = _options.forceUpdateGeometry, usedAttributes = _options.usedAttributes;
    var needUpdateGeometry = forceUpdateGeometry;
    var attributeNames = Object.keys(attributes);
    attributeNames.forEach(function(attributeName) {
      var _propertyMetadataCach;
      var name = formatAttributeName(attributeName);
      if (!skipUpdateAttribute) {
        object.attributes[name] = attributes[attributeName];
      }
      if (!needUpdateGeometry && ((_propertyMetadataCach = propertyMetadataCache[name]) === null || _propertyMetadataCach === void 0 ? void 0 : _propertyMetadataCach.l)) {
        needUpdateGeometry = true;
      }
    });
    if (!skipParse) {
      attributeNames.forEach(function(name) {
        object.computedStyle[name] = _this2.parseProperty(name, object.attributes[name], object);
      });
    }
    if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
      attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
    }
    attributeNames.forEach(function(name) {
      if (name in object.computedStyle) {
        object.parsedStyle[name] = _this2.computeProperty(name, object.computedStyle[name], object);
      }
    });
    if (needUpdateGeometry) {
      this.updateGeometry(object);
    }
    attributeNames.forEach(function(name) {
      if (name in object.parsedStyle) {
        _this2.postProcessProperty(name, object, attributeNames);
      }
    });
    if (runtime.enableCSSParsing && object.children.length) {
      attributeNames.forEach(function(name) {
        if (name in object.parsedStyle && _this2.isPropertyInheritable(name)) {
          object.children.forEach(function(child) {
            child.internalSetAttribute(name, null, {
              skipUpdateAttribute: true,
              skipParse: true
            });
          });
        }
      });
    }
  };
  _proto.parseProperty = function parseProperty(name, value, object) {
    var metadata = propertyMetadataCache[name];
    var computed = value;
    if (value === "" || is_nil_default(value)) {
      value = "unset";
    }
    if (value === "unset" || value === "initial" || value === "inherit") {
      computed = getOrCreateKeyword(value);
    } else {
      if (metadata) {
        var keywords = metadata.k, syntax = metadata.syntax;
        var handler = syntax && this.getPropertySyntax(syntax);
        if (keywords && keywords.indexOf(value) > -1) {
          computed = getOrCreateKeyword(value);
        } else if (handler && handler.parser) {
          computed = handler.parser(value, object);
        }
      }
    }
    return computed;
  };
  _proto.computeProperty = function computeProperty(name, computed, object) {
    var metadata = propertyMetadataCache[name];
    var isDocumentElement = object.id === "g-root";
    var used = computed;
    if (metadata) {
      var syntax = metadata.syntax, inherited = metadata.inh, defaultValue = metadata.d;
      if (computed instanceof CSSKeywordValue) {
        var value = computed.value;
        if (value === "unset") {
          if (inherited && !isDocumentElement) {
            value = "inherit";
          } else {
            value = "initial";
          }
        }
        if (value === "initial") {
          if (!is_nil_default(defaultValue)) {
            computed = this.parseProperty(name, isFunction(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object);
          }
        } else if (value === "inherit") {
          var resolved = this.tryToResolveProperty(object, name, {
            inherited: true
          });
          if (!is_nil_default(resolved)) {
            return resolved;
          } else {
            this.addUnresolveProperty(object, name);
            return;
          }
        }
      }
      var handler = syntax && this.getPropertySyntax(syntax);
      if (handler && handler.calculator) {
        var oldParsedValue = object.parsedStyle[name];
        used = handler.calculator(name, oldParsedValue, computed, object, this);
      } else if (computed instanceof CSSKeywordValue) {
        used = computed.value;
      } else {
        used = computed;
      }
    }
    return used;
  };
  _proto.postProcessProperty = function postProcessProperty(name, object, attributes) {
    var metadata = propertyMetadataCache[name];
    if (metadata && metadata.syntax) {
      var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
      var propertyHandler = handler;
      if (propertyHandler && propertyHandler.postProcessor) {
        propertyHandler.postProcessor(object, attributes);
      }
    }
  };
  _proto.addUnresolveProperty = function addUnresolveProperty(object, name) {
    var properties = unresolvedProperties.get(object);
    if (!properties) {
      unresolvedProperties.set(object, []);
      properties = unresolvedProperties.get(object);
    }
    if (properties.indexOf(name) === -1) {
      properties.push(name);
    }
  };
  _proto.tryToResolveProperty = function tryToResolveProperty(object, name, options) {
    if (options === void 0) {
      options = {};
    }
    var _options2 = options, inherited = _options2.inherited;
    if (inherited) {
      if (object.parentElement && isPropertyResolved(object.parentElement, name)) {
        var usedValue = object.parentElement.parsedStyle[name];
        if (
          // usedValue instanceof CSSKeywordValue &&
          usedValue === "unset" || usedValue === "initial" || usedValue === "inherit"
        ) {
          return;
        }
        return usedValue;
      }
    }
    return;
  };
  _proto.recalc = function recalc(object) {
    var properties = unresolvedProperties.get(object);
    if (properties && properties.length) {
      var attributes = {};
      properties.forEach(function(property) {
        attributes[property] = object.attributes[property];
      });
      this.processProperties(object, attributes);
      unresolvedProperties.delete(object);
    }
  };
  _proto.updateGeometry = function updateGeometry(object) {
    var geometryUpdater = runtime.geometryUpdaterFactory[object.nodeName];
    if (geometryUpdater) {
      var geometry = object.geometry;
      if (!geometry.contentBounds) {
        geometry.contentBounds = new AABB();
      }
      if (!geometry.renderBounds) {
        geometry.renderBounds = new AABB();
      }
      var parsedStyle = object.parsedStyle;
      var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), width = _geometryUpdater$upda.width, height = _geometryUpdater$upda.height, _geometryUpdater$upda2 = _geometryUpdater$upda.depth, depth = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.offsetX, offsetX = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.offsetY, offsetY = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.offsetZ, offsetZ = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5;
      var flipY = width < 0;
      var flipX = height < 0;
      var halfExtents = [Math.abs(width) / 2, Math.abs(height) / 2, depth / 2];
      var stroke = parsedStyle.stroke, lineWidth = parsedStyle.lineWidth, increasedLineWidthForHitTesting = parsedStyle.increasedLineWidthForHitTesting, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
      var anchor = parsedStyle.anchor;
      if (object.nodeName === Shape.TEXT) {
        delete parsedStyle.anchor;
      }
      var center = [(1 - (anchor && anchor[0] || 0) * 2) * width / 2 + offsetX, (1 - (anchor && anchor[1] || 0) * 2) * height / 2 + offsetY, (1 - (anchor && anchor[2] || 0) * 2) * halfExtents[2] + offsetZ];
      geometry.contentBounds.update(center, halfExtents);
      var expansion = object.nodeName === Shape.POLYLINE || object.nodeName === Shape.POLYGON || object.nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
      var hasStroke = stroke && !stroke.isNone;
      if (hasStroke) {
        var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
        halfExtents[0] += halfLineWidth;
        halfExtents[1] += halfLineWidth;
      }
      geometry.renderBounds.update(center, halfExtents);
      if (shadowColor && shadowType && shadowType !== "inner") {
        var _geometry$renderBound = geometry.renderBounds, min4 = _geometry$renderBound.min, max4 = _geometry$renderBound.max;
        var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
        var shadowBlurInPixels = shadowBlur || 0;
        var shadowOffsetXInPixels = shadowOffsetX || 0;
        var shadowOffsetYInPixels = shadowOffsetY || 0;
        var shadowLeft = min4[0] - shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowRight = max4[0] + shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowTop = min4[1] - shadowBlurInPixels + shadowOffsetYInPixels;
        var shadowBottom = max4[1] + shadowBlurInPixels + shadowOffsetYInPixels;
        min4[0] = Math.min(min4[0], shadowLeft);
        max4[0] = Math.max(max4[0], shadowRight);
        min4[1] = Math.min(min4[1], shadowTop);
        max4[1] = Math.max(max4[1], shadowBottom);
        geometry.renderBounds.setMinMax(min4, max4);
      }
      filter.forEach(function(_ref) {
        var name = _ref.name, params = _ref.params;
        if (name === "blur") {
          var blurRadius = params[0].value;
          geometry.renderBounds.update(geometry.renderBounds.center, addVec3(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
        } else if (name === "drop-shadow") {
          var _shadowOffsetX = params[0].value;
          var _shadowOffsetY = params[1].value;
          var _shadowBlur = params[2].value;
          var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
          var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
          var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
          var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
          var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
          _min[0] = Math.min(_min[0], _shadowLeft);
          _max[0] = Math.max(_max[0], _shadowRight);
          _min[1] = Math.min(_min[1], _shadowTop);
          _max[1] = Math.max(_max[1], _shadowBottom);
          geometry.renderBounds.setMinMax(_min, _max);
        }
      });
      anchor = parsedStyle.anchor;
      var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object) : 0);
      var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object) : 0);
      usedOriginXValue = usedOriginXValue - (flipY ? -1 : 1) * (anchor && anchor[0] || 0) * geometry.contentBounds.halfExtents[0] * 2;
      usedOriginYValue = usedOriginYValue - (flipX ? -1 : 1) * (anchor && anchor[1] || 0) * geometry.contentBounds.halfExtents[1] * 2;
      object.setOrigin(usedOriginXValue, usedOriginYValue);
      runtime.sceneGraphService.dirtifyToRoot(object);
    }
  };
  _proto.isPropertyInheritable = function isPropertyInheritable(name) {
    var metadata = propertyMetadataCache[name];
    if (!metadata) {
      return false;
    }
    return metadata.inh;
  };
  return DefaultStyleValueRegistry2;
}();
var CameraType;
(function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
})(CameraType || (CameraType = {}));
var CameraTrackingMode;
(function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
})(CameraTrackingMode || (CameraTrackingMode = {}));
var CameraProjectionMode;
(function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
})(CameraProjectionMode || (CameraProjectionMode = {}));
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = function() {
  function Camera2() {
    this.canvas = void 0;
    this.eventEmitter = new import_eventemitter3.default();
    this.matrix = mat4_exports.create();
    this.right = vec3_exports.fromValues(1, 0, 0);
    this.up = vec3_exports.fromValues(0, 1, 0);
    this.forward = vec3_exports.fromValues(0, 0, 1);
    this.position = vec3_exports.fromValues(0, 0, 1);
    this.focalPoint = vec3_exports.fromValues(0, 0, 0);
    this.distanceVector = vec3_exports.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.left = void 0;
    this.rright = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.projectionMatrix = mat4_exports.create();
    this.projectionMatrixInverse = mat4_exports.create();
    this.jitteredProjectionMatrix = void 0;
    this.view = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = mat4_exports.create();
  }
  var _proto = Camera2.prototype;
  _proto.isOrtho = function isOrtho() {
    return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
  };
  _proto.getProjectionMode = function getProjectionMode() {
    return this.projectionMode;
  };
  _proto.getPerspective = function getPerspective() {
    return this.jitteredProjectionMatrix || this.projectionMatrix;
  };
  _proto.getPerspectiveInverse = function getPerspectiveInverse() {
    return this.projectionMatrixInverse;
  };
  _proto.getFrustum = function getFrustum() {
    return this.frustum;
  };
  _proto.getPosition = function getPosition2() {
    return this.position;
  };
  _proto.getFocalPoint = function getFocalPoint() {
    return this.focalPoint;
  };
  _proto.getDollyingStep = function getDollyingStep() {
    return this.dollyingStep;
  };
  _proto.getNear = function getNear() {
    return this.near;
  };
  _proto.getFar = function getFar() {
    return this.far;
  };
  _proto.getZoom = function getZoom() {
    return this.zoom;
  };
  _proto.getOrthoMatrix = function getOrthoMatrix() {
    return this.orthoMatrix;
  };
  _proto.getView = function getView() {
    return this.view;
  };
  _proto.setEnableUpdate = function setEnableUpdate(enabled) {
    this.enableUpdate = enabled;
  };
  _proto.setType = function setType(type, trackingMode) {
    this.type = type;
    if (this.type === CameraType.EXPLORING) {
      this.setWorldRotation(true);
    } else {
      this.setWorldRotation(false);
    }
    this._getAngles();
    if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
      this.setTrackingMode(trackingMode);
    }
    return this;
  };
  _proto.setProjectionMode = function setProjectionMode(projectionMode) {
    this.projectionMode = projectionMode;
    return this;
  };
  _proto.setTrackingMode = function setTrackingMode(trackingMode) {
    if (this.type !== CameraType.TRACKING) {
      throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
    }
    this.trackingMode = trackingMode;
    return this;
  };
  _proto.setWorldRotation = function setWorldRotation(flag) {
    this.rotateWorld = flag;
    this._getAngles();
    return this;
  };
  _proto.getViewTransform = function getViewTransform() {
    return mat4_exports.invert(mat4_exports.create(), this.matrix);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return this.matrix;
  };
  _proto.jitterProjectionMatrix = function jitterProjectionMatrix(x, y) {
    var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x, y, 0]);
    this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
  };
  _proto.clearJitterProjectionMatrix = function clearJitterProjectionMatrix() {
    this.jitteredProjectionMatrix = void 0;
  };
  _proto.setMatrix = function setMatrix(matrix) {
    this.matrix = matrix;
    this._update();
    return this;
  };
  _proto.setFov = function setFov(fov) {
    this.setPerspective(this.near, this.far, fov, this.aspect);
    return this;
  };
  _proto.setAspect = function setAspect(aspect) {
    this.setPerspective(this.near, this.far, this.fov, aspect);
    return this;
  };
  _proto.setNear = function setNear(near) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
    }
    return this;
  };
  _proto.setFar = function setFar(far) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
    }
    return this;
  };
  _proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === void 0) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.clearViewOffset = function clearViewOffset() {
    if (this.view !== void 0) {
      this.view.enabled = false;
    }
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.setZoom = function setZoom(zoom) {
    this.zoom = zoom;
    if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    }
    return this;
  };
  _proto.setZoomByViewportPoint = function setZoomByViewportPoint(zoom, viewportPoint) {
    var _this$canvas$viewport = this.canvas.viewport2Canvas({
      x: viewportPoint[0],
      y: viewportPoint[1]
    }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
    var roll = this.roll;
    this.rotate(0, 0, -roll);
    this.setPosition(ox, oy);
    this.setFocalPoint(ox, oy);
    this.setZoom(zoom);
    this.rotate(0, 0, roll);
    var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
      x: viewportPoint[0],
      y: viewportPoint[1]
    }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
    var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
    var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
    var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
    this.pan(-dx, -dy);
    return this;
  };
  _proto.setPerspective = function setPerspective(near, far, fov, aspect) {
    var _this$view;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.aspect = aspect;
    var top = this.near * Math.tan(deg2rad2(0.5 * this.fov)) / this.zoom;
    var height = 2 * top;
    var width = this.aspect * height;
    var left = -0.5 * width;
    if ((_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.enabled) {
      var fullWidth = this.view.fullWidth;
      var fullHeight = this.view.fullHeight;
      left += this.view.offsetX * width / fullWidth;
      top -= this.view.offsetY * height / fullHeight;
      width *= this.view.width / fullWidth;
      height *= this.view.height / fullHeight;
    }
    makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far);
    mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
    mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this.triggerUpdate();
    return this;
  };
  _proto.setOrthographic = function setOrthographic(l, r, t, b, near, far) {
    var _this$view2;
    this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
    this.rright = r;
    this.left = l;
    this.top = t;
    this.bottom = b;
    this.near = near;
    this.far = far;
    var dx = (this.rright - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.rright + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.enabled) {
      var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
      var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    mat4_exports.ortho(this.projectionMatrix, left, right, bottom, top, near, far);
    mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
    mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this._getOrthoMatrix();
    this.triggerUpdate();
    return this;
  };
  _proto.setPosition = function setPosition(x, y, z) {
    if (y === void 0) {
      y = this.position[1];
    }
    if (z === void 0) {
      z = this.position[2];
    }
    var position = createVec3(x, y, z);
    this._setPosition(position);
    this.setFocalPoint(this.focalPoint);
    this.triggerUpdate();
    return this;
  };
  _proto.setFocalPoint = function setFocalPoint(x, y, z) {
    if (y === void 0) {
      y = this.focalPoint[1];
    }
    if (z === void 0) {
      z = this.focalPoint[2];
    }
    var up = vec3_exports.fromValues(0, 1, 0);
    this.focalPoint = createVec3(x, y, z);
    if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
      var d4 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      x = d4[0];
      y = d4[1];
      z = d4[2];
      var r = vec3_exports.length(d4);
      var el = rad2deg2(Math.asin(y / r));
      var az = 90 + rad2deg2(Math.atan2(z, x));
      var m = mat4_exports.create();
      mat4_exports.rotateY(m, m, deg2rad2(az));
      mat4_exports.rotateX(m, m, deg2rad2(el));
      up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m);
    }
    mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
    this._getAxes();
    this._getDistance();
    this._getAngles();
    this.triggerUpdate();
    return this;
  };
  _proto.getDistance = function getDistance() {
    return this.distance;
  };
  _proto.getDistanceVector = function getDistanceVector() {
    return this.distanceVector;
  };
  _proto.setDistance = function setDistance(d4) {
    if (this.distance === d4 || d4 < 0) {
      return this;
    }
    this.distance = d4;
    if (this.distance < MIN_DISTANCE) {
      this.distance = MIN_DISTANCE;
    }
    this.dollyingStep = this.distance / 100;
    var pos2 = vec3_exports.create();
    d4 = this.distance;
    var n = this.forward;
    var f = this.focalPoint;
    pos2[0] = d4 * n[0] + f[0];
    pos2[1] = d4 * n[1] + f[1];
    pos2[2] = d4 * n[2] + f[2];
    this._setPosition(pos2);
    this.triggerUpdate();
    return this;
  };
  _proto.setMaxDistance = function setMaxDistance(d4) {
    this.maxDistance = d4;
    return this;
  };
  _proto.setMinDistance = function setMinDistance(d4) {
    this.minDistance = d4;
    return this;
  };
  _proto.setAzimuth = function setAzimuth(az) {
    this.azimuth = getAngle3(az);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getAzimuth = function getAzimuth() {
    return this.azimuth;
  };
  _proto.setElevation = function setElevation(el) {
    this.elevation = getAngle3(el);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getElevation = function getElevation() {
    return this.elevation;
  };
  _proto.setRoll = function setRoll(angle3) {
    this.roll = getAngle3(angle3);
    this.computeMatrix();
    this._getAxes();
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getRoll = function getRoll() {
    return this.roll;
  };
  _proto._update = function _update() {
    this._getAxes();
    this._getPosition();
    this._getDistance();
    this._getAngles();
    this._getOrthoMatrix();
    this.triggerUpdate();
  };
  _proto.computeMatrix = function computeMatrix() {
    var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad2(this.roll));
    mat4_exports.identity(this.matrix);
    var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
    var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
    var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
    rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
    var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
      mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
    } else if (this.type === CameraType.TRACKING) {
      mat4_exports.translate(this.matrix, this.matrix, this.position);
      mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
    }
  };
  _proto._setPosition = function _setPosition(x, y, z) {
    this.position = createVec3(x, y, z);
    var m = this.matrix;
    m[12] = this.position[0];
    m[13] = this.position[1];
    m[14] = this.position[2];
    m[15] = 1;
    this._getOrthoMatrix();
  };
  _proto._getAxes = function _getAxes() {
    vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
    vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
    vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
    vec3_exports.normalize(this.right, this.right);
    vec3_exports.normalize(this.up, this.up);
    vec3_exports.normalize(this.forward, this.forward);
  };
  _proto._getAngles = function _getAngles() {
    var x = this.distanceVector[0];
    var y = this.distanceVector[1];
    var z = this.distanceVector[2];
    var r = vec3_exports.length(this.distanceVector);
    if (r === 0) {
      this.elevation = 0;
      this.azimuth = 0;
      return;
    }
    if (this.type === CameraType.TRACKING) {
      this.elevation = rad2deg2(Math.asin(y / r));
      this.azimuth = rad2deg2(Math.atan2(-x, -z));
    } else {
      if (this.rotateWorld) {
        this.elevation = rad2deg2(Math.asin(y / r));
        this.azimuth = rad2deg2(Math.atan2(-x, -z));
      } else {
        this.elevation = -rad2deg2(Math.asin(y / r));
        this.azimuth = -rad2deg2(Math.atan2(-x, -z));
      }
    }
  };
  _proto._getPosition = function _getPosition() {
    vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
    this._getDistance();
  };
  _proto._getFocalPoint = function _getFocalPoint() {
    vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
    vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
    this._getDistance();
  };
  _proto._getDistance = function _getDistance() {
    this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
    this.distance = vec3_exports.length(this.distanceVector);
    this.dollyingStep = this.distance / 100;
  };
  _proto._getOrthoMatrix = function _getOrthoMatrix() {
    if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
      return;
    }
    var position = this.position;
    var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
    mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
  };
  _proto.triggerUpdate = function triggerUpdate() {
    if (this.enableUpdate) {
      var viewMatrix = this.getViewTransform();
      var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
      this.getFrustum().extractFromVPMatrix(vpMatrix);
      this.eventEmitter.emit(CameraEvent.UPDATED);
    }
  };
  _proto.rotate = function rotate5(azimuth, elevation, roll) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.pan = function pan(tx, ty) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.dolly = function dolly(value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.createLandmark = function createLandmark(name, params) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.gotoLandmark = function gotoLandmark(name, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  return Camera2;
}();
var CircleUpdater = function() {
  function CircleUpdater2() {
  }
  var _proto = CircleUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var r = parsedStyle.r;
    var width = r * 2;
    var height = r * 2;
    return {
      width,
      height
    };
  };
  return CircleUpdater2;
}();
var EllipseUpdater = function() {
  function EllipseUpdater2() {
  }
  var _proto = EllipseUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var rx = parsedStyle.rx, ry = parsedStyle.ry;
    var width = rx * 2;
    var height = ry * 2;
    return {
      width,
      height
    };
  };
  return EllipseUpdater2;
}();
var LineUpdater = function() {
  function LineUpdater2() {
  }
  var _proto = LineUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width,
      height
    };
  };
  return LineUpdater2;
}();
var PathUpdater = function() {
  function PathUpdater2() {
  }
  var _proto = PathUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var path = parsedStyle.path;
    var _path$rect = path.rect, width = _path$rect.width, height = _path$rect.height;
    return {
      width,
      height
    };
  };
  return PathUpdater2;
}();
var PolylineUpdater = function() {
  function PolylineUpdater2() {
  }
  var _proto = PolylineUpdater2.prototype;
  _proto.update = function update(parsedStyle) {
    var points = parsedStyle.points.points;
    var minX = Math.min.apply(Math, points.map(function(point) {
      return point[0];
    }));
    var maxX = Math.max.apply(Math, points.map(function(point) {
      return point[0];
    }));
    var minY = Math.min.apply(Math, points.map(function(point) {
      return point[1];
    }));
    var maxY = Math.max.apply(Math, points.map(function(point) {
      return point[1];
    }));
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width,
      height
    };
  };
  return PolylineUpdater2;
}();
var RectUpdater = function() {
  function RectUpdater2() {
  }
  var _proto = RectUpdater2.prototype;
  _proto.update = function update(parsedStyle, object) {
    var img = parsedStyle.img, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
    var contentWidth = width;
    var contentHeight = height;
    if (img && !is_string_default(img)) {
      if (!contentWidth) {
        contentWidth = img.width;
        parsedStyle.width = contentWidth;
      }
      if (!contentHeight) {
        contentHeight = img.height;
        parsedStyle.height = contentHeight;
      }
    }
    return {
      width: contentWidth,
      height: contentHeight
    };
  };
  return RectUpdater2;
}();
var TextUpdater = function() {
  function TextUpdater2(globalRuntime) {
    this.globalRuntime = void 0;
    this.globalRuntime = globalRuntime;
  }
  var _proto = TextUpdater2.prototype;
  _proto.isReadyToMeasure = function isReadyToMeasure(parsedStyle, object) {
    var text = parsedStyle.text, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, fontSize = parsedStyle.fontSize, fontStyle = parsedStyle.fontStyle, fontWeight = parsedStyle.fontWeight, fontVariant = parsedStyle.fontVariant, lineWidth = parsedStyle.lineWidth;
    return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !is_nil_default(lineWidth);
  };
  _proto.update = function update(parsedStyle, object) {
    var _object$ownerDocument, _object$ownerDocument2;
    var text = parsedStyle.text, textAlign = parsedStyle.textAlign, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, dx = parsedStyle.dx, dy = parsedStyle.dy;
    var _ref = (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : (_object$ownerDocument2 = _object$ownerDocument.defaultView) === null || _object$ownerDocument2 === void 0 ? void 0 : _object$ownerDocument2.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
    if (!this.isReadyToMeasure(parsedStyle, object)) {
      parsedStyle.metrics = {
        font: "",
        width: 0,
        height: 0,
        lines: [],
        lineWidths: [],
        lineHeight: 0,
        maxLineWidth: 0,
        fontProperties: {
          ascent: 0,
          descent: 0,
          fontSize: 0
        },
        lineMetrics: []
      };
      return {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0
      };
    }
    var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
    parsedStyle.metrics = metrics;
    var width = metrics.width, height = metrics.height, lineHeight = metrics.lineHeight, fontProperties = metrics.fontProperties;
    var halfExtents = [width / 2, height / 2, 0];
    var anchor = [0, 1];
    var lineXOffset = 0;
    if (textAlign === "center" || textAlign === "middle") {
      lineXOffset = lineWidth / 2;
      anchor = [0.5, 1];
    } else if (textAlign === "right" || textAlign === "end") {
      lineXOffset = lineWidth;
      anchor = [1, 1];
    }
    var lineYOffset = 0;
    if (textBaseline === "middle") {
      lineYOffset = halfExtents[1];
    } else if (textBaseline === "top" || textBaseline === "hanging") {
      lineYOffset = halfExtents[1] * 2;
    } else if (textBaseline === "alphabetic") {
      lineYOffset = lineHeight - fontProperties.ascent;
    } else if (textBaseline === "bottom" || textBaseline === "ideographic") {
      lineYOffset = 0;
    }
    if (dx) {
      lineXOffset += dx;
    }
    if (dy) {
      lineYOffset += dy;
    }
    parsedStyle.anchor = [anchor[0], anchor[1], 0];
    return {
      width: halfExtents[0] * 2,
      height: halfExtents[1] * 2,
      offsetX: lineXOffset,
      offsetY: lineYOffset
    };
  };
  return TextUpdater2;
}();
var PROPAGATION_LIMIT = 2048;
var EventService = function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    this.globalRuntime = void 0;
    this.context = void 0;
    this.rootTarget = void 0;
    this.emitter = new import_eventemitter3.default();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.pickHandler = void 0;
    this.tmpMatrix = mat4_exports.create();
    this.tmpVec3 = vec3_exports.create();
    this.onPointerDown = function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(from) {
        var e2, isRightButton, trackingData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.createPointerEvent(from);
              case 2:
                e2 = _context.sent;
                _this2.dispatchEvent(e2, "pointerdown");
                if (e2.pointerType === "touch") {
                  _this2.dispatchEvent(e2, "touchstart");
                } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                  isRightButton = e2.button === 2;
                  _this2.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
                }
                trackingData = _this2.trackingData(from.pointerId);
                trackingData.pressTargetsByButton[from.button] = e2.composedPath();
                _this2.freeEvent(e2);
              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    this.onPointerUp = function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(from) {
        var now, e2, isRightButton, trackingData, pressTarget, clickTarget, currentTarget, _isRightButton, _e$detail, clickEvent, clickHistory;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                now = performance.now();
                _context2.next = 3;
                return _this2.createPointerEvent(from);
              case 3:
                e2 = _context2.sent;
                _this2.dispatchEvent(e2, "pointerup");
                if (e2.pointerType === "touch") {
                  _this2.dispatchEvent(e2, "touchend");
                } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                  isRightButton = e2.button === 2;
                  _this2.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
                }
                trackingData = _this2.trackingData(from.pointerId);
                pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                clickTarget = pressTarget;
                if (pressTarget && !e2.composedPath().includes(pressTarget)) {
                  currentTarget = pressTarget;
                  while (currentTarget && !e2.composedPath().includes(currentTarget)) {
                    e2.currentTarget = currentTarget;
                    _this2.notifyTarget(e2, "pointerupoutside");
                    if (e2.pointerType === "touch") {
                      _this2.notifyTarget(e2, "touchendoutside");
                    } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                      _isRightButton = e2.button === 2;
                      _this2.notifyTarget(e2, _isRightButton ? "rightupoutside" : "mouseupoutside");
                    }
                    if (Node2.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                  clickTarget = currentTarget;
                }
                if (clickTarget) {
                  clickEvent = _this2.clonePointerEvent(e2, "click");
                  clickEvent.target = clickTarget;
                  clickEvent.path = [];
                  if (!trackingData.clicksByButton[from.button]) {
                    trackingData.clicksByButton[from.button] = {
                      clickCount: 0,
                      target: clickEvent.target,
                      timeStamp: now
                    };
                  }
                  clickHistory = trackingData.clicksByButton[from.button];
                  if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                    ++clickHistory.clickCount;
                  } else {
                    clickHistory.clickCount = 1;
                  }
                  clickHistory.target = clickEvent.target;
                  clickHistory.timeStamp = now;
                  clickEvent.detail = clickHistory.clickCount;
                  if (!((_e$detail = e2.detail) === null || _e$detail === void 0 ? void 0 : _e$detail.preventClick)) {
                    if (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch") {
                      _this2.dispatchEvent(clickEvent, "click");
                    }
                    _this2.dispatchEvent(clickEvent, "pointertap");
                  }
                  _this2.freeEvent(clickEvent);
                }
                _this2.freeEvent(e2);
              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    this.onPointerMove = function() {
      var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(from) {
        var e2, isMouse, trackingData, outTarget, outType, outEvent, leaveEvent, overType, overEvent, overTargetAncestor, didPointerEnter, enterEvent;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this2.createPointerEvent(from);
              case 2:
                e2 = _context3.sent;
                isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
                trackingData = _this2.trackingData(from.pointerId);
                outTarget = _this2.findMountedTarget(trackingData.overTargets);
                if (!(trackingData.overTargets && outTarget !== e2.target)) {
                  _context3.next = 21;
                  break;
                }
                outType = from.type === "mousemove" ? "mouseout" : "pointerout";
                _context3.next = 10;
                return _this2.createPointerEvent(from, outType, outTarget || void 0);
              case 10:
                outEvent = _context3.sent;
                _this2.dispatchEvent(outEvent, "pointerout");
                if (isMouse)
                  _this2.dispatchEvent(outEvent, "mouseout");
                if (e2.composedPath().includes(outTarget)) {
                  _context3.next = 20;
                  break;
                }
                _context3.next = 16;
                return _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
              case 16:
                leaveEvent = _context3.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this2.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this2.notifyTarget(leaveEvent, "mouseleave");
                  }
                  if (Node2.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                _this2.freeEvent(leaveEvent);
              case 20:
                _this2.freeEvent(outEvent);
              case 21:
                if (!(outTarget !== e2.target)) {
                  _context3.next = 36;
                  break;
                }
                overType = from.type === "mousemove" ? "mouseover" : "pointerover";
                overEvent = _this2.clonePointerEvent(e2, overType);
                _this2.dispatchEvent(overEvent, "pointerover");
                if (isMouse)
                  _this2.dispatchEvent(overEvent, "mouseover");
                overTargetAncestor = outTarget && Node2.isNode(outTarget) && outTarget.parentNode;
              case 27:
                if (!(overTargetAncestor && overTargetAncestor !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode))) {
                  _context3.next = 33;
                  break;
                }
                if (!(overTargetAncestor === e2.target)) {
                  _context3.next = 30;
                  break;
                }
                return _context3.abrupt("break", 33);
              case 30:
                overTargetAncestor = overTargetAncestor.parentNode;
                _context3.next = 27;
                break;
              case 33:
                didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
                if (didPointerEnter) {
                  enterEvent = _this2.clonePointerEvent(e2, "pointerenter");
                  enterEvent.eventPhase = enterEvent.AT_TARGET;
                  while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                    enterEvent.currentTarget = enterEvent.target;
                    _this2.notifyTarget(enterEvent);
                    if (isMouse)
                      _this2.notifyTarget(enterEvent, "mouseenter");
                    if (Node2.isNode(enterEvent.target)) {
                      enterEvent.target = enterEvent.target.parentNode;
                    }
                  }
                  _this2.freeEvent(enterEvent);
                }
                _this2.freeEvent(overEvent);
              case 36:
                _this2.dispatchEvent(e2, "pointermove");
                if (e2.pointerType === "touch")
                  _this2.dispatchEvent(e2, "touchmove");
                if (isMouse) {
                  _this2.dispatchEvent(e2, "mousemove");
                  _this2.cursor = _this2.getCursor(e2.target);
                }
                trackingData.overTargets = e2.composedPath();
                _this2.freeEvent(e2);
              case 41:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function(_x3) {
        return _ref3.apply(this, arguments);
      };
    }();
    this.onPointerOut = function() {
      var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(from) {
        var trackingData, isMouse, outTarget, outEvent, leaveEvent;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                if (!trackingData.overTargets) {
                  _context4.next = 17;
                  break;
                }
                isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
                outTarget = _this2.findMountedTarget(trackingData.overTargets);
                _context4.next = 6;
                return _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
              case 6:
                outEvent = _context4.sent;
                _this2.dispatchEvent(outEvent);
                if (isMouse)
                  _this2.dispatchEvent(outEvent, "mouseout");
                _context4.next = 11;
                return _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
              case 11:
                leaveEvent = _context4.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && leaveEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this2.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this2.notifyTarget(leaveEvent, "mouseleave");
                  }
                  if (Node2.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = null;
                _this2.freeEvent(outEvent);
                _this2.freeEvent(leaveEvent);
              case 17:
                _this2.cursor = null;
              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return function(_x4) {
        return _ref4.apply(this, arguments);
      };
    }();
    this.onPointerOver = function() {
      var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(from) {
        var trackingData, e2, isMouse, enterEvent;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                _context5.next = 3;
                return _this2.createPointerEvent(from);
              case 3:
                e2 = _context5.sent;
                isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
                _this2.dispatchEvent(e2, "pointerover");
                if (isMouse)
                  _this2.dispatchEvent(e2, "mouseover");
                if (e2.pointerType === "mouse")
                  _this2.cursor = _this2.getCursor(e2.target);
                enterEvent = _this2.clonePointerEvent(e2, "pointerenter");
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while (enterEvent.target && enterEvent.target !== (Node2.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                  enterEvent.currentTarget = enterEvent.target;
                  _this2.notifyTarget(enterEvent);
                  if (isMouse) {
                    _this2.notifyTarget(enterEvent, "mouseenter");
                  }
                  if (Node2.isNode(enterEvent.target)) {
                    enterEvent.target = enterEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = e2.composedPath();
                _this2.freeEvent(e2);
                _this2.freeEvent(enterEvent);
              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return function(_x5) {
        return _ref5.apply(this, arguments);
      };
    }();
    this.onPointerUpOutside = function() {
      var _ref6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(from) {
        var trackingData, pressTarget, e2, currentTarget;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                trackingData = _this2.trackingData(from.pointerId);
                pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                _context6.next = 4;
                return _this2.createPointerEvent(from);
              case 4:
                e2 = _context6.sent;
                if (pressTarget) {
                  currentTarget = pressTarget;
                  while (currentTarget) {
                    e2.currentTarget = currentTarget;
                    _this2.notifyTarget(e2, "pointerupoutside");
                    if (e2.pointerType === "touch")
                      ;
                    else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                      _this2.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
                    }
                    if (Node2.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                }
                _this2.freeEvent(e2);
              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return function(_x6) {
        return _ref6.apply(this, arguments);
      };
    }();
    this.onWheel = function() {
      var _ref7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7(from) {
        var wheelEvent;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this2.createWheelEvent(from);
              case 2:
                wheelEvent = _context7.sent;
                _this2.dispatchEvent(wheelEvent);
                _this2.freeEvent(wheelEvent);
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      return function(_x7) {
        return _ref7.apply(this, arguments);
      };
    }();
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = EventService2.prototype;
  _proto.init = function init() {
    this.rootTarget = this.context.renderingContext.root.parentNode;
    this.addEventMapping("pointerdown", this.onPointerDown);
    this.addEventMapping("pointerup", this.onPointerUp);
    this.addEventMapping("pointermove", this.onPointerMove);
    this.addEventMapping("pointerout", this.onPointerOut);
    this.addEventMapping("pointerleave", this.onPointerOut);
    this.addEventMapping("pointerover", this.onPointerOver);
    this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
    this.addEventMapping("wheel", this.onWheel);
  };
  _proto.destroy = function destroy() {
    this.emitter.removeAllListeners();
    this.mappingTable = {};
    this.mappingState = {};
    this.eventPool.clear();
  };
  _proto.client2Viewport = function client2Viewport(client) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Canvas = function viewport2Canvas(_ref8) {
    var x = _ref8.x, y = _ref8.y;
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
    var projectionMatrixInverse = camera.getPerspectiveInverse();
    var worldMatrix = camera.getWorldTransform();
    var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
    var viewport = vec3_exports.set(this.tmpVec3, x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);
    vec3_exports.transformMat4(viewport, viewport, vpMatrix);
    return new Point(viewport[0], viewport[1]);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvasP) {
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var projectionMatrix = camera.getPerspective();
    var viewMatrix = camera.getViewTransform();
    var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
    var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
    vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
    var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
    return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
  };
  _proto.setPickHandler = function setPickHandler(pickHandler) {
    this.pickHandler = pickHandler;
  };
  _proto.addEventMapping = function addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort(function(a, b) {
      return a.priority - b.priority;
    });
  };
  _proto.mapEvent = function mapEvent(e2) {
    if (!this.rootTarget) {
      return;
    }
    var mappers = this.mappingTable[e2.type];
    if (mappers) {
      for (var i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e2);
      }
    } else {
      console.warn("[EventService]: Event mapping not defined for " + e2.type);
    }
  };
  _proto.dispatchEvent = function dispatchEvent(e2, type, skipPropagate) {
    if (!skipPropagate) {
      e2.propagationStopped = false;
      e2.propagationImmediatelyStopped = false;
      this.propagate(e2, type);
    } else {
      e2.eventPhase = e2.AT_TARGET;
      var canvas = this.rootTarget.defaultView || null;
      e2.currentTarget = canvas;
      this.notifyListeners(e2, type);
    }
    this.emitter.emit(type || e2.type, e2);
  };
  _proto.propagate = function propagate(e2, type) {
    if (!e2.target) {
      return;
    }
    var composedPath = e2.composedPath();
    e2.eventPhase = e2.CAPTURING_PHASE;
    for (var i = composedPath.length - 1; i >= 1; i--) {
      e2.currentTarget = composedPath[i];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
    e2.eventPhase = e2.AT_TARGET;
    e2.currentTarget = e2.target;
    this.notifyTarget(e2, type);
    if (e2.propagationStopped || e2.propagationImmediatelyStopped)
      return;
    var index = composedPath.indexOf(e2.currentTarget);
    e2.eventPhase = e2.BUBBLING_PHASE;
    for (var _i = index + 1; _i < composedPath.length; _i++) {
      e2.currentTarget = composedPath[_i];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
  };
  _proto.propagationPath = function propagationPath(target) {
    var propagationPath2 = [target];
    var canvas = this.rootTarget.defaultView || null;
    if (canvas && canvas === target) {
      propagationPath2.unshift(canvas.document);
      return propagationPath2;
    }
    for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (Node2.isNode(target) && target.parentNode) {
        propagationPath2.push(target.parentNode);
        target = target.parentNode;
      }
    }
    if (canvas) {
      propagationPath2.push(canvas);
    }
    return propagationPath2;
  };
  _proto.hitTest = function() {
    var _hitTest = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(position) {
      var viewportX, viewportY, _this$context$config3, width, height;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              viewportX = position.viewportX, viewportY = position.viewportY;
              _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context8.next = 4;
                break;
              }
              return _context8.abrupt("return", null);
            case 4:
              _context8.next = 6;
              return this.pickHandler(position);
            case 6:
              _context8.t1 = _context8.sent;
              if (_context8.t1) {
                _context8.next = 9;
                break;
              }
              _context8.t1 = this.rootTarget;
            case 9:
              _context8.t0 = _context8.t1;
              if (_context8.t0) {
                _context8.next = 12;
                break;
              }
              _context8.t0 = // return Document
              null;
            case 12:
              return _context8.abrupt("return", _context8.t0);
            case 13:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));
    function hitTest(_x8) {
      return _hitTest.apply(this, arguments);
    }
    return hitTest;
  }();
  _proto.isNativeEventFromCanvas = function isNativeEventFromCanvas(event) {
    var _event$nativeEvent;
    var $el = this.context.contextService.getDomElement();
    var target = (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.target;
    if (target) {
      if (target === $el) {
        return true;
      }
      if ($el && $el.contains) {
        return $el.contains(target);
      }
    }
    if (event.nativeEvent.composedPath) {
      return event.nativeEvent.composedPath().indexOf($el) > -1;
    }
    return false;
  };
  _proto.getExistedHTML = function getExistedHTML(event) {
    if (event.nativeEvent.composedPath) {
      var htmls = this.globalRuntime.displayObjectPool.getHTMLs();
      for (var _iterator = _createForOfIteratorHelperLoose(htmls), _step; !(_step = _iterator()).done; ) {
        var html = _step.value;
        if (event.nativeEvent.composedPath().indexOf(html) > -1) {
          return html;
        }
      }
    }
    return null;
  };
  _proto.pickTarget = function() {
    var _pickTarget = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(event) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", this.hitTest({
                clientX: event.clientX,
                clientY: event.clientY,
                viewportX: event.viewportX,
                viewportY: event.viewportY,
                x: event.canvasX,
                y: event.canvasY
              }));
            case 1:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));
    function pickTarget(_x9) {
      return _pickTarget.apply(this, arguments);
    }
    return pickTarget;
  }();
  _proto.createPointerEvent = function() {
    var _createPointerEvent = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(from, type, target) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              event = this.allocateEvent(FederatedPointerEvent);
              this.copyPointerData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              if (!(target !== null && target !== void 0)) {
                _context10.next = 11;
                break;
              }
              _context10.t0 = target;
              _context10.next = 20;
              break;
            case 11:
              _context10.t1 = existedHTML;
              if (_context10.t1) {
                _context10.next = 19;
                break;
              }
              _context10.t2 = this.isNativeEventFromCanvas(event);
              if (!_context10.t2) {
                _context10.next = 18;
                break;
              }
              _context10.next = 17;
              return this.pickTarget(event);
            case 17:
              _context10.t2 = _context10.sent;
            case 18:
              _context10.t1 = _context10.t2;
            case 19:
              _context10.t0 = _context10.t1;
            case 20:
              event.target = _context10.t0;
              if (typeof type === "string") {
                event.type = type;
              }
              return _context10.abrupt("return", event);
            case 23:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));
    function createPointerEvent(_x10, _x11, _x12) {
      return _createPointerEvent.apply(this, arguments);
    }
    return createPointerEvent;
  }();
  _proto.createWheelEvent = function() {
    var _createWheelEvent = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(from) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              event = this.allocateEvent(FederatedWheelEvent);
              this.copyWheelData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              _context11.t0 = existedHTML;
              if (_context11.t0) {
                _context11.next = 15;
                break;
              }
              _context11.t1 = this.isNativeEventFromCanvas(event);
              if (!_context11.t1) {
                _context11.next = 14;
                break;
              }
              _context11.next = 13;
              return this.pickTarget(event);
            case 13:
              _context11.t1 = _context11.sent;
            case 14:
              _context11.t0 = _context11.t1;
            case 15:
              event.target = _context11.t0;
              return _context11.abrupt("return", event);
            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));
    function createWheelEvent(_x13) {
      return _createWheelEvent.apply(this, arguments);
    }
    return createWheelEvent;
  }();
  _proto.trackingData = function trackingData(id2) {
    if (!this.mappingState.trackingData[id2]) {
      this.mappingState.trackingData[id2] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id2];
  };
  _proto.cloneWheelEvent = function cloneWheelEvent(from) {
    var event = this.allocateEvent(FederatedWheelEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = from.type;
    return event;
  };
  _proto.clonePointerEvent = function clonePointerEvent(from, type) {
    var event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type !== null && type !== void 0 ? type : event.type;
    return event;
  };
  _proto.copyPointerData = function copyPointerData(from, to) {
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  };
  _proto.copyMouseData = function copyMouseData(from, to) {
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.shiftKey = from.shiftKey;
    to.client.copyFrom(from.client);
    to.movement.copyFrom(from.movement);
    to.canvas.copyFrom(from.canvas);
    to.screen.copyFrom(from.screen);
    to.global.copyFrom(from.global);
    to.offset.copyFrom(from.offset);
  };
  _proto.copyWheelData = function copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  };
  _proto.copyData = function copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.page.copyFrom(from.page);
    to.viewport.copyFrom(from.viewport);
  };
  _proto.allocateEvent = function allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    var event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = [];
    event.target = null;
    return event;
  };
  _proto.freeEvent = function freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    var constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  };
  _proto.notifyTarget = function notifyTarget(e2, type) {
    var _type;
    type = (_type = type) !== null && _type !== void 0 ? _type : e2.type;
    var key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? type + "capture" : type;
    this.notifyListeners(e2, key);
    if (e2.eventPhase === e2.AT_TARGET) {
      this.notifyListeners(e2, type);
    }
  };
  _proto.notifyListeners = function notifyListeners(e2, type) {
    var emitter = e2.currentTarget.emitter;
    var listeners = emitter._events[type];
    if (!listeners)
      return;
    if ("fn" in listeners) {
      if (listeners.once) {
        emitter.removeListener(type, listeners.fn, void 0, true);
      }
      listeners.fn.call(e2.currentTarget || listeners.context, e2);
    } else {
      for (var i = 0; i < listeners.length && !e2.propagationImmediatelyStopped; i++) {
        if (listeners[i].once) {
          emitter.removeListener(type, listeners[i].fn, void 0, true);
        }
        listeners[i].fn.call(e2.currentTarget || listeners[i].context, e2);
      }
    }
  };
  _proto.findMountedTarget = function findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    var currentTarget = propagationPath[propagationPath.length - 1];
    for (var i = propagationPath.length - 2; i >= 0; i--) {
      var target = propagationPath[i];
      if (target === this.rootTarget || Node2.isNode(target) && target.parentNode === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  };
  _proto.getCursor = function getCursor(target) {
    var tmp2 = target;
    while (tmp2) {
      var cursor = Element2.isElement(tmp2) && tmp2.getAttribute("cursor");
      if (cursor) {
        return cursor;
      }
      tmp2 = Node2.isNode(tmp2) && tmp2.parentNode;
    }
  };
  return EventService2;
}();
var OffscreenCanvasCreator = function() {
  function OffscreenCanvasCreator2() {
    this.canvas = void 0;
    this.context = void 0;
  }
  var _proto = OffscreenCanvasCreator2.prototype;
  _proto.getOrCreateCanvas = function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
    if (this.canvas) {
      return this.canvas;
    }
    if (offscreenCanvas) {
      this.canvas = offscreenCanvas;
      this.context = this.canvas.getContext("2d", contextAttributes);
    } else {
      try {
        this.canvas = new window.OffscreenCanvas(0, 0);
        this.context = this.canvas.getContext("2d", contextAttributes);
        if (!this.context || !this.context.measureText) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d");
        }
      } catch (ex) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d", contextAttributes);
      }
    }
    this.canvas.width = 10;
    this.canvas.height = 10;
    return this.canvas;
  };
  _proto.getOrCreateContext = function getOrCreateContext(offscreenCanvas, contextAttributes) {
    if (this.context) {
      return this.context;
    }
    this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
    return this.context;
  };
  return OffscreenCanvasCreator2;
}();
var RenderReason;
(function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
})(RenderReason || (RenderReason = {}));
var RenderingService = function() {
  function RenderingService2(globalRuntime, context) {
    this.globalRuntime = void 0;
    this.context = void 0;
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.renderOrderChangedEvent = new CustomEvent(ElementEvent.RENDER_ORDER_CHANGED);
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(["object"]),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(["object", "camera"]),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook([]),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(["objectToRender"]),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(["objectToRender"]),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(["objectToRender"]),
      endFrame: new SyncHook([]),
      destroy: new SyncHook([]),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(["result"]),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(["result"]),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(["event"]),
      pointerUp: new SyncHook(["event"]),
      pointerMove: new SyncHook(["event"]),
      pointerOut: new SyncHook(["event"]),
      pointerOver: new SyncHook(["event"]),
      pointerWheel: new SyncHook(["event"]),
      pointerCancel: new SyncHook(["event"])
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = RenderingService2.prototype;
  _proto.init = function() {
    var _init = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      var context;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _extends({}, this.globalRuntime, this.context);
              this.context.renderingPlugins.forEach(function(plugin) {
                plugin.apply(context, runtime);
              });
              _context.next = 4;
              return this.hooks.init.promise();
            case 4:
              this.inited = true;
            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function init() {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.getStats = function getStats() {
    return this.stats;
  };
  _proto.disableDirtyRectangleRendering = function disableDirtyRectangleRendering() {
    var renderer = this.context.config.renderer;
    var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
    return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
  };
  _proto.render = function render3(canvasConfig, rerenderCallback) {
    var _this2 = this;
    this.stats.total = 0;
    this.stats.rendered = 0;
    this.zIndexCounter = 0;
    var renderingContext = this.context.renderingContext;
    this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
    this.globalRuntime.sceneGraphService.triggerPendingEvents();
    if (renderingContext.renderReasons.size && this.inited) {
      this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
      this.hooks.beginFrame.call();
      renderingContext.renderListCurrentFrame.forEach(function(object) {
        _this2.hooks.beforeRender.call(object);
        _this2.hooks.render.call(object);
        _this2.hooks.afterRender.call(object);
      });
      this.hooks.endFrame.call();
      renderingContext.renderListCurrentFrame = [];
      renderingContext.renderReasons.clear();
      rerenderCallback();
    }
  };
  _proto.renderDisplayObject = function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
    var _this2 = this;
    var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
    if (this.globalRuntime.enableCSSParsing) {
      this.globalRuntime.styleValueRegistry.recalc(displayObject);
    }
    var objectChanged = enableDirtyCheck ? this.hooks.dirtycheck.call(displayObject) : displayObject;
    if (objectChanged) {
      var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
      if (objectToRender) {
        this.stats.rendered++;
        renderingContext.renderListCurrentFrame.push(objectToRender);
      }
    }
    displayObject.renderable.dirty = false;
    displayObject.sortable.renderOrder = this.zIndexCounter++;
    this.stats.total++;
    var sortable = displayObject.sortable;
    var renderOrderChanged = false;
    if (sortable.dirty) {
      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      renderOrderChanged = true;
      sortable.dirty = false;
    }
    (sortable.sorted || displayObject.childNodes).forEach(function(child) {
      _this2.renderDisplayObject(child, canvasConfig, renderingContext);
    });
    if (renderOrderChanged) {
      displayObject.forEach(function(child) {
        _this2.renderOrderChangedEvent.target = child;
        _this2.renderOrderChangedEvent.detail = {
          renderOrder: child.sortable.renderOrder
        };
        child.ownerDocument.defaultView.dispatchEvent(_this2.renderOrderChangedEvent, true);
      });
    }
  };
  _proto.destroy = function destroy() {
    this.inited = false;
    this.hooks.destroy.call();
    this.globalRuntime.sceneGraphService.clearPendingEvents();
  };
  _proto.dirtify = function dirtify() {
    this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
  };
  return RenderingService2;
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = function() {
  function DefaultSceneGraphSelector2() {
  }
  var _proto = DefaultSceneGraphSelector2.prototype;
  _proto.selectOne = function selectOne(query, root2) {
    var _this2 = this;
    if (query.startsWith(".")) {
      return root2.find(function(node) {
        return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith("#")) {
      return root2.find(function(node) {
        return node.id === _this2.getIdOrClassname(query);
      });
    } else if (query.startsWith("[")) {
      var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
      if (name) {
        return root2.find(function(node) {
          return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
        });
      } else {
        return null;
      }
    } else {
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  };
  _proto.selectAll = function selectAll(query, root2) {
    var _this2 = this;
    if (query.startsWith(".")) {
      return root2.findAll(function(node) {
        return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith("#")) {
      return root2.findAll(function(node) {
        return root2 !== node && node.id === _this2.getIdOrClassname(query);
      });
    } else if (query.startsWith("[")) {
      var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
      if (name) {
        return root2.findAll(function(node) {
          return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
        });
      } else {
        return [];
      }
    } else {
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  };
  _proto.is = function is(query, node) {
    if (query.startsWith(".")) {
      return node.className === this.getIdOrClassname(query);
    } else if (query.startsWith("#")) {
      return node.id === this.getIdOrClassname(query);
    } else if (query.startsWith("[")) {
      var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
      return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
    } else {
      return node.nodeName === query;
    }
  };
  _proto.getIdOrClassname = function getIdOrClassname(query) {
    return query.substring(1);
  };
  _proto.getAttribute = function getAttribute(query) {
    var matches = query.match(ATTRIBUTE_REGEXP);
    var name = "";
    var value = "";
    if (matches && matches.length > 2) {
      name = matches[1].replace(/"/g, "");
      value = matches[2].replace(/"/g, "");
    }
    return {
      name,
      value
    };
  };
  _proto.attributeToString = function attributeToString(node, name) {
    if (!node.getAttribute) {
      return "";
    }
    var value = node.getAttribute(name);
    if (is_nil_default(value)) {
      return "";
    }
    if (value.toString) {
      return value.toString();
    }
    return "";
  };
  return DefaultSceneGraphSelector2;
}();
function markRenderableDirty(e2) {
  var renderable = e2.renderable;
  if (renderable) {
    renderable.renderBoundsDirty = true;
    renderable.boundsDirty = true;
  }
}
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var DefaultSceneGraphService = function() {
  function DefaultSceneGraphService2(runtime2) {
    var _this2 = this;
    this.runtime = void 0;
    this.pendingEvents = [];
    this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
    this.rotate = function() {
      var parentInvertRotation = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.rotateLocal(element, degrees);
        } else {
          var rotation = quat_exports.create();
          quat_exports.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
          var rot = _this2.getRotation(element);
          var parentRot = _this2.getRotation(element.parentNode);
          quat_exports.copy(parentInvertRotation, parentRot);
          quat_exports.invert(parentInvertRotation, parentInvertRotation);
          quat_exports.multiply(rotation, parentInvertRotation, rotation);
          quat_exports.multiply(transform.localRotation, rotation, rot);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          _this2.dirtifyLocal(element, transform);
        }
      };
    }();
    this.rotateLocal = function() {
      var rotation = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        quat_exports.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        quat_exports.mul(transform.localRotation, transform.localRotation, rotation);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setEulerAngles = function() {
      var invParentRot = quat_exports.create();
      return function(element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === "number") {
          degrees = vec3_exports.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.setLocalEulerAngles(element, degrees);
        } else {
          quat_exports.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
          var parentRotation = _this2.getRotation(element.parentNode);
          quat_exports.copy(invParentRot, quat_exports.invert(quat_exports.create(), parentRotation));
          quat_exports.mul(transform.localRotation, transform.localRotation, invParentRot);
          _this2.dirtifyLocal(element, transform);
        }
      };
    }();
    this.translateLocal = function() {
      return function(element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === "number") {
          translation = vec3_exports.fromValues(translation, y, z);
        }
        var transform = element.transformable;
        if (vec3_exports.equals(translation, vec3_exports.create())) {
          return;
        }
        vec3_exports.transformQuat(translation, translation, transform.localRotation);
        vec3_exports.add(transform.localPosition, transform.localPosition, translation);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setPosition = function() {
      var parentInvertMatrix = mat4_exports.create();
      var tmpPosition = vec3_exports.create();
      return function(element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (vec3_exports.equals(_this2.getPosition(element), tmpPosition)) {
          return;
        }
        vec3_exports.copy(transform.position, tmpPosition);
        if (element.parentNode === null || !element.parentNode.transformable) {
          vec3_exports.copy(transform.localPosition, tmpPosition);
        } else {
          var parentTransform = element.parentNode.transformable;
          mat4_exports.copy(parentInvertMatrix, parentTransform.worldTransform);
          mat4_exports.invert(parentInvertMatrix, parentInvertMatrix);
          vec3_exports.transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
        }
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.setLocalPosition = function() {
      var tmpPosition = vec3_exports.create();
      return function(element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (vec3_exports.equals(transform.localPosition, tmpPosition)) {
          return;
        }
        vec3_exports.copy(transform.localPosition, tmpPosition);
        _this2.dirtifyLocal(element, transform);
      };
    }();
    this.translate = function() {
      var zeroVec3 = vec3_exports.create();
      var tmpVec3 = vec3_exports.create();
      var tr = vec3_exports.create();
      return function(element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === "number") {
          translation = vec3_exports.set(tmpVec3, translation, y, z);
        }
        if (vec3_exports.equals(translation, zeroVec3)) {
          return;
        }
        vec3_exports.add(tr, _this2.getPosition(element), translation);
        _this2.setPosition(element, tr);
      };
    }();
    this.setRotation = function() {
      var parentInvertRotation = quat_exports.create();
      return function(element, rotation, y, z, w) {
        var transform = element.transformable;
        if (typeof rotation === "number") {
          rotation = quat_exports.fromValues(rotation, y, z, w);
        }
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this2.setLocalRotation(element, rotation);
        } else {
          var parentRot = _this2.getRotation(element.parentNode);
          quat_exports.copy(parentInvertRotation, parentRot);
          quat_exports.invert(parentInvertRotation, parentInvertRotation);
          quat_exports.multiply(transform.localRotation, parentInvertRotation, rotation);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          _this2.dirtifyLocal(element, transform);
        }
      };
    };
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.calcLocalTransform = function() {
      var tmpMat = mat4_exports.create();
      var tmpPosition = vec3_exports.create();
      var tmpQuat = quat_exports.fromValues(0, 0, 0, 1);
      return function(transform) {
        var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
        if (hasSkew) {
          mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, vec3_exports.fromValues(1, 1, 1), transform.origin);
          if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
            var tmpMat43 = mat4_exports.identity(tmpMat);
            tmpMat43[4] = Math.tan(transform.localSkew[0]);
            tmpMat43[1] = Math.tan(transform.localSkew[1]);
            mat4_exports.multiply(transform.localTransform, transform.localTransform, tmpMat43);
          }
          var scaling = mat4_exports.fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
          mat4_exports.multiply(transform.localTransform, transform.localTransform, scaling);
        } else {
          mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
        }
      };
    }();
    this.runtime = runtime2;
  }
  var _proto = DefaultSceneGraphService2.prototype;
  _proto.matches = function matches(query, root2) {
    return this.runtime.sceneGraphSelector.is(query, root2);
  };
  _proto.querySelector = function querySelector(query, root2) {
    return this.runtime.sceneGraphSelector.selectOne(query, root2);
  };
  _proto.querySelectorAll = function querySelectorAll(query, root2) {
    return this.runtime.sceneGraphSelector.selectAll(query, root2);
  };
  _proto.attach = function attach(child, parent, index) {
    var _sortable$sorted, _child$style;
    var detached = false;
    if (child.parentNode) {
      detached = child.parentNode !== parent;
      this.detach(child);
    }
    child.parentNode = parent;
    if (!is_nil_default(index)) {
      child.parentNode.childNodes.splice(index, 0, child);
    } else {
      child.parentNode.childNodes.push(child);
    }
    var sortable = parent.sortable;
    if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) || ((_child$style = child.style) === null || _child$style === void 0 ? void 0 : _child$style.zIndex)) {
      sortable.dirty = true;
    }
    var transform = child.transformable;
    if (transform) {
      this.dirtifyWorld(child, transform);
    }
    if (transform.frozen) {
      this.unfreezeParentToRoot(child);
    }
    if (detached) {
      child.dispatchEvent(reparentEvent);
    }
  };
  _proto.detach = function detach(child) {
    if (child.parentNode) {
      var _sortable$sorted2, _child$style2;
      var transform = child.transformable;
      var sortable = child.parentNode.sortable;
      if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) || ((_child$style2 = child.style) === null || _child$style2 === void 0 ? void 0 : _child$style2.zIndex)) {
        sortable.dirty = true;
      }
      var index = child.parentNode.childNodes.indexOf(child);
      if (index > -1) {
        child.parentNode.childNodes.splice(index, 1);
      }
      if (transform) {
        this.dirtifyWorld(child, transform);
      }
      child.parentNode = null;
    }
  };
  _proto.getOrigin = function getOrigin(element) {
    return element.transformable.origin;
  };
  _proto.setOrigin = function setOrigin(element, origin, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof origin === "number") {
      origin = vec3_exports.fromValues(origin, y, z);
    }
    var transform = element.transformable;
    if (vec3_exports.equals(origin, transform.origin)) {
      return;
    }
    var originVec = transform.origin;
    originVec[0] = origin[0];
    originVec[1] = origin[1];
    originVec[2] = origin[2] || 0;
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalEulerAngles = function setLocalEulerAngles(element, degrees, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof degrees === "number") {
      degrees = vec3_exports.fromValues(degrees, y, z);
    }
    var transform = element.transformable;
    quat_exports.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
    this.dirtifyLocal(element, transform);
  };
  _proto.scaleLocal = function scaleLocal(element, scaling) {
    var transform = element.transformable;
    vec3_exports.multiply(transform.localScale, transform.localScale, vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || 1));
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalScale = function setLocalScale(element, scaling) {
    var transform = element.transformable;
    var updatedScaling = vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
    if (vec3_exports.equals(updatedScaling, transform.localScale)) {
      return;
    }
    vec3_exports.copy(transform.localScale, updatedScaling);
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalRotation = function setLocalRotation(element, rotation, y, z, w) {
    if (typeof rotation === "number") {
      rotation = quat_exports.fromValues(rotation, y, z, w);
    }
    var transform = element.transformable;
    quat_exports.copy(transform.localRotation, rotation);
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalSkew = function setLocalSkew(element, skew, y) {
    if (typeof skew === "number") {
      skew = vec2_exports.fromValues(skew, y);
    }
    var transform = element.transformable;
    vec2_exports.copy(transform.localSkew, skew);
    this.dirtifyLocal(element, transform);
  };
  _proto.dirtifyLocal = function dirtifyLocal(element, transform) {
    if (!transform.localDirtyFlag) {
      transform.localDirtyFlag = true;
      if (!transform.dirtyFlag) {
        this.dirtifyWorld(element, transform);
      }
    }
  };
  _proto.dirtifyWorld = function dirtifyWorld(element, transform) {
    if (!transform.dirtyFlag) {
      this.unfreezeParentToRoot(element);
    }
    this.dirtifyWorldInternal(element, transform);
    this.dirtifyToRoot(element, true);
  };
  _proto.triggerPendingEvents = function triggerPendingEvents() {
    var _this2 = this;
    var set7 = /* @__PURE__ */ new Set();
    var trigger = function trigger2(element, detail) {
      if (element.isConnected && !set7.has(element.entity)) {
        _this2.boundsChangedEvent.detail = detail;
        _this2.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this2.boundsChangedEvent);
        } else {
          element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
        }
        set7.add(element.entity);
      }
    };
    this.pendingEvents.forEach(function(_ref) {
      var element = _ref[0], detail = _ref[1];
      if (detail.affectChildren) {
        element.forEach(function(e2) {
          trigger(e2, detail);
        });
      } else {
        trigger(element, detail);
      }
    });
    this.clearPendingEvents();
    set7.clear();
  };
  _proto.clearPendingEvents = function clearPendingEvents() {
    this.pendingEvents = [];
  };
  _proto.dirtifyToRoot = function dirtifyToRoot(element, affectChildren) {
    if (affectChildren === void 0) {
      affectChildren = false;
    }
    var p = element;
    if (p.renderable) {
      p.renderable.dirty = true;
    }
    while (p) {
      markRenderableDirty(p);
      p = p.parentNode;
    }
    if (affectChildren) {
      element.forEach(function(e2) {
        markRenderableDirty(e2);
      });
    }
    this.informDependentDisplayObjects(element);
    this.pendingEvents.push([element, {
      affectChildren
    }]);
  };
  _proto.updateDisplayObjectDependency = function updateDisplayObjectDependency(name, oldPath, newPath, object) {
    if (oldPath && oldPath !== newPath) {
      var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
      if (oldDependencyMap && oldDependencyMap[name]) {
        var index = oldDependencyMap[name].indexOf(object);
        oldDependencyMap[name].splice(index, 1);
      }
    }
    if (newPath) {
      var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      if (!newDependencyMap) {
        this.displayObjectDependencyMap.set(newPath, {});
        newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      }
      if (!newDependencyMap[name]) {
        newDependencyMap[name] = [];
      }
      newDependencyMap[name].push(object);
    }
  };
  _proto.informDependentDisplayObjects = function informDependentDisplayObjects(object) {
    var _this3 = this;
    var dependencyMap = this.displayObjectDependencyMap.get(object);
    if (dependencyMap) {
      Object.keys(dependencyMap).forEach(function(name) {
        dependencyMap[name].forEach(function(target) {
          _this3.dirtifyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this3, _this3, name, MutationEvent.MODIFICATION, _this3, _this3));
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name, _this3, _this3);
            }
          }
        });
      });
    }
  };
  _proto.getPosition = function getPosition2(element) {
    var transform = element.transformable;
    return mat4_exports.getTranslation(transform.position, this.getWorldTransform(element, transform));
  };
  _proto.getRotation = function getRotation2(element) {
    var transform = element.transformable;
    return mat4_exports.getRotation(transform.rotation, this.getWorldTransform(element, transform));
  };
  _proto.getScale = function getScale(element) {
    var transform = element.transformable;
    return mat4_exports.getScaling(transform.scaling, this.getWorldTransform(element, transform));
  };
  _proto.getWorldTransform = function getWorldTransform(element, transform) {
    if (transform === void 0) {
      transform = element.transformable;
    }
    if (!transform.localDirtyFlag && !transform.dirtyFlag) {
      return transform.worldTransform;
    }
    if (element.parentNode && element.parentNode.transformable) {
      this.getWorldTransform(element.parentNode);
    }
    this.sync(element, transform);
    return transform.worldTransform;
  };
  _proto.getLocalPosition = function getLocalPosition(element) {
    return element.transformable.localPosition;
  };
  _proto.getLocalRotation = function getLocalRotation(element) {
    return element.transformable.localRotation;
  };
  _proto.getLocalScale = function getLocalScale(element) {
    return element.transformable.localScale;
  };
  _proto.getLocalSkew = function getLocalSkew(element) {
    return element.transformable.localSkew;
  };
  _proto.getLocalTransform = function getLocalTransform(element) {
    var transform = element.transformable;
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    return transform.localTransform;
  };
  _proto.setLocalTransform = function setLocalTransform(element, transform) {
    var t = mat4_exports.getTranslation(vec3_exports.create(), transform);
    var r = mat4_exports.getRotation(quat_exports.create(), transform);
    var s2 = mat4_exports.getScaling(vec3_exports.create(), transform);
    this.setLocalScale(element, s2);
    this.setLocalPosition(element, t);
    this.setLocalRotation(element, r);
  };
  _proto.resetLocalTransform = function resetLocalTransform(element) {
    this.setLocalScale(element, [1, 1, 1]);
    this.setLocalPosition(element, [0, 0, 0]);
    this.setLocalEulerAngles(element, [0, 0, 0]);
    this.setLocalSkew(element, [0, 0]);
  };
  _proto.getTransformedGeometryBounds = function getTransformedGeometryBounds(element, render3, existedAABB) {
    if (render3 === void 0) {
      render3 = false;
    }
    var bounds = this.getGeometryBounds(element, render3);
    if (!AABB.isEmpty(bounds)) {
      var aabb = existedAABB || new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      return aabb;
    } else {
      return null;
    }
  };
  _proto.getGeometryBounds = function getGeometryBounds(element, render3) {
    if (render3 === void 0) {
      render3 = false;
    }
    var geometry = element.geometry;
    var bounds = render3 ? geometry.renderBounds : geometry.contentBounds || null;
    return bounds || new AABB();
  };
  _proto.getBounds = function getBounds(element, render3) {
    var _this4 = this;
    if (render3 === void 0) {
      render3 = false;
    }
    var renderable = element.renderable;
    if (!renderable.boundsDirty && !render3 && renderable.bounds) {
      return renderable.bounds;
    }
    if (!renderable.renderBoundsDirty && render3 && renderable.renderBounds) {
      return renderable.renderBounds;
    }
    var existedAABB = render3 ? renderable.renderBounds : renderable.bounds;
    var aabb = this.getTransformedGeometryBounds(element, render3, existedAABB);
    var children = element.childNodes;
    children.forEach(function(child) {
      var childBounds = _this4.getBounds(child, render3);
      if (childBounds) {
        if (!aabb) {
          aabb = existedAABB || new AABB();
          aabb.update(childBounds.center, childBounds.halfExtents);
        } else {
          aabb.add(childBounds);
        }
      }
    });
    if (render3) {
      var clipped = findClosestClipPathTarget(element);
      if (clipped) {
        var clipPathBounds = clipped.style.clipPath.getBounds(render3);
        if (!aabb) {
          aabb = clipPathBounds;
        } else if (clipPathBounds) {
          aabb = clipPathBounds.intersection(aabb);
        }
      }
    }
    if (!aabb) {
      aabb = new AABB();
    }
    if (aabb) {
      if (render3) {
        renderable.renderBounds = aabb;
      } else {
        renderable.bounds = aabb;
      }
    }
    if (render3) {
      renderable.renderBoundsDirty = false;
    } else {
      renderable.boundsDirty = false;
    }
    return aabb;
  };
  _proto.getLocalBounds = function getLocalBounds(element) {
    if (element.parentNode) {
      var parentInvert = mat4_exports.create();
      if (element.parentNode.transformable) {
        parentInvert = mat4_exports.invert(mat4_exports.create(), this.getWorldTransform(element.parentNode));
      }
      var bounds = this.getBounds(element);
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds(element);
  };
  _proto.getBoundingClientRect = function getBoundingClientRect(element) {
    var _element$ownerDocumen, _element$ownerDocumen2;
    var aabb;
    var bounds = this.getGeometryBounds(element);
    if (!AABB.isEmpty(bounds)) {
      aabb = new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
    }
    var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : (_element$ownerDocumen2 = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.getContextService().getBoundingClientRect();
    if (aabb) {
      var _aabb$getMin = aabb.getMin(), left = _aabb$getMin[0], top = _aabb$getMin[1];
      var _aabb$getMax = aabb.getMax(), right = _aabb$getMax[0], bottom = _aabb$getMax[1];
      return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
    }
    return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
  };
  _proto.dirtifyWorldInternal = function dirtifyWorldInternal(element, transform) {
    var _this5 = this;
    if (!transform.dirtyFlag) {
      transform.dirtyFlag = true;
      transform.frozen = false;
      element.childNodes.forEach(function(child) {
        var childTransform = child.transformable;
        if (!childTransform.dirtyFlag) {
          _this5.dirtifyWorldInternal(child, childTransform);
        }
      });
      var renderable = element.renderable;
      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }
    }
  };
  _proto.syncHierarchy = function syncHierarchy(element) {
    var transform = element.transformable;
    if (transform.frozen) {
      return;
    }
    transform.frozen = true;
    if (transform.localDirtyFlag || transform.dirtyFlag) {
      this.sync(element, transform);
    }
    var children = element.childNodes;
    for (var i = 0; i < children.length; i++) {
      this.syncHierarchy(children[i]);
    }
  };
  _proto.sync = function sync(element, transform) {
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    if (transform.dirtyFlag) {
      var parent = element.parentNode;
      var parentTransform = parent && parent.transformable;
      if (parent === null || !parentTransform) {
        mat4_exports.copy(transform.worldTransform, transform.localTransform);
      } else {
        mat4_exports.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
      }
      transform.dirtyFlag = false;
    }
  };
  _proto.unfreezeParentToRoot = function unfreezeParentToRoot(child) {
    var p = child.parentNode;
    while (p) {
      var transform = p.transformable;
      if (transform) {
        transform.frozen = false;
      }
      p = p.parentNode;
    }
  };
  return DefaultSceneGraphService2;
}();
var TEXT_METRICS = {
  MetricsString: "|ÉqÅ",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
var regexCannotStart = new RegExp(regexCannotStartZhCn.source + "|" + regexCannotStartZhTw.source + "|" + regexCannotStartJaJp.source + "|" + regexCannotStartKoKr.source);
var regexCannotEnd = new RegExp(regexCannotEndZhCn.source + "|" + regexCannotEndZhTw.source + "|" + regexCannotEndJaJp.source + "|" + regexCannotEndKoKr.source);
var TextService = function() {
  function TextService2(runtime2) {
    var _this2 = this;
    this.runtime = void 0;
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(char, nextChar) {
      if (_this2.isBreakingSpace(nextChar))
        return false;
      if (char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = [].concat(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
  }
  var _proto = TextService2.prototype;
  _proto.measureFont = function measureFont(font, offscreenCanvas) {
    if (this.fontMetricsCache[font]) {
      return this.fontMetricsCache[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas = this.runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
    var width = Math.ceil(context.measureText(metricsString).width);
    var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
    var height = TEXT_METRICS.HeightMultiplier * baseline;
    baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
    var pixels = imagedata.length;
    var line3 = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; ++i) {
      for (var j = 0; j < line3; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line3;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line3;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (var _j = 0; _j < line3; _j += 4) {
        if (imagedata[idx + _j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line3;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    this.fontMetricsCache[font] = properties;
    return properties;
  };
  _proto.measureText = function measureText2(text, parsedStyle, offscreenCanvas) {
    var fontSize = parsedStyle.fontSize, wordWrap = parsedStyle.wordWrap, strokeHeight = parsedStyle.lineHeight, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, textAlign = parsedStyle.textAlign, letterSpacing = parsedStyle.letterSpacing, textPath = parsedStyle.textPath, textPathSide = parsedStyle.textPathSide, textPathStartOffset = parsedStyle.textPathStartOffset, _parsedStyle$leading = parsedStyle.leading, leading2 = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
    var font = toFontString(parsedStyle);
    var fontProperties = this.measureFont(font, offscreenCanvas);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = fontSize;
      fontProperties.ascent = fontSize;
    }
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    parsedStyle.isOverflowing = false;
    var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    if (textPath) {
      var totalPathLength = textPath.getTotalLength();
      for (var i = 0; i < lines.length; i++) {
        var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
      }
    } else {
      for (var _i = 0; _i < lines.length; _i++) {
        var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
        lineWidths[_i] = _lineWidth;
        maxLineWidth = Math.max(maxLineWidth, _lineWidth);
      }
      var _width = maxLineWidth + lineWidth;
      var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
      var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading2);
      lineHeight += leading2;
      var offsetY = 0;
      if (textBaseline === "middle") {
        offsetY = -height / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        offsetY = -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        offsetY = 0;
      }
      return {
        font,
        width: _width,
        height,
        lines,
        lineWidths,
        lineHeight,
        maxLineWidth,
        fontProperties,
        lineMetrics: lineWidths.map(function(width2, i2) {
          var offsetX = 0;
          if (textAlign === "center" || textAlign === "middle") {
            offsetX -= width2 / 2;
          } else if (textAlign === "right" || textAlign === "end") {
            offsetX -= width2;
          }
          return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width2 + lineWidth, lineHeight);
        })
      };
    }
  };
  _proto.setGraphemeOnPath = function setGraphemeOnPath() {
  };
  _proto.wordWrap = function wordWrap(text, parsedStyle, offscreenCanvas) {
    var _this2 = this;
    var _parsedStyle$wordWrap = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap === void 0 ? 0 : _parsedStyle$wordWrap, letterSpacing = parsedStyle.letterSpacing, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    var maxWidth = wordWrapWidth + letterSpacing;
    var ellipsis = "";
    if (textOverflow === "ellipsis") {
      ellipsis = "...";
    } else if (textOverflow && textOverflow !== "clip") {
      ellipsis = textOverflow;
    }
    var lines = [];
    var currentIndex = 0;
    var currentWidth = 0;
    var cache = {};
    var calcWidth = function calcWidth2(char2) {
      return _this2.getFromCache(char2, letterSpacing, cache, context);
    };
    var ellipsisWidth = Array.from(ellipsis).reduce(function(prev, cur) {
      return prev + calcWidth(cur);
    }, 0);
    var chars = Array.from(text);
    for (var i = 0; i < chars.length; i++) {
      var char = chars[i];
      var prevChar = text[i - 1];
      var nextChar = text[i + 1];
      var charWidth = calcWidth(char);
      if (this.isNewline(char)) {
        currentIndex++;
        if (currentIndex >= maxLines) {
          parsedStyle.isOverflowing = true;
          break;
        }
        currentWidth = 0;
        lines[currentIndex] = "";
        continue;
      }
      if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
        if (currentIndex + 1 >= maxLines) {
          parsedStyle.isOverflowing = true;
          if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
            var currentLineLength = lines[currentIndex].length;
            var lastLineWidth = 0;
            var lastLineIndex = currentLineLength;
            for (var _i2 = 0; _i2 < currentLineLength; _i2++) {
              var width = calcWidth(lines[currentIndex][_i2]);
              if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                lastLineIndex = _i2;
                break;
              }
              lastLineWidth += width;
            }
            lines[currentIndex] = (lines[currentIndex] || "").slice(0, lastLineIndex) + ellipsis;
          }
          break;
        }
        currentIndex++;
        currentWidth = 0;
        lines[currentIndex] = "";
        if (this.isBreakingSpace(char)) {
          continue;
        }
        if (!this.canBreakInLastChar(char)) {
          lines = this.trimToBreakable(lines);
          currentWidth = this.sumTextWidthByCache(lines[currentIndex] || "", cache);
        }
        if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
          lines = this.trimByKinsokuShorui(lines);
          currentWidth += calcWidth(prevChar || "");
        }
      }
      currentWidth += charWidth;
      lines[currentIndex] = (lines[currentIndex] || "") + char;
    }
    return lines.join("\n");
  };
  _proto.isBreakingSpace = function isBreakingSpace(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.isNewline = function isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.trimToBreakable = function trimToBreakable(prev) {
    var next = [].concat(prev);
    var prevLine = next[next.length - 2];
    var index = this.findBreakableIndex(prevLine);
    if (index === -1 || !prevLine)
      return next;
    var trimmedChar = prevLine.slice(index, index + 1);
    var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
    var trimFrom = index + 1;
    var trimTo = index + (isTrimmedWithSpace ? 0 : 1);
    next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
    next[next.length - 2] = prevLine.slice(0, trimTo);
    return next;
  };
  _proto.canBreakInLastChar = function canBreakInLastChar(char) {
    if (char && LATIN_REGEX.test(char))
      return false;
    return true;
  };
  _proto.sumTextWidthByCache = function sumTextWidthByCache(text, cache) {
    return text.split("").reduce(function(sum, c) {
      if (!cache[c])
        throw Error("cannot count the word without cache");
      return sum + cache[c];
    }, 0);
  };
  _proto.findBreakableIndex = function findBreakableIndex(line3) {
    for (var i = line3.length - 1; i >= 0; i--) {
      if (!LATIN_REGEX.test(line3[i]))
        return i;
    }
    return -1;
  };
  _proto.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
    var width = cache[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  return TextService2;
}();
var _this = void 0;
var runtime = {};
var geometryUpdaterFactory = function() {
  var _ref;
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _ref[Shape.CIRCLE] = new CircleUpdater(), _ref[Shape.ELLIPSE] = new EllipseUpdater(), _ref[Shape.RECT] = rectUpdater, _ref[Shape.IMAGE] = rectUpdater, _ref[Shape.GROUP] = rectUpdater, _ref[Shape.LINE] = new LineUpdater(), _ref[Shape.TEXT] = new TextUpdater(runtime), _ref[Shape.POLYLINE] = polylineUpdater, _ref[Shape.POLYGON] = polylineUpdater, _ref[Shape.PATH] = new PathUpdater(), _ref[Shape.HTML] = null, _ref[Shape.MESH] = null, _ref;
}();
var CSSPropertySyntaxFactory = function() {
  var _ref2;
  var color2 = new CSSPropertyColor();
  var length14 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _ref2[PropertySyntax.PERCENTAGE] = null, _ref2[PropertySyntax.NUMBER] = new CSSPropertyNumber(), _ref2[PropertySyntax.ANGLE] = new CSSPropertyAngle(), _ref2[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _ref2[PropertySyntax.PAINT] = color2, _ref2[PropertySyntax.COLOR] = color2, _ref2[PropertySyntax.FILTER] = new CSSPropertyFilter(), _ref2[PropertySyntax.LENGTH] = length14, _ref2[PropertySyntax.LENGTH_PERCENTAGE] = length14, _ref2[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _ref2[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _ref2[PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(), _ref2[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _ref2[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _ref2[PropertySyntax.PATH] = new CSSPropertyPath(), _ref2[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _ref2[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _ref2[PropertySyntax.TEXT] = new CSSPropertyText(), _ref2[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _ref2[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _ref2[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _ref2[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _ref2[PropertySyntax.MARKER] = new CSSPropertyMarker(), _ref2;
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (typeof _this !== "undefined")
    return _this;
  throw new Error("Unable to locate global `this`");
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvas = new OffscreenCanvasCreator();
runtime.displayObjectPool = new DisplayObjectPool();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry();
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableCSSParsing = true;
var AbstractRendererPlugin = function() {
  function AbstractRendererPlugin2() {
    this.context = void 0;
    this.plugins = [];
  }
  var _proto = AbstractRendererPlugin2.prototype;
  _proto.addRenderingPlugin = function addRenderingPlugin(plugin) {
    this.plugins.push(plugin);
    this.context.renderingPlugins.push(plugin);
  };
  _proto.removeAllRenderingPlugins = function removeAllRenderingPlugins() {
    var _this2 = this;
    this.plugins.forEach(function(plugin) {
      var index = _this2.context.renderingPlugins.indexOf(plugin);
      if (index >= 0) {
        _this2.context.renderingPlugins.splice(index, 1);
      }
    });
  };
  return AbstractRendererPlugin2;
}();
var AbstractRenderer = function() {
  function AbstractRenderer2(config) {
    this.plugins = [];
    this.config = void 0;
    this.config = _extends({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false
    }, config);
  }
  var _proto2 = AbstractRenderer2.prototype;
  _proto2.registerPlugin = function registerPlugin(plugin) {
    var index = this.plugins.findIndex(function(p) {
      return p === plugin;
    });
    if (index === -1) {
      this.plugins.push(plugin);
    }
  };
  _proto2.unregisterPlugin = function unregisterPlugin(plugin) {
    var index = this.plugins.findIndex(function(p) {
      return p === plugin;
    });
    if (index > -1) {
      this.plugins.splice(index, 1);
    }
  };
  _proto2.getPlugins = function getPlugins() {
    return this.plugins;
  };
  _proto2.getPlugin = function getPlugin(name) {
    return this.plugins.find(function(plugin) {
      return plugin.name === name;
    });
  };
  _proto2.getConfig = function getConfig() {
    return this.config;
  };
  _proto2.setConfig = function setConfig(config) {
    Object.assign(this.config, config);
  };
  return AbstractRenderer2;
}();
var CullingPlugin = function() {
  function CullingPlugin2(strategies) {
    this.strategies = void 0;
    this.strategies = strategies;
  }
  var _proto = CullingPlugin2.prototype;
  _proto.apply = function apply(context) {
    var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
    var strategies = this.strategies;
    renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
      if (object) {
        var cullable = object.cullable;
        if (strategies.length === 0) {
          cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
        } else {
          cullable.visible = strategies.every(function(strategy) {
            return strategy.isVisible(camera, object);
          });
        }
        if (!object.isCulled() && object.isVisible()) {
          return object;
        } else {
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
        }
        return null;
      }
      return object;
    });
    renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
      object.cullable.visibilityPlaneMask = -1;
    });
  };
  return CullingPlugin2;
}();
CullingPlugin.tag = "Culling";
var DirtyCheckPlugin = function() {
  function DirtyCheckPlugin2() {
  }
  var _proto = DirtyCheckPlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService;
    renderingService.hooks.dirtycheck.tap(DirtyCheckPlugin2.tag, function(object) {
      if (object) {
        var renderable = object.renderable;
        var isDirty = renderable.dirty || renderingService.disableDirtyRectangleRendering();
        if (isDirty) {
          return object;
        } else {
          return null;
        }
      }
      return object;
    });
  };
  return DirtyCheckPlugin2;
}();
DirtyCheckPlugin.tag = "DirtyCheck";
var EventPlugin = function() {
  function EventPlugin2() {
    var _this2 = this;
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.context = void 0;
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi, _this$context$renderi2;
      var canvas = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 ? void 0 : (_this$context$renderi2 = _this$context$renderi.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator = _createForOfIteratorHelperLoose(normalizedEvents), _step; !(_step = _iterator()).done; ) {
        var normalizedEvent = _step.value;
        var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas);
        _this2.context.eventService.mapEvent(event);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  var _proto = EventPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    this.context = context;
    var renderingService = context.renderingService;
    var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
    this.context.eventService.setPickHandler(function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(position) {
        var _yield$_this2$context, picked;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.context.renderingService.hooks.pick.promise({
                  position,
                  picked: [],
                  topmost: true
                  // we only concern the topmost element
                });
              case 2:
                _yield$_this2$context = _context.sent;
                picked = _yield$_this2$context.picked;
                return _context.abrupt("return", picked[0] || null);
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }());
    renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
      var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
      _this2.context.eventService.mapEvent(wheelEvent);
    });
    renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      if (_this2.autoPreventDefault && events[0].isNormalized) {
        var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(events), _step2; !(_step2 = _iterator2()).done; ) {
        var event = _step2.value;
        var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas);
        _this2.context.eventService.mapEvent(federatedEvent);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var $element = _this2.context.contextService.getDomElement();
      var outside = "outside";
      try {
        outside = $element && nativeEvent.target && nativeEvent.target !== $element && $element.contains && !$element.contains(nativeEvent.target) ? "outside" : "";
      } catch (e2) {
      }
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator3 = _createForOfIteratorHelperLoose(normalizedEvents), _step3; !(_step3 = _iterator3()).done; ) {
        var normalizedEvent = _step3.value;
        var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas);
        event.type += outside;
        _this2.context.eventService.mapEvent(event);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
    renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
    renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
  };
  _proto.getViewportXY = function getViewportXY(nativeEvent) {
    var x;
    var y;
    var offsetX = nativeEvent.offsetX, offsetY = nativeEvent.offsetY, clientX = nativeEvent.clientX, clientY = nativeEvent.clientY;
    if (this.context.config.supportsCSSTransform && !is_nil_default(offsetX) && !is_nil_default(offsetY)) {
      x = offsetX;
      y = offsetY;
    } else {
      var point = this.context.eventService.client2Viewport(new Point(clientX, clientY));
      x = point.x;
      y = point.y;
    }
    return {
      x,
      y
    };
  };
  _proto.bootstrapEvent = function bootstrapEvent(event, nativeEvent, view) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    var _this$getViewportXY = this.getViewportXY(nativeEvent), x = _this$getViewportXY.x, y = _this$getViewportXY.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe.x, canvasY = _this$context$eventSe.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  };
  _proto.normalizeWheelEvent = function normalizeWheelEvent(nativeEvent) {
    var event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaMode = nativeEvent.deltaMode;
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    var _this$getViewportXY2 = this.getViewportXY(nativeEvent), x = _this$getViewportXY2.x, y = _this$getViewportXY2.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  };
  _proto.transferMouseData = function transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.metaKey = nativeEvent.metaKey;
    event.shiftKey = nativeEvent.shiftKey;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  };
  _proto.setCursor = function setCursor(cursor) {
    this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
  };
  _proto.normalizeToPointerEvent = function normalizeToPointerEvent(event, canvas) {
    var normalizedEvents = [];
    if (canvas.isTouchEvent(event)) {
      for (var i = 0; i < event.changedTouches.length; i++) {
        var touch = event.changedTouches[i];
        if (is_undefined_default(touch.button))
          touch.button = 0;
        if (is_undefined_default(touch.buttons))
          touch.buttons = 1;
        if (is_undefined_default(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (is_undefined_default(touch.width))
          touch.width = touch.radiusX || 1;
        if (is_undefined_default(touch.height))
          touch.height = touch.radiusY || 1;
        if (is_undefined_default(touch.tiltX))
          touch.tiltX = 0;
        if (is_undefined_default(touch.tiltY))
          touch.tiltY = 0;
        if (is_undefined_default(touch.pointerType))
          touch.pointerType = "touch";
        if (is_undefined_default(touch.pointerId))
          touch.pointerId = touch.identifier || 0;
        if (is_undefined_default(touch.pressure))
          touch.pressure = touch.force || 0.5;
        if (is_undefined_default(touch.twist))
          touch.twist = 0;
        if (is_undefined_default(touch.tangentialPressure))
          touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (canvas.isMouseEvent(event)) {
      var tempEvent = event;
      if (is_undefined_default(tempEvent.isPrimary))
        tempEvent.isPrimary = true;
      if (is_undefined_default(tempEvent.width))
        tempEvent.width = 1;
      if (is_undefined_default(tempEvent.height))
        tempEvent.height = 1;
      if (is_undefined_default(tempEvent.tiltX))
        tempEvent.tiltX = 0;
      if (is_undefined_default(tempEvent.tiltY))
        tempEvent.tiltY = 0;
      if (is_undefined_default(tempEvent.pointerType))
        tempEvent.pointerType = "mouse";
      if (is_undefined_default(tempEvent.pointerId))
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (is_undefined_default(tempEvent.pressure))
        tempEvent.pressure = 0.5;
      if (is_undefined_default(tempEvent.twist))
        tempEvent.twist = 0;
      if (is_undefined_default(tempEvent.tangentialPressure))
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  return EventPlugin2;
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = function() {
  function FrustumCullingStrategy2() {
  }
  var _proto = FrustumCullingStrategy2.prototype;
  _proto.isVisible = function isVisible(camera, object) {
    var _object$parentNode, _object$parentNode$cu;
    var cullable = object.cullable;
    if (!cullable.enable) {
      return true;
    }
    var renderBounds = object.getRenderBounds();
    if (AABB.isEmpty(renderBounds)) {
      return false;
    }
    var frustum2 = camera.getFrustum();
    var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 ? void 0 : (_object$parentNode$cu = _object$parentNode.cullable) === null || _object$parentNode$cu === void 0 ? void 0 : _object$parentNode$cu.visibilityPlaneMask;
    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
    cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
    return cullable.visible;
  };
  _proto.computeVisibilityWithPlaneMask = function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
      return parentPlaneMask;
    }
    var mask = Mask.INSIDE;
    var isShape2D = shape2D.indexOf(object.nodeName) > -1;
    for (var k = 0, len5 = planes.length; k < len5; ++k) {
      var flag = 1 << k;
      if ((parentPlaneMask & flag) === 0) {
        continue;
      }
      if (isShape2D && (k === 4 || k === 5)) {
        continue;
      }
      var _planes$k = planes[k], normal = _planes$k.normal, distance6 = _planes$k.distance;
      if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance6 < 0) {
        return Mask.OUTSIDE;
      }
      if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance6 < 0) {
        mask |= flag;
      }
    }
    return mask;
  };
  return FrustumCullingStrategy2;
}();
var PrepareRendererPlugin = function() {
  function PrepareRendererPlugin2() {
    this.rBush = void 0;
    this.toSync = /* @__PURE__ */ new Set();
  }
  var _proto = PrepareRendererPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    this.rBush = rBushRoot;
    var handleAttributeChanged = function handleAttributeChanged2(e2) {
      var object = e2.target;
      object.renderable.dirty = true;
      renderingService.dirtify();
    };
    var handleBoundsChanged = function handleBoundsChanged2(e2) {
      var affectChildren = e2.detail.affectChildren;
      var object = e2.target;
      if (affectChildren) {
        object.forEach(function(node) {
          _this2.toSync.add(node);
        });
      }
      var p = object;
      while (p) {
        if (p.renderable) {
          _this2.toSync.add(p);
        }
        p = p.parentElement;
      }
      renderingService.dirtify();
    };
    var handleMounted = function handleMounted2(e2) {
      var object = e2.target;
      if (runtime.enableCSSParsing) {
        runtime.styleValueRegistry.recalc(object);
      }
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    var handleUnmounted = function handleUnmounted2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.rBush.remove(rBushNode.aabb);
      }
      _this2.toSync.delete(object);
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    renderingService.hooks.init.tapPromise(PrepareRendererPlugin2.tag, _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
              canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
      canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
      canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      _this2.toSync.clear();
    });
    renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
      _this2.syncRTree();
    });
  };
  _proto.syncRTree = function syncRTree() {
    var _this2 = this;
    var bulk = [];
    Array.from(this.toSync).filter(function(object) {
      return object.isConnected;
    }).forEach(function(node) {
      var rBushNode = node.rBushNode;
      if (rBushNode && rBushNode.aabb) {
        _this2.rBush.remove(rBushNode.aabb);
      }
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var _renderBounds$getMin = renderBounds.getMin(), minX = _renderBounds$getMin[0], minY = _renderBounds$getMin[1];
        var _renderBounds$getMax = renderBounds.getMax(), maxX = _renderBounds$getMax[0], maxY = _renderBounds$getMax[1];
        if (!rBushNode.aabb) {
          rBushNode.aabb = {};
        }
        rBushNode.aabb.id = node.entity;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY;
      }
      if (rBushNode.aabb) {
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          bulk.push(rBushNode.aabb);
        }
      }
    });
    this.rBush.load(bulk);
    bulk.length = 0;
    this.toSync.clear();
  };
  return PrepareRendererPlugin2;
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent;
(function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
})(CanvasEvent || (CanvasEvent = {}));
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = function(_EventTarget) {
  _inheritsLoose(Canvas3, _EventTarget);
  function Canvas3(config) {
    var _this2;
    _this2 = _EventTarget.call(this) || this;
    _this2.document = void 0;
    _this2.customElements = void 0;
    _this2.requestAnimationFrame = void 0;
    _this2.cancelAnimationFrame = void 0;
    _this2.devicePixelRatio = void 0;
    _this2.supportsPointerEvents = void 0;
    _this2.supportsTouchEvents = void 0;
    _this2.isTouchEvent = void 0;
    _this2.isMouseEvent = void 0;
    _this2.Element = DisplayObject;
    _this2.frameId = void 0;
    _this2.inited = false;
    _this2.readyPromise = void 0;
    _this2.resolveReadyPromise = void 0;
    _this2.context = {};
    _this2.document = new Document();
    _this2.document.defaultView = _assertThisInitialized(_this2);
    _this2.customElements = new CustomElementRegistry();
    var container = config.container, canvas = config.canvas, offscreenCanvas = config.offscreenCanvas, width = config.width, height = config.height, devicePixelRatio = config.devicePixelRatio, renderer = config.renderer, background = config.background, cursor = config.cursor, document2 = config.document, requestAnimationFrame3 = config.requestAnimationFrame, cancelAnimationFrame3 = config.cancelAnimationFrame, createImage = config.createImage, supportsPointerEvents = config.supportsPointerEvents, supportsTouchEvents = config.supportsTouchEvents, supportsCSSTransform = config.supportsCSSTransform, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent;
    cleanExistedCanvas(container, _assertThisInitialized(_this2));
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio;
    if (canvas) {
      dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame3 !== null && requestAnimationFrame3 !== void 0 ? requestAnimationFrame3 : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame3 !== null && cancelAnimationFrame3 !== void 0 ? cancelAnimationFrame3 : caf.bind(runtime.globalThis);
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    _this2.initRenderingContext({
      container,
      canvas,
      width: canvasWidth,
      height: canvasHeight,
      renderer,
      offscreenCanvas,
      devicePixelRatio: dpr,
      cursor: cursor || "default",
      background: background || "transparent",
      createImage,
      document: document2,
      supportsCSSTransform
    });
    _this2.initDefaultCamera(canvasWidth, canvasHeight);
    _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this2.initRenderer(renderer);
            case 2:
              _this2.dispatchEvent(new CustomEvent(CanvasEvent.READY));
              if (_this2.readyPromise) {
                _this2.resolveReadyPromise();
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
    return _this2;
  }
  var _proto = Canvas3.prototype;
  _proto.initRenderingContext = function initRenderingContext(mergedConfig) {
    this.context.config = mergedConfig;
    this.context.renderingContext = {
      /**
       * the root node in scene graph
       */
      root: this.document.documentElement,
      renderListCurrentFrame: [],
      unculledEntities: [],
      renderReasons: /* @__PURE__ */ new Set(),
      force: false,
      dirty: false
    };
  };
  _proto.initDefaultCamera = function initDefaultCamera(width, height) {
    var _this2 = this;
    var camera = new runtime.CameraContribution();
    camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
    camera.canvas = this;
    camera.eventEmitter.on(CameraEvent.UPDATED, function() {
      _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    });
    this.context.camera = camera;
  };
  _proto.getConfig = function getConfig() {
    return this.context.config;
  };
  _proto.getRoot = function getRoot() {
    return this.document.documentElement;
  };
  _proto.getCamera = function getCamera() {
    return this.context.camera;
  };
  _proto.getContextService = function getContextService() {
    return this.context.contextService;
  };
  _proto.getEventService = function getEventService() {
    return this.context.eventService;
  };
  _proto.getRenderingService = function getRenderingService() {
    return this.context.renderingService;
  };
  _proto.getRenderingContext = function getRenderingContext() {
    return this.context.renderingContext;
  };
  _proto.getStats = function getStats() {
    return this.getRenderingService().getStats();
  };
  _proto.destroy = function destroy(cleanUp, skipTriggerEvent) {
    if (cleanUp === void 0) {
      cleanUp = true;
    }
    if (skipTriggerEvent === void 0) {
      skipTriggerEvent = false;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
    }
    if (this.frameId) {
      var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
      cancelRAF(this.frameId);
    }
    var root2 = this.getRoot();
    this.unmountChildren(root2);
    if (cleanUp) {
      this.document.destroy();
      this.getEventService().destroy();
    }
    this.getRenderingService().destroy();
    this.getContextService().destroy();
    if (cleanUp && this.context.rBushRoot) {
      this.context.rBushRoot.clear();
      this.context.rBushRoot = null;
      this.context.renderingContext.root = null;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
    }
  };
  _proto.changeSize = function changeSize(width, height) {
    this.resize(width, height);
  };
  _proto.resize = function resize(width, height) {
    var canvasConfig = this.context.config;
    canvasConfig.width = width;
    canvasConfig.height = height;
    this.getContextService().resize(width, height);
    var camera = this.context.camera;
    var projectionMode = camera.getProjectionMode();
    camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
    if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
    } else {
      camera.setAspect(width / height);
    }
    this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
      width,
      height
    }));
  };
  _proto.appendChild = function appendChild(child, index) {
    return this.document.documentElement.appendChild(child, index);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    return this.document.documentElement.insertBefore(newChild, refChild);
  };
  _proto.removeChild = function removeChild(child) {
    return this.document.documentElement.removeChild(child);
  };
  _proto.removeChildren = function removeChildren() {
    this.document.documentElement.removeChildren();
  };
  _proto.destroyChildren = function destroyChildren() {
    this.document.documentElement.destroyChildren();
  };
  _proto.render = function render3() {
    var _this3 = this;
    this.dispatchEvent(beforeRenderEvent);
    var renderingService = this.getRenderingService();
    renderingService.render(this.getConfig(), function() {
      _this3.dispatchEvent(rerenderEvent);
    });
    this.dispatchEvent(afterRenderEvent);
  };
  _proto.run = function run() {
    var _this4 = this;
    var tick = function tick2() {
      _this4.render();
      _this4.frameId = requestAnimationFrame(tick2);
    };
    tick();
  };
  _proto.initRenderer = function() {
    var _initRenderer = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(renderer) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (renderer) {
                _context2.next = 2;
                break;
              }
              throw new Error("Renderer is required.");
            case 2:
              this.inited = false;
              this.readyPromise = void 0;
              this.context.rBushRoot = new import_rbush.default();
              this.context.renderingPlugins = [];
              this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), new DirtyCheckPlugin(), new CullingPlugin([new FrustumCullingStrategy()]));
              this.loadRendererContainerModule(renderer);
              this.context.contextService = new this.context.ContextService(_extends({}, runtime, this.context));
              this.context.renderingService = new RenderingService(runtime, this.context);
              this.context.eventService = new EventService(runtime, this.context);
              this.context.eventService.init();
              _context2.next = 14;
              return this.context.contextService.init();
            case 14:
              _context2.next = 16;
              return this.context.renderingService.init();
            case 16:
              this.inited = true;
              this.getRoot().forEach(function(node) {
                var renderable = node.renderable;
                if (renderable) {
                  renderable.renderBoundsDirty = true;
                  renderable.boundsDirty = true;
                  renderable.dirty = true;
                }
              });
              this.mountChildren(this.getRoot());
              if (renderer.getConfig().enableAutoRendering) {
                this.run();
              }
            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function initRenderer(_x) {
      return _initRenderer.apply(this, arguments);
    }
    return initRenderer;
  }();
  _proto.loadRendererContainerModule = function loadRendererContainerModule(renderer) {
    var _this5 = this;
    var plugins = renderer.getPlugins();
    plugins.forEach(function(plugin) {
      plugin.context = _this5.context;
      plugin.init(runtime);
    });
  };
  _proto.setRenderer = function() {
    var _setRenderer = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(renderer) {
      var canvasConfig, oldRenderer;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              canvasConfig = this.getConfig();
              if (!(canvasConfig.renderer === renderer)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              oldRenderer = canvasConfig.renderer;
              canvasConfig.renderer = renderer;
              this.destroy(false, true);
              [].concat(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()).reverse().forEach(function(plugin) {
                plugin.destroy(runtime);
              });
              _context3.next = 9;
              return this.initRenderer(renderer);
            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function setRenderer(_x2) {
      return _setRenderer.apply(this, arguments);
    }
    return setRenderer;
  }();
  _proto.setCursor = function setCursor(cursor) {
    var canvasConfig = this.getConfig();
    canvasConfig.cursor = cursor;
    this.getContextService().applyCursorStyle(cursor);
  };
  _proto.unmountChildren = function unmountChildren(parent) {
    var _this6 = this;
    parent.childNodes.forEach(function(child) {
      _this6.unmountChildren(child);
    });
    if (this.inited) {
      if (parent.isMutationObserved) {
        parent.dispatchEvent(unmountedEvent);
      } else {
        unmountedEvent.target = parent;
        this.dispatchEvent(unmountedEvent, true);
      }
      if (parent !== this.document.documentElement) {
        parent.ownerDocument = null;
      }
      parent.isConnected = false;
    }
    if (parent.isCustomElement) {
      if (parent.disconnectedCallback) {
        parent.disconnectedCallback();
      }
    }
  };
  _proto.mountChildren = function mountChildren(parent) {
    var _this7 = this;
    if (this.inited) {
      if (!parent.isConnected) {
        parent.ownerDocument = this.document;
        parent.isConnected = true;
        if (parent.isMutationObserved) {
          parent.dispatchEvent(mountedEvent);
        } else {
          mountedEvent.target = parent;
          this.dispatchEvent(mountedEvent, true);
        }
      }
    } else {
      console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", parent.nodeName);
    }
    parent.childNodes.forEach(function(child) {
      _this7.mountChildren(child);
    });
    if (parent.isCustomElement) {
      if (parent.connectedCallback) {
        parent.connectedCallback();
      }
    }
  };
  _proto.client2Viewport = function client2Viewport(client) {
    return this.getEventService().client2Viewport(client);
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    return this.getEventService().viewport2Client(canvas);
  };
  _proto.viewport2Canvas = function viewport2Canvas(viewport) {
    return this.getEventService().viewport2Canvas(viewport);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvas) {
    return this.getEventService().canvas2Viewport(canvas);
  };
  _proto.getPointByClient = function getPointByClient(clientX, clientY) {
    return this.client2Viewport({
      x: clientX,
      y: clientY
    });
  };
  _proto.getClientByPoint = function getClientByPoint(x, y) {
    return this.viewport2Client({
      x,
      y
    });
  };
  _createClass(Canvas3, [{
    key: "ready",
    get: function get() {
      var _this8 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this8.resolveReadyPromise = function() {
            resolve(_this8);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
  }]);
  return Canvas3;
}(EventTarget);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/util/util.js
var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/arc.js
function computeArcSweep(startAngle, endAngle, anticlockwise) {
  if (!anticlockwise) {
    if (endAngle >= startAngle) {
      return endAngle - startAngle <= Math.PI ? 0 : 1;
    }
    return endAngle - startAngle <= -Math.PI ? 0 : 1;
  }
  if (endAngle >= startAngle) {
    return endAngle - startAngle <= Math.PI ? 1 : 0;
  }
  return endAngle - startAngle <= -Math.PI ? 1 : 0;
}
var Arc = (
  /** @class */
  function(_super) {
    __extends(Arc2, _super);
    function Arc2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Arc2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["cx", "cy", "startAngle", "endAngle", "r", "anticlockwise"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Arc2.prototype.updatePath = function() {
      var _a = this.parsedStyle, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, startAngle = _a.startAngle, endAngle = _a.endAngle, r = _a.r, anticlockwise = _a.anticlockwise;
      if (is_nil_default(startAngle) || is_nil_default(endAngle) || startAngle === endAngle || is_nil_default(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad2(startAngle), deg2rad2(endAngle), r, anticlockwise);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    Arc2.prototype.createPath = function(x, y, startAngle, endAngle, r, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var angle3 = Math.abs(endAngle - startAngle);
      if (angle3 >= Math.PI * 2 || isNumberEqual(angle3, Math.PI * 2)) {
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        return [["M", start.x, start.y], ["A", r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ["A", r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ["Z"]];
      }
      var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
      return [["M", start.x, start.y], ["A", r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
    };
    return Arc2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/marker.js
var SYMBOLS = {
  circle: function circle(x, y, r) {
    return [["M", x - r, y], ["A", r, r, 0, 1, 0, x + r, y], ["A", r, r, 0, 1, 0, x - r, y]];
  },
  square: function square(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  arrow: function arrow(x, y, r) {
    return [["M", x - r, y + 2 * r / Math.sqrt(3)], ["L", x + r, y + 2 * r / Math.sqrt(3)], ["L", x, y - 2 * r / Math.sqrt(3)], ["Z"]];
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Marker2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["x", "y", "symbol", "radius"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Marker2.prototype.updatePath = function() {
      var _a = this.parsedStyle, _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c;
      var _d = this.attributes, radius = _d.radius, symbol = _d.symbol;
      if (!symbol)
        return;
      var method = SYMBOLS[symbol];
      if (!method)
        return;
      var path = method(x, y, radius);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    return Marker2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/sector.js
var PI = Math.PI;
var PI2 = PI * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathSqrt = Math.sqrt;
var mathMax = Math.max;
var mathMin = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d22 = dx * dx + dy * dy;
  var r = radius - cr;
  var s2 = x11 * y10 - x10 * y11;
  var d4 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d22 - s2 * s2));
  var cx0 = (s2 * dy - dx * d4) / d22;
  var cy0 = (-s2 * dx - dy * d4) / d22;
  var cx1 = (s2 * dy + dx * d4) / d22;
  var cy1 = (-s2 * dx + dy * d4) / d22;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function computeArcSweep2(startAngle, endAngle, clockwise) {
  if (clockwise === void 0) {
    clockwise = true;
  }
  if (!clockwise) {
    var replaceAngle = endAngle;
    endAngle = startAngle;
    startAngle = replaceAngle;
  }
  endAngle = endAngle - startAngle < 0 ? endAngle + PI2 : endAngle;
  return Math.abs(endAngle - startAngle) % PI2 <= PI ? 0 : 1;
}
var Sector = (
  /** @class */
  function(_super) {
    __extends(Sector2, _super);
    function Sector2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    Sector2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["startAngle", "endAngle", "r", "r0", "radius", "cx", "cy"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Sector2.prototype.updatePath = function() {
      var _a = this.parsedStyle, cx = _a.cx, cy = _a.cy, startAngle = _a.startAngle, endAngle = _a.endAngle, r = _a.r, r0 = _a.r0, radius = _a.radius, _b = _a.anticlockwise, anticlockwise = _b === void 0 ? false : _b;
      if (is_nil_default(startAngle) || is_nil_default(endAngle) || startAngle === endAngle || is_nil_default(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad2(startAngle), deg2rad2(endAngle), r, r0 ? r0 : 0, radius ? radius : [0, 0, 0, 0], anticlockwise);
      _super.prototype.setAttribute.call(this, "path", path);
    };
    Sector2.prototype.createPath = function(x, y, startAngle, endAngle, r, r0, borderRadius, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var innerStart = polarToCartesian(x, y, r0, startAngle);
      var innerEnd = polarToCartesian(x, y, r0, endAngle);
      var clockwise = !anticlockwise;
      var angle3 = clockwise ? endAngle - startAngle : startAngle - endAngle;
      if (Math.abs(angle3) >= PI2 || isNumberEqual(Math.abs(angle3), PI2)) {
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        var innerMiddlePoint = polarToCartesian(x, y, r0, startAngle + Math.PI);
        var circlePathCommands = [["M", start.x, start.y], ["A", r, r, 0, 1, clockwise ? 1 : 0, middlePoint.x, middlePoint.y], ["A", r, r, 0, 1, clockwise ? 1 : 0, end.x, end.y]];
        if (r0 > 0) {
          circlePathCommands.push(["M", innerStart.x, innerStart.y]);
          circlePathCommands.push(["A", r0, r0, 0, 1, clockwise ? 0 : 1, innerMiddlePoint.x, innerMiddlePoint.y]);
          circlePathCommands.push(["A", r0, r0, 0, 1, clockwise ? 0 : 1, innerEnd.x, innerEnd.y]);
        }
        circlePathCommands.push(["M", start.x, start.y]);
        circlePathCommands.push(["Z"]);
        return circlePathCommands;
      }
      var xrs = r * mathCos(startAngle);
      var yrs = r * mathSin(startAngle);
      var xire = r0 * mathCos(endAngle);
      var yire = r0 * mathSin(endAngle);
      var xre = r * mathCos(endAngle);
      var yre = r * mathSin(endAngle);
      var xirs = r0 * mathCos(startAngle);
      var yirs = r0 * mathSin(startAngle);
      var outStartRadius = borderRadius[0], outEndRadius = borderRadius[1], innerEndRadius = borderRadius[2], innerStartRadius = borderRadius[3];
      var halfRadius = (r - r0) / 2;
      var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
      var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
      var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
      var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
      var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
      var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
      var limitedOutBorderRadiusMax = outBorderRadiusMax;
      var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
      if (outBorderRadiusMax > e || innerBorderRadiusMax > e) {
        if (angle3 < PI) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r - b) / (a + 1));
            limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b) / (a - 1));
          }
        }
      }
      var arcSweep = computeArcSweep2(startAngle, endAngle, clockwise);
      var sectorPathCommands = [];
      if (limitedOutBorderRadiusMax > e) {
        var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
        var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, r, crEnd, clockwise);
        sectorPathCommands.push(["M", x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
          var outStartBorderRadiusStartAngle = mathATan2(ct0.cy + ct0.y0, ct0.cx + ct0.x0);
          var outStartBorderRadiusEndAngle = mathATan2(ct1.cy + ct1.y0, ct1.cx + ct1.x0);
          sectorPathCommands.push(["A", limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep2(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, !clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          if (crStart > 0) {
            var outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            var outStartBorderRadiusEndPoint = polarToCartesian(x, y, r, outStartBorderRadiusEndAngle);
            sectorPathCommands.push(["A", crStart, crStart, 0, computeArcSweep2(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
          }
          var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var outRadiusEndPoint = polarToCartesian(x, y, r, outRadiusEndAngle);
          sectorPathCommands.push(["A", r, r, 1, computeArcSweep2(outRadiusStartAngle, outRadiusEndAngle, clockwise), clockwise ? 1 : 0, outRadiusEndPoint.x, outRadiusEndPoint.y]);
          if (crEnd > 0) {
            var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(["A", crEnd, crEnd, 0, computeArcSweep2(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["M", start.x, start.y]);
        sectorPathCommands.push(["A", r, r, 0, arcSweep, clockwise ? 1 : 0, end.x, end.y]);
      }
      if (r0 < e) {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
      } else if (limitedInnerBorderRadiusMax > e) {
        var crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
        var crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
        var ct0 = computeCornerTangents(0, 0, xire, yire, r0, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xirs, yirs, 0, 0, r0, -crStart, clockwise);
        sectorPathCommands.push(["L", x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && crStart === crEnd) {
          var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var innerStartBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(["A", limitedInnerBorderRadiusMax, limitedInnerBorderRadiusMax, 0, computeArcSweep2(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          if (crEnd > 0) {
            var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var innerStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            sectorPathCommands.push(["A", crEnd, crEnd, 0, computeArcSweep2(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct0.cx + ct0.x1, y + ct0.cy + ct0.y1]);
          }
          var innerRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var innerRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var innerRadiusEndPoint = polarToCartesian(x, y, r0, innerRadiusEndAngle);
          sectorPathCommands.push(["A", r0, r0, 0, computeArcSweep2(innerRadiusEndAngle, innerRadiusStartAngle, clockwise), clockwise ? 0 : 1, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
          if (crStart > 0) {
            var innerEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var innerEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(["A", crStart, crStart, 0, computeArcSweep2(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
        sectorPathCommands.push(["A", r0, r0, 0, arcSweep, clockwise ? 0 : 1, innerStart.x, innerStart.y]);
      }
      sectorPathCommands.push(["Z"]);
      return sectorPathCommands;
    };
    return Sector2;
  }(Path)
);

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/util/smooth.js
function getPoint2(v) {
  return [v.x, v.y];
}
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min4;
  var max4;
  var point;
  var len5;
  var l;
  var i;
  if (hasConstraint) {
    min4 = [Infinity, Infinity];
    max4 = [-Infinity, -Infinity];
    for (i = 0, l = points.length; i < l; i++) {
      point = getPoint2(points[i]);
      vec2_exports.min(min4, min4, point);
      vec2_exports.max(max4, max4, point);
    }
    vec2_exports.min(min4, min4, constraint[0]);
    vec2_exports.max(max4, max4, constraint[1]);
  }
  for (i = 0, len5 = points.length; i < len5; i++) {
    point = getPoint2(points[i]);
    if (isLoop) {
      prevPoint = getPoint2(points[i ? i - 1 : len5 - 1]);
      nextPoint = getPoint2(points[(i + 1) % len5]);
    } else {
      if (i === 0 || i === len5 - 1) {
        cps.push([point[0], point[1]]);
        continue;
      } else {
        prevPoint = getPoint2(points[i - 1]);
        nextPoint = getPoint2(points[i + 1]);
      }
    }
    var v = vec2_exports.sub([], nextPoint, prevPoint);
    vec2_exports.scale(v, v, smooth);
    var d0 = vec2_exports.distance(point, prevPoint);
    var d1 = vec2_exports.distance(point, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    var v1 = vec2_exports.scale([], v, -d0);
    var v2 = vec2_exports.scale([], v, d1);
    var cp0 = vec2_exports.add([], point, v1);
    var cp1 = vec2_exports.add([], point, v2);
    if (hasConstraint) {
      vec2_exports.max(cp0, cp0, min4);
      vec2_exports.min(cp0, cp0, max4);
      vec2_exports.max(cp1, cp1, min4);
      vec2_exports.min(cp1, cp1, max4);
    }
    cps.push([cp0[0], cp0[1]]);
    cps.push([cp1[0], cp1[1]]);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2bezier(pointList, z, constraint) {
  var isLoop = !!z;
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len5 - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
  }
  return d1;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/shape/smoothPolyline.js
var SmoothPolyline = (
  /** @class */
  function(_super) {
    __extends(SmoothPolyline2, _super);
    function SmoothPolyline2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.updatePath();
      return _this2;
    }
    SmoothPolyline2.prototype.setAttribute = function(name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (["smooth", "points"].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    SmoothPolyline2.prototype.updatePath = function() {
      var _a = this.parsedStyle, smooth = _a.smooth, points = _a.points;
      var pos2 = points.points;
      var d4 = [["M", pos2[0][0], pos2[0][1]]];
      if (smooth) {
        var constaint = [[0, 0], [1, 1]];
        var sps = catmullRom2bezier(pos2.map(function(d5) {
          return {
            x: d5[0],
            y: d5[1]
          };
        }), false, constaint);
        for (var i = 0, n = sps.length; i < n; i++) {
          var sp = sps[i];
          d4.push(["C", sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);
        }
      } else {
        var i = void 0;
        var l = void 0;
        for (i = 1, l = pos2.length - 1; i < l; i++) {
          d4.push(["L", pos2[i][0], pos2[i][1]]);
        }
        d4.push(["L", pos2[l][0], pos2[l][1]]);
      }
      _super.prototype.setAttribute.call(this, "path", d4);
    };
    SmoothPolyline2.tag = "smooth-polyline";
    return SmoothPolyline2;
  }(Path)
);

// node_modules/.pnpm/@antv+g-gesture@0.0.68/node_modules/@antv/g-gesture/dist/index.esm.js
var import_eventemitter32 = __toESM(require_eventemitter3());
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var clock = typeof performance === "object" && performance.now ? performance : Date;
var PRESS_DELAY = 250;
var calcDirection = function calcDirection2(start, end) {
  var xDistance = end.x - start.x;
  var yDistance = end.y - start.y;
  if (Math.abs(xDistance) > Math.abs(yDistance)) {
    return xDistance > 0 ? "right" : "left";
  }
  return yDistance > 0 ? "down" : "up";
};
var calcDistance = function calcDistance2(point1, point2) {
  var xDistance = Math.abs(point2.x - point1.x);
  var yDistance = Math.abs(point2.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter = function getCenter2(point1, point2) {
  var x = point1.x + (point2.x - point1.x) / 2;
  var y = point1.y + (point2.y - point1.y) / 2;
  return {
    x,
    y
  };
};
var Gesture = function(_EE) {
  _inheritsLoose2(Gesture3, _EE);
  function Gesture3(el) {
    var _this2;
    _this2 = _EE.call(this) || this;
    _this2.el = void 0;
    _this2.evCache = [];
    _this2.startTime = void 0;
    _this2.pressTimeout = void 0;
    _this2.startPoints = [];
    _this2.processEvent = {};
    _this2.startDistance = void 0;
    _this2.center = void 0;
    _this2.eventType = void 0;
    _this2.direction = void 0;
    _this2.lastMoveTime = void 0;
    _this2.prevMovePoint = void 0;
    _this2.prevMoveTime = void 0;
    _this2.lastMovePoint = void 0;
    _this2.throttleTimer = 0;
    _this2.emitThrottles = [];
    _this2._start = function(ev) {
      _this2.reset();
      _this2.startTime = clock.now();
      var _assertThisInitialize = _assertThisInitialized2(_this2), evCache = _assertThisInitialize.evCache, startPoints = _assertThisInitialize.startPoints;
      if (ev) {
        var pointerId = ev.pointerId, x = ev.x, y = ev.y;
        evCache.push({
          pointerId,
          x,
          y,
          ev
        });
      }
      startPoints.length = evCache.length;
      for (var i = 0; i < evCache.length; i++) {
        var _evCache$i = evCache[i], _x = _evCache$i.x, _y = _evCache$i.y;
        var point = {
          x: _x,
          y: _y
        };
        startPoints[i] = point;
      }
      if (startPoints.length === 1) {
        var event = evCache[0].ev;
        _this2.pressTimeout = setTimeout(function() {
          var eventType = "press";
          var direction = "none";
          event.direction = direction;
          event.deltaX = 0;
          event.deltaY = 0;
          event.points = startPoints;
          _this2.emitStart(eventType, event);
          _this2._emit(eventType, event);
          _this2.eventType = eventType;
          _this2.direction = direction;
        }, PRESS_DELAY);
        return;
      }
      _this2.startDistance = calcDistance(startPoints[0], startPoints[1]);
      _this2.center = getCenter(startPoints[0], startPoints[1]);
    };
    _this2._move = function(ev) {
      _this2.clearPressTimeout();
      var _assertThisInitialize2 = _assertThisInitialized2(_this2), startPoints = _assertThisInitialize2.startPoints, evCache = _assertThisInitialize2.evCache;
      if (!startPoints.length)
        return;
      var x = ev.x, y = ev.y, pointerId = ev.pointerId;
      var isTriggerStart = false;
      for (var i = 0, len5 = evCache.length; i < len5; i++) {
        if (pointerId === evCache[i].pointerId) {
          evCache[i] = {
            pointerId,
            x,
            y,
            ev
          };
          isTriggerStart = true;
          break;
        }
      }
      if (!isTriggerStart) {
        var _point = {
          x,
          y
        };
        startPoints.push(_point);
        evCache.push({
          pointerId,
          x,
          y,
          ev
        });
        _this2.startDistance = calcDistance(startPoints[0], startPoints[1]);
        _this2.center = getCenter(startPoints[0], startPoints[1]);
      }
      var point = {
        x,
        y
      };
      var points = evCache.map(function(ev2) {
        return {
          x: ev2.x,
          y: ev2.y
        };
      });
      var now = clock.now();
      _this2.prevMoveTime = _this2.lastMoveTime;
      _this2.prevMovePoint = _this2.lastMovePoint;
      _this2.lastMoveTime = now;
      _this2.lastMovePoint = point;
      if (startPoints.length === 1) {
        var startPoint = startPoints[0];
        var deltaX = x - startPoint.x;
        var deltaY = y - startPoint.y;
        var direction = _this2.direction || calcDirection(startPoint, point);
        _this2.direction = direction;
        var eventType = _this2.getEventType(point);
        ev.direction = direction;
        ev.deltaX = deltaX;
        ev.deltaY = deltaY;
        ev.points = points;
        _this2.emitStart(eventType, ev);
        _this2._emit(eventType, ev);
        return;
      }
      var _assertThisInitialize3 = _assertThisInitialized2(_this2), startDistance = _assertThisInitialize3.startDistance;
      var currentDistance = calcDistance(points[0], points[1]);
      ev.zoom = currentDistance / startDistance;
      ev.center = _this2.center;
      ev.points = points;
      _this2.emitStart("pinch", ev);
      _this2._emit("pinch", ev);
    };
    _this2._end = function(ev) {
      var _assertThisInitialize4 = _assertThisInitialized2(_this2), evCache = _assertThisInitialize4.evCache, startPoints = _assertThisInitialize4.startPoints;
      var points = evCache.map(function(ev2) {
        return {
          x: ev2.x,
          y: ev2.y
        };
      });
      ev.points = points;
      _this2.emitEnd(ev);
      if (evCache.length === 1) {
        var now = clock.now();
        var lastMoveTime = _this2.lastMoveTime;
        if (now - lastMoveTime < 100) {
          var prevMoveTime = _this2.prevMoveTime || _this2.startTime;
          var intervalTime = lastMoveTime - prevMoveTime;
          if (intervalTime > 0) {
            var prevMovePoint = _this2.prevMovePoint || startPoints[0];
            var lastMovePoint = _this2.lastMovePoint || startPoints[0];
            var velocity = calcDistance(prevMovePoint, lastMovePoint) / intervalTime;
            if (velocity > 0.3) {
              ev.velocity = velocity;
              ev.direction = calcDirection(prevMovePoint, lastMovePoint);
              _this2._emit("swipe", ev);
            }
          }
        }
      }
      for (var i = 0, len5 = evCache.length; i < len5; i++) {
        if (evCache[i].pointerId === ev.pointerId) {
          evCache.splice(i, 1);
          startPoints.splice(i, 1);
          break;
        }
      }
      _this2.reset();
      if (evCache.length > 0) {
        _this2._start();
      }
    };
    _this2.el = el;
    _this2._initEvent();
    return _this2;
  }
  var _proto = Gesture3.prototype;
  _proto._initEvent = function _initEvent() {
    var el = this.el;
    el.addEventListener("pointerdown", this._start);
    el.addEventListener("pointermove", this._move);
    el.addEventListener("pointerup", this._end);
    el.addEventListener("pointerupoutside", this._end);
  };
  _proto.getEventType = function getEventType(point) {
    var eventType = this.eventType, startTime = this.startTime, startPoints = this.startPoints;
    if (eventType) {
      return eventType;
    }
    var type;
    var panEventListeners = this._events.pan;
    if (!panEventListeners) {
      type = "press";
    } else {
      var now = clock.now();
      if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], point) < 10) {
        type = "press";
      } else {
        type = "pan";
      }
    }
    this.eventType = type;
    return type;
  };
  _proto.enable = function enable(eventType) {
    this.processEvent[eventType] = true;
  };
  _proto.isProcess = function isProcess(eventType) {
    return this.processEvent[eventType];
  };
  _proto.emitStart = function emitStart(type, ev) {
    if (this.isProcess(type)) {
      return;
    }
    this.enable(type);
    this._emit(type + "start", ev);
  };
  _proto._emit = function _emit(type, ev) {
    var _el$ownerDocument, _el$document, _this2 = this;
    this.pushEvent(type, ev);
    var el = this.el, throttleTimer = this.throttleTimer, emitThrottles = this.emitThrottles;
    if (throttleTimer) {
      return;
    }
    var global2 = ((_el$ownerDocument = el.ownerDocument) === null || _el$ownerDocument === void 0 ? void 0 : _el$ownerDocument.defaultView) || ((_el$document = el.document) === null || _el$document === void 0 ? void 0 : _el$document.defaultView);
    this.throttleTimer = global2.requestAnimationFrame(function() {
      for (var i = 0, len5 = emitThrottles.length; i < len5; i++) {
        var _emitThrottles$i = emitThrottles[i], _type = _emitThrottles$i.type, _ev = _emitThrottles$i.ev;
        _this2.emit(_type, _ev);
      }
      _this2.throttleTimer = 0;
      _this2.emitThrottles.length = 0;
    });
  };
  _proto.emitEnd = function emitEnd(ev) {
    var _this3 = this;
    var processEvent = this.processEvent;
    Object.keys(processEvent).forEach(function(type) {
      _this3._emit(type + "end", ev);
      delete processEvent[type];
    });
  };
  _proto.pushEvent = function pushEvent(type, ev) {
    var emitThrottles = this.emitThrottles;
    var newEvent = {
      type,
      ev
    };
    for (var i = 0, len5 = emitThrottles.length; i < len5; i++) {
      if (emitThrottles[i].type === type) {
        emitThrottles.splice(i, 1, newEvent);
        return;
      }
    }
    emitThrottles.push(newEvent);
  };
  _proto.clearPressTimeout = function clearPressTimeout() {
    if (this.pressTimeout) {
      clearTimeout(this.pressTimeout);
      this.pressTimeout = null;
    }
  };
  _proto.reset = function reset() {
    this.clearPressTimeout();
    this.startTime = 0;
    this.startDistance = 0;
    this.direction = null;
    this.eventType = null;
    this.prevMoveTime = 0;
    this.prevMovePoint = null;
    this.lastMoveTime = 0;
    this.lastMovePoint = null;
  };
  return Gesture3;
}(import_eventemitter32.default);
var index_esm_default = Gesture;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/gesture.js
var G_SHAPE_EVENT = {
  click: true,
  touchstart: true,
  touchmove: true,
  touchend: true,
  touchendoutside: true,
  dragenter: true,
  dragleave: true,
  dragover: true,
  drop: true,
  dragstart: true,
  drag: true,
  dragend: true
};
var GESTURE_EVENT = {
  panstart: true,
  pan: true,
  panend: true,
  pressstart: true,
  press: true,
  pressend: true,
  swipe: true,
  pinchstart: true,
  pinch: true,
  pinchend: true
};
var Gesture2 = (
  /** @class */
  function() {
    function Gesture3(element) {
      this.el = element;
      this.gesture = new index_esm_default(element);
    }
    Gesture3.prototype.on = function(eventName, listener) {
      var _a = this, el = _a.el, gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.addEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.on(eventName, listener);
      }
    };
    Gesture3.prototype.off = function(eventName, listener) {
      var _a = this, el = _a.el, gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.removeEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.off(eventName, listener);
      }
    };
    return Gesture3;
  }()
);
var gesture_default = Gesture2;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/jsx/tag.js
var SHAPE_TAG = {};
var registerTag = function registerTag2(name, ShapeConstructor) {
  SHAPE_TAG[name] = ShapeConstructor;
};
var getTag = function getTag2(type) {
  return SHAPE_TAG[type];
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/createShape.js
var EVENT_LIST = [
  ["click", "onClick"],
  ["touchstart", "onTouchStart"],
  ["touchmove", "onTouchMove"],
  ["touchend", "onTouchEnd"],
  ["touchendoutside", "onTouchEndOutside"],
  // drage 相关
  ["dragenter", "onDragEnter"],
  ["dragleave", "onDragLeave"],
  ["dragover", "onDragOver"],
  ["drop", "onDrop"],
  ["dragstart", "onDragStart"],
  ["drag", "onDrag"],
  ["dragend", "onDragEnd"],
  // pan
  ["panstart", "onPanStart"],
  ["pan", "onPan"],
  ["panend", "onPanEnd"],
  // press
  ["pressstart", "onPressStart"],
  ["press", "onPress"],
  ["pressend", "onPressEnd"],
  // swipe
  ["swipe", "onSwipe"],
  // pinch
  ["pinchstart", "onPinchStart"],
  ["pinch", "onPinch"],
  ["pinchend", "onPinchEnd"]
];
var TagElements = [["group", Rect], ["text", Text], ["circle", Circle], ["path", Path], ["ellipse", Ellipse], ["rect", Rect], ["image", Image], ["line", Line], ["polyline", SmoothPolyline], ["polygon", Polygon], ["arc", Arc], ["marker", Marker], ["sector", Sector]];
TagElements.map(function(_a) {
  var type = _a[0], ShapeClass = _a[1];
  registerTag(type, ShapeClass);
});
var SECTOR_CSS_PROPERTY = [{
  name: "r0",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE
}, {
  name: "startAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}, {
  name: "endAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}];
SECTOR_CSS_PROPERTY.forEach(function(property) {
  CSS.registerProperty(property);
});
function createShape(type, props) {
  if (!type)
    return null;
  var ShapeClass = getTag(type);
  if (!ShapeClass)
    return null;
  var shape = new ShapeClass(props);
  addEvent(shape, props);
  return shape;
}
function addEvent(shape, props) {
  var gesture = new gesture_default(shape);
  EVENT_LIST.forEach(function(_a) {
    var eventName = _a[0], handlerName = _a[1];
    if (!props[handlerName])
      return;
    gesture.on(eventName, props[handlerName]);
  });
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/equal.js
function objToString(obj) {
  return Object.prototype.toString.call(obj);
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function equal(a, b) {
  if (a === b)
    return true;
  if (_typeof(a) !== _typeof(b)) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true;
  }
  if (objToString(a) !== objToString(b)) {
    return false;
  }
  if (is_function_default(a)) {
    return true;
  }
  if (_typeof(a) !== "object") {
    return false;
  }
  if (is_array_default(a)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = a.length - 1; i >= 0; i--) {
      if (!equal(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (!is_plain_object_default(a)) {
    return false;
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (var i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    }
  }
  for (var i = ka.length - 1; i >= 0; i--) {
    var key = ka[i];
    if (!equal(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
var equal_default = equal;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/workTags.js
var FunctionComponent = 0;
var ClassComponent = 1;
var Shape2 = 2;
function getWorkTag(type) {
  if (is_string_default(type)) {
    return Shape2;
  }
  if (type.prototype && type.prototype.isF2Component) {
    return ClassComponent;
  }
  return FunctionComponent;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/findClosestShapeNode.js
function findClosestShapeNode(vNode) {
  var tag = vNode.tag, children = vNode.children;
  if (tag === Shape2) {
    return vNode;
  }
  var shapeNode;
  children_default.map(children, function(child) {
    if (shapeNode)
      return;
    shapeNode = findClosestShapeNode(child);
  });
  return shapeNode;
}
var findClosestShapeNode_default = findClosestShapeNode;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animator.js
var import_eventemitter33 = __toESM(require_eventemitter3());

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/applyStyle.js
function applyStyle(shape, style) {
  if (!style)
    return;
  Object.keys(style).forEach(function(key) {
    if (key === "clip" || key === "offset") {
      var effect = style[key];
      if (isDisplayObject(effect === null || effect === void 0 ? void 0 : effect.current)) {
        shape.setAttribute("".concat(key, "Path"), effect.current);
        return;
      }
      var effectConfig = is_function_default(effect) ? effect(style) : effect;
      if (effectConfig) {
        var type = effectConfig.type, style_1 = effectConfig.style;
        var effectShape = createShape(type, {
          style: style_1
        });
        shape.setAttribute("".concat(key, "Path"), effectShape);
      }
    } else {
      shape.setAttribute(key, style[key]);
    }
  });
}
var applyStyle_default = applyStyle;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animator.js
var Animator = (
  /** @class */
  function(_super) {
    __extends(Animator2, _super);
    function Animator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Animator2.prototype.animate = function(shape, start, end, effect) {
      this.shape = shape;
      this.start = start;
      this.end = end;
      this.effect = effect;
    };
    Animator2.prototype.loadPlay = function() {
      var _a = this, shape = _a.shape, start = _a.start, end = _a.end, effect = _a.effect, children = _a.children;
      var animations = [];
      if (effect) {
        var _b = effect.property, property = _b === void 0 ? [] : _b, easing = effect.easing, duration = effect.duration, delay = effect.delay, iterations = effect.iterations, clip = effect.clip, _c = effect.onFrame, onFrame = _c === void 0 ? function() {
        } : _c, _d = effect.onEnd, onEnd = _d === void 0 ? function() {
        } : _d;
        if (property.length && duration > 0) {
          var style = __assign(__assign({}, omit_default(end, property)), omit_default(start, property));
          applyStyle_default(shape, style);
          var keyframeStart = property.reduce(function(prev, cur) {
            prev[cur] = start[cur];
            return prev;
          }, {});
          var keyframeEnd = pick_default(end, property);
          var animation = shape.animate([keyframeStart, keyframeEnd], {
            fill: "both",
            easing,
            duration,
            delay,
            iterations
          });
          if (animation) {
            animation.onframe = onFrame;
            animation.onfinish = onEnd;
            if (iterations !== Infinity) {
              animations.push(animation);
            }
            this.animation = animation;
          } else {
            applyStyle_default(shape, end);
          }
        } else {
          applyStyle_default(shape, end);
        }
        if (clip) {
          var clipConfig = is_function_default(clip) ? clip(end) : clip;
          if (clipConfig) {
            var clipType = clipConfig.type, clipStyle = clipConfig.style, _e = clipConfig.property, clipProperty = _e === void 0 ? [] : _e, clipEasing = clipConfig.easing, clipDuration = clipConfig.duration, clipDelay = clipConfig.delay, clipIterations = clipConfig.iterations, clipStart = clipConfig.start, clipEnd = clipConfig.end;
            if (clipProperty.length && (clipDuration || duration) > 0) {
              var clipStartStyle_1 = __assign(__assign({}, clipStyle), clipStart);
              var clipEndStyle = __assign(__assign({}, clipStyle), clipEnd);
              var clipKeyframeStart = clipProperty.reduce(function(prev, cur) {
                prev[cur] = clipStartStyle_1[cur];
                return prev;
              }, {});
              var clipKeyframeEnd = pick_default(clipEndStyle, clipProperty);
              var clipShape_1 = createShape(clipType, {
                style: clipStartStyle_1
              });
              shape.setAttribute("clipPath", clipShape_1);
              shape.ownerDocument.documentElement.appendChild(clipShape_1);
              var clipAnimation = clipShape_1.animate([clipKeyframeStart, clipKeyframeEnd], {
                fill: "both",
                easing: clipEasing || easing,
                duration: clipDuration || duration,
                delay: clipDelay || delay,
                iterations: clipIterations || iterations
              });
              if (clipAnimation) {
                var clipFinished = clipAnimation.finished;
                this.animation = clipAnimation;
                clipFinished.then(function() {
                  shape.setAttribute("clipPath", null);
                  clipShape_1.destroy();
                });
                if ((clipIterations || iterations) !== Infinity) {
                  animations.push(clipAnimation);
                }
              } else {
                shape.setAttribute("clipPath", null);
                clipShape_1.destroy();
              }
            }
          }
        }
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          var childAnimator = child.loadPlay();
          if (childAnimator) {
            animations.push.apply(animations, childAnimator);
          }
        });
      }
      this.endEmit(animations);
      return animations;
    };
    Animator2.prototype.pause = function() {
      var _a = this, children = _a.children, animation = _a.animation;
      if (animation) {
        animation.pause();
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          child.pause();
        });
      }
    };
    Animator2.prototype.endEmit = function(animations) {
      var _this2 = this;
      if (!animations.length) {
        this.emit("end");
        return null;
      }
      var finished = Promise.all(animations.map(function(d4) {
        return d4.finished;
      }));
      finished.then(function() {
        _this2.emit("end");
      });
    };
    Animator2.prototype.play = function() {
      var _a = this, children = _a.children, animation = _a.animation;
      if (animation) {
        animation.play();
      }
      if (children && children.length) {
        children.forEach(function(child) {
          if (!child)
            return;
          child.play();
        });
      }
    };
    Animator2.prototype.reset = function(shape) {
      this.shape = shape;
      this.start = null;
      this.end = null;
      this.effect = null;
      this.children = null;
    };
    return Animator2;
  }(import_eventemitter33.default)
);
var animator_default = Animator;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/animation.js
function findAllShapeNode(vNode) {
  var shapeNodes = [];
  children_default.map(vNode, function(node) {
    if (!node)
      return;
    var tag = node.tag, type = node.type, children = node.children;
    if (tag === Shape2 && type !== "group") {
      shapeNodes.push(node);
    }
    if (children) {
      shapeNodes.push.apply(shapeNodes, findAllShapeNode(children));
    }
  });
  return shapeNodes;
}
function morphShape(lastNode, nextNode, animator) {
  var nextProps = nextNode.props, nextShape = nextNode.shape, nextStyle = nextNode.style;
  var lastShape = lastNode.shape, lastStyle = lastNode.style;
  lastShape.destroy();
  var animate = nextProps.animate, animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  if (animate === false || !animationEffect) {
    return animator;
  }
  animator = animator || new animator_default();
  var start = animationEffect.start, end = animationEffect.end, _a = animationEffect.property, property = _a === void 0 ? [] : _a;
  var nextParsedStyle = nextShape.parsedStyle;
  var lastParsedStyle = lastShape.parsedStyle;
  var lastPath = convertToPath(lastShape);
  var nextPath = convertToPath(nextShape);
  var startStyle = __assign(__assign(__assign({}, lastStyle), start), {
    path: lastPath
  });
  var endStyle = __assign(__assign(__assign({}, nextStyle), end), {
    path: nextPath
  });
  var pathShape = createShape("path", {
    style: __assign(__assign({}, startStyle), {
      path: ""
    })
  });
  var animateProperty = property.filter(function(key) {
    return nextParsedStyle.hasOwnProperty(key) && lastParsedStyle.hasOwnProperty(key);
  }).concat("path");
  animator.animate(pathShape, startStyle, endStyle, __assign(__assign({}, animationEffect), {
    property: animateProperty
  }));
  animator.once("end", function() {
    applyStyle_default(nextShape, endStyle);
    pathShape.replaceWith(nextShape);
  });
  return animator;
}
function appearAnimation(vNode) {
  return children_default.map(vNode, function(node) {
    if (!node)
      return;
    var tag = node.tag, shape = node.shape, style = node.style, children = node.children, animate = node.animate, props = node.props, animator = node.animator;
    animator.reset(shape);
    animator.children = children ? createAnimation(node, children, null) : null;
    if (animate === false || tag !== Shape2) {
      applyStyle_default(shape, style);
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.appear : null;
    if (!animationEffect) {
      applyStyle_default(shape, style);
      return animator;
    }
    var _a = animationEffect.start, start = _a === void 0 ? {} : _a, end = animationEffect.end;
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(shape, start, endStyle, animationEffect);
    return animator;
  });
}
function updateAnimation(nextNode, lastNode) {
  var nextTag = nextNode.tag, nextType = nextNode.type, nextStyle = nextNode.style, nextChildren = nextNode.children, nextProps = nextNode.props, nextShape = nextNode.shape, animator = nextNode.animator, animate = nextNode.animate;
  var lastTag = lastNode.tag, lastType = lastNode.type, lastStyle = lastNode.style, lastChildren = lastNode.children, lastShape = lastNode.shape;
  animator.reset(nextShape);
  animator.children = createAnimation(nextNode, nextChildren, lastChildren);
  var animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  if (nextType === lastType) {
    var resetStyle = lastStyle ? Object.keys(lastStyle).reduce(function(prev, cur) {
      prev[cur] = "";
      return prev;
    }, {}) : null;
    var style = __assign(__assign({}, resetStyle), nextStyle);
    if (nextTag !== Shape2) {
      applyStyle_default(nextShape, style);
      return animator;
    }
    if (animate === false || !animationEffect) {
      applyStyle_default(nextShape, style);
      return animator;
    }
    var start = animationEffect.start, end = animationEffect.end;
    var startStyle = __assign(__assign({}, lastStyle), start);
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(nextShape, startStyle, endStyle, animationEffect);
    return animator;
  }
  if (nextTag !== Shape2 || lastTag !== Shape2) {
    lastShape.destroy();
    return animator;
  }
  if (nextType === "group") {
    var shapeNodes = findAllShapeNode(nextNode.children);
    return shapeNodes.map(function(node) {
      return morphShape(lastNode, node);
    });
  }
  if (lastType === "group") {
    var shapeNodes = findAllShapeNode(lastNode.children);
    return shapeNodes.map(function(node) {
      return morphShape(node, nextNode);
    });
  }
  if (animate === false || !animationEffect) {
    applyStyle_default(nextShape, nextStyle);
    return animator;
  }
  return morphShape(lastNode, nextNode, animator);
}
function destroyAnimation(node) {
  return children_default.map(node, function(vNode) {
    if (!vNode)
      return null;
    var tag = vNode.tag, shape = vNode.shape, children = vNode.children, animate = vNode.animate, style = vNode.style, props = vNode.props, animator = vNode.animator;
    if (shape.destroyed) {
      return null;
    }
    animator.reset(shape);
    var childrenAnimation = children ? children_default.toArray(children).map(function(child) {
      return destroyAnimation(child);
    }).filter(Boolean) : null;
    if (animate === false) {
      shape.destroy();
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.leave : null;
    if (!(childrenAnimation && childrenAnimation.length) && !animationEffect) {
      shape.destroy();
      return animator;
    }
    animator.children = childrenAnimation;
    if (animationEffect && tag === Shape2) {
      var start = animationEffect.start, _a = animationEffect.end, end = _a === void 0 ? {} : _a;
      var startStyle = __assign(__assign({}, style), start);
      var endStyle = end;
      animator.animate(shape, startStyle, endStyle, animationEffect);
    }
    animator.once("end", function() {
      shape.destroy();
    });
    return animator;
  });
}
function createAnimator(nextNode, lastNode) {
  if (!nextNode && !lastNode) {
    return null;
  }
  if (!nextNode && lastNode) {
    return destroyAnimation(lastNode);
  }
  var transform = nextNode.transform;
  if (transform) {
    var closestShapeNode = findClosestShapeNode_default(nextNode);
    nextNode.transform = null;
    closestShapeNode.transform = transform;
  }
  if (nextNode.transform) {
    if (!lastNode) {
      return updateAnimation(nextNode, nextNode.transform);
    }
    return [updateAnimation(nextNode, nextNode.transform), destroyAnimation(lastNode)];
  }
  if (nextNode && !lastNode) {
    return appearAnimation(nextNode);
  }
  return updateAnimation(nextNode, lastNode);
}
function insertShape(parent, shape, nextSibling) {
  if (nextSibling) {
    parent.insertBefore(shape, nextSibling);
  } else {
    parent.appendChild(shape);
  }
}
function createAnimation(parent, nextChildren, lastChildren) {
  if (!nextChildren && !lastChildren) {
    return;
  }
  var parentShape = parent.shape;
  var prevSibling;
  var childrenAnimator = [];
  children_default.compare(nextChildren, lastChildren, function(nextNode, lastNode) {
    var animator = createAnimator(nextNode, lastNode);
    children_default.map(animator, function(item) {
      if (!item)
        return;
      childrenAnimator.push(item);
      var shape = item.shape;
      if (!shape || shape.destroyed)
        return;
      var nextSibling;
      if (!prevSibling) {
        nextSibling = parentShape.firstChild;
      } else {
        nextSibling = prevSibling.nextSibling;
      }
      if (nextSibling !== shape) {
        insertShape(parentShape, shape, nextSibling);
      }
      prevSibling = shape;
    });
  });
  return childrenAnimator;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/rect.js
var rect_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width, height = layout.height;
  return {
    x: left,
    y: top,
    width,
    height
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/line.js
var line_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width, height = layout.height;
  return {
    x1: left,
    y1: top,
    x2: left + width,
    y2: top + height
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/text.js
var text_default = function(layout) {
  var height = layout.height, left = layout.left, top = layout.top;
  return {
    x: left,
    y: top + height / 2,
    // 通过middle + top 才能比较好的实现文本对齐
    textBaseline: "middle"
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/circle.js
var circle_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width;
  var r = width / 2;
  return {
    cx: left + r,
    cy: top + r,
    r
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/marker.js
var marker_default = function(layout) {
  var left = layout.left, top = layout.top, width = layout.width;
  var r = width / 2;
  return {
    x: left + r,
    y: top,
    radius: r
  };
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/shape/index.js
var map2 = {
  rect: rect_default,
  line: line_default,
  text: text_default,
  circle: circle_default,
  marker: marker_default,
  group: rect_default
};
var shape_default = function(type, layout) {
  if (!layout)
    return null;
  var fn = map2[type] || rect_default;
  return fn(layout);
};

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/css-layout.js
var CSS_UNDEFINED;
var CSS_DIRECTION_INHERIT = "inherit";
var CSS_DIRECTION_LTR = "ltr";
var CSS_DIRECTION_RTL = "rtl";
var CSS_FLEX_DIRECTION_ROW = "row";
var CSS_FLEX_DIRECTION_ROW_REVERSE = "row-reverse";
var CSS_FLEX_DIRECTION_COLUMN = "column";
var CSS_FLEX_DIRECTION_COLUMN_REVERSE = "column-reverse";
var CSS_JUSTIFY_FLEX_START = "flex-start";
var CSS_JUSTIFY_CENTER = "center";
var CSS_JUSTIFY_FLEX_END = "flex-end";
var CSS_JUSTIFY_SPACE_BETWEEN = "space-between";
var CSS_JUSTIFY_SPACE_AROUND = "space-around";
var CSS_ALIGN_FLEX_START = "flex-start";
var CSS_ALIGN_CENTER = "center";
var CSS_ALIGN_FLEX_END = "flex-end";
var CSS_ALIGN_STRETCH = "stretch";
var CSS_POSITION_RELATIVE = "relative";
var CSS_POSITION_ABSOLUTE = "absolute";
var leading = {
  row: "left",
  "row-reverse": "right",
  column: "top",
  "column-reverse": "bottom"
};
var trailing = {
  row: "right",
  "row-reverse": "left",
  column: "bottom",
  "column-reverse": "top"
};
var pos = {
  row: "left",
  "row-reverse": "right",
  column: "top",
  "column-reverse": "bottom"
};
var dim = {
  row: "width",
  "row-reverse": "width",
  column: "height",
  "column-reverse": "height"
};
function fillNodes(node) {
  if (!node.layout || node.isDirty) {
    node.layout = {
      width: void 0,
      height: void 0,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  if (!node.style) {
    node.style = {};
  }
  if (!node.children) {
    node.children = [];
  }
  node.children.forEach(fillNodes);
  return node;
}
function isUndefined2(value) {
  return value === void 0;
}
function isRowDirection(flexDirection) {
  return flexDirection === CSS_FLEX_DIRECTION_ROW || flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;
}
function isColumnDirection(flexDirection) {
  return flexDirection === CSS_FLEX_DIRECTION_COLUMN || flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;
}
function getLeadingMargin(node, axis) {
  if (node.style.marginStart !== void 0 && isRowDirection(axis)) {
    return node.style.marginStart;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.marginLeft;
      break;
    case "row-reverse":
      value = node.style.marginRight;
      break;
    case "column":
      value = node.style.marginTop;
      break;
    case "column-reverse":
      value = node.style.marginBottom;
      break;
  }
  if (value !== void 0) {
    return value;
  }
  if (node.style.margin !== void 0) {
    return node.style.margin;
  }
  return 0;
}
function getTrailingMargin(node, axis) {
  if (node.style.marginEnd !== void 0 && isRowDirection(axis)) {
    return node.style.marginEnd;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.marginRight;
      break;
    case "row-reverse":
      value = node.style.marginLeft;
      break;
    case "column":
      value = node.style.marginBottom;
      break;
    case "column-reverse":
      value = node.style.marginTop;
      break;
  }
  if (value != null) {
    return value;
  }
  if (node.style.margin !== void 0) {
    return node.style.margin;
  }
  return 0;
}
function getLeadingPadding(node, axis) {
  if (node.style.paddingStart !== void 0 && node.style.paddingStart >= 0 && isRowDirection(axis)) {
    return node.style.paddingStart;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.paddingLeft;
      break;
    case "row-reverse":
      value = node.style.paddingRight;
      break;
    case "column":
      value = node.style.paddingTop;
      break;
    case "column-reverse":
      value = node.style.paddingBottom;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.padding !== void 0 && node.style.padding >= 0) {
    return node.style.padding;
  }
  return 0;
}
function getTrailingPadding(node, axis) {
  if (node.style.paddingEnd !== void 0 && node.style.paddingEnd >= 0 && isRowDirection(axis)) {
    return node.style.paddingEnd;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.paddingRight;
      break;
    case "row-reverse":
      value = node.style.paddingLeft;
      break;
    case "column":
      value = node.style.paddingBottom;
      break;
    case "column-reverse":
      value = node.style.paddingTop;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.padding !== void 0 && node.style.padding >= 0) {
    return node.style.padding;
  }
  return 0;
}
function getLeadingBorder(node, axis) {
  if (node.style.borderStartWidth !== void 0 && node.style.borderStartWidth >= 0 && isRowDirection(axis)) {
    return node.style.borderStartWidth;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.borderLeftWidth;
      break;
    case "row-reverse":
      value = node.style.borderRightWidth;
      break;
    case "column":
      value = node.style.borderTopWidth;
      break;
    case "column-reverse":
      value = node.style.borderBottomWidth;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.borderWidth !== void 0 && node.style.borderWidth >= 0) {
    return node.style.borderWidth;
  }
  return 0;
}
function getTrailingBorder(node, axis) {
  if (node.style.borderEndWidth !== void 0 && node.style.borderEndWidth >= 0 && isRowDirection(axis)) {
    return node.style.borderEndWidth;
  }
  var value = null;
  switch (axis) {
    case "row":
      value = node.style.borderRightWidth;
      break;
    case "row-reverse":
      value = node.style.borderLeftWidth;
      break;
    case "column":
      value = node.style.borderBottomWidth;
      break;
    case "column-reverse":
      value = node.style.borderTopWidth;
      break;
  }
  if (value != null && value >= 0) {
    return value;
  }
  if (node.style.borderWidth !== void 0 && node.style.borderWidth >= 0) {
    return node.style.borderWidth;
  }
  return 0;
}
function getLeadingPaddingAndBorder(node, axis) {
  return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);
}
function getTrailingPaddingAndBorder(node, axis) {
  return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);
}
function getBorderAxis(node, axis) {
  return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);
}
function getMarginAxis(node, axis) {
  return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);
}
function getPaddingAndBorderAxis(node, axis) {
  return getLeadingPaddingAndBorder(node, axis) + getTrailingPaddingAndBorder(node, axis);
}
function getJustifyContent(node) {
  if (node.style.justifyContent) {
    return node.style.justifyContent;
  }
  return "flex-start";
}
function getAlignContent(node) {
  if (node.style.alignContent) {
    return node.style.alignContent;
  }
  return "flex-start";
}
function getAlignItem(node, child) {
  if (child.style.alignSelf) {
    return child.style.alignSelf;
  }
  if (node.style.alignItems) {
    return node.style.alignItems;
  }
  return "stretch";
}
function resolveAxis(axis, direction) {
  if (direction === CSS_DIRECTION_RTL) {
    if (axis === CSS_FLEX_DIRECTION_ROW) {
      return CSS_FLEX_DIRECTION_ROW_REVERSE;
    } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {
      return CSS_FLEX_DIRECTION_ROW;
    }
  }
  return axis;
}
function resolveDirection(node, parentDirection) {
  var direction;
  if (node.style.direction) {
    direction = node.style.direction;
  } else {
    direction = CSS_DIRECTION_INHERIT;
  }
  if (direction === CSS_DIRECTION_INHERIT) {
    direction = parentDirection === void 0 ? CSS_DIRECTION_LTR : parentDirection;
  }
  return direction;
}
function getFlexDirection(node) {
  if (node.style.flexDirection) {
    return node.style.flexDirection;
  }
  return CSS_FLEX_DIRECTION_COLUMN;
}
function getCrossFlexDirection(flexDirection, direction) {
  if (isColumnDirection(flexDirection)) {
    return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
  } else {
    return CSS_FLEX_DIRECTION_COLUMN;
  }
}
function getPositionType(node) {
  if (node.style.position) {
    return node.style.position;
  }
  return "relative";
}
function isFlex(node) {
  return getPositionType(node) === CSS_POSITION_RELATIVE && node.style.flex > 0;
}
function isFlexWrap(node) {
  return node.style.flexWrap === "wrap";
}
function getDimWithMargin(node, axis) {
  return node.layout[dim[axis]] + getMarginAxis(node, axis);
}
function isDimDefined(node, axis) {
  return node.style[dim[axis]] !== void 0 && node.style[dim[axis]] >= 0;
}
function isPosDefined(node, pos2) {
  return node.style[pos2] !== void 0;
}
function isMeasureDefined(node) {
  return node.style.measure !== void 0;
}
function getPosition(node, pos2) {
  if (node.style[pos2] !== void 0) {
    return node.style[pos2];
  }
  return 0;
}
function boundAxis(node, axis, value) {
  var min4 = {
    row: node.style.minWidth,
    "row-reverse": node.style.minWidth,
    column: node.style.minHeight,
    "column-reverse": node.style.minHeight
  }[axis];
  var max4 = {
    row: node.style.maxWidth,
    "row-reverse": node.style.maxWidth,
    column: node.style.maxHeight,
    "column-reverse": node.style.maxHeight
  }[axis];
  var boundValue = value;
  if (max4 !== void 0 && max4 >= 0 && boundValue > max4) {
    boundValue = max4;
  }
  if (min4 !== void 0 && min4 >= 0 && boundValue < min4) {
    boundValue = min4;
  }
  return boundValue;
}
function fmaxf(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}
function setDimensionFromStyle(node, axis) {
  if (node.layout[dim[axis]] !== void 0) {
    return;
  }
  if (!isDimDefined(node, axis)) {
    return;
  }
  node.layout[dim[axis]] = fmaxf(boundAxis(node, axis, node.style[dim[axis]]), getPaddingAndBorderAxis(node, axis));
}
function setTrailingPosition(node, child, axis) {
  child.layout[trailing[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - child.layout[pos[axis]];
}
function getRelativePosition(node, axis) {
  if (node.style[leading[axis]] !== void 0) {
    return getPosition(node, leading[axis]);
  }
  return -getPosition(node, trailing[axis]);
}
function layoutNodeImpl(node, parentMaxWidth, parentDirection) {
  var direction = resolveDirection(node, parentDirection);
  var mainAxis = resolveAxis(getFlexDirection(node), direction);
  var crossAxis = getCrossFlexDirection(mainAxis, direction);
  var resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
  setDimensionFromStyle(node, mainAxis);
  setDimensionFromStyle(node, crossAxis);
  node.layout.direction = direction;
  node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
  node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
  node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
  node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
  var childCount = node.children.length;
  var paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);
  if (isMeasureDefined(node)) {
    var isResolvedRowDimDefined = !isUndefined2(node.layout[dim[resolvedRowAxis]]);
    var width = CSS_UNDEFINED;
    if (isDimDefined(node, resolvedRowAxis)) {
      width = node.style.width;
    } else if (isResolvedRowDimDefined) {
      width = node.layout[dim[resolvedRowAxis]];
    } else {
      width = parentMaxWidth - getMarginAxis(node, resolvedRowAxis);
    }
    width -= paddingAndBorderAxisResolvedRow;
    var isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;
    var isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined2(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);
    if (isRowUndefined || isColumnUndefined) {
      var measureDim = node.style.measure(
        /*(c)!node->context,*/
        /*(java)!layoutContext.measureOutput,*/
        width
      );
      if (isRowUndefined) {
        node.layout.width = measureDim.width + paddingAndBorderAxisResolvedRow;
      }
      if (isColumnUndefined) {
        node.layout.height = measureDim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);
      }
    }
    if (childCount === 0) {
      return;
    }
  }
  var isNodeFlexWrap = isFlexWrap(node);
  var justifyContent = getJustifyContent(node);
  var leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);
  var leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);
  var paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);
  var paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);
  var isMainDimDefined = !isUndefined2(node.layout[dim[mainAxis]]);
  var isCrossDimDefined = !isUndefined2(node.layout[dim[crossAxis]]);
  var isMainRowDirection = isRowDirection(mainAxis);
  var i;
  var ii;
  var child;
  var axis;
  var firstAbsoluteChild = null;
  var currentAbsoluteChild = null;
  var definedMainDim = CSS_UNDEFINED;
  if (isMainDimDefined) {
    definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;
  }
  var startLine = 0;
  var endLine = 0;
  var alreadyComputedNextLayout = 0;
  var linesCrossDim = 0;
  var linesMainDim = 0;
  var linesCount = 0;
  while (endLine < childCount) {
    var mainContentDim = 0;
    var flexibleChildrenCount = 0;
    var totalFlexible = 0;
    var nonFlexibleChildrenCount = 0;
    var isSimpleStackMain = isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START || !isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER;
    var firstComplexMain = isSimpleStackMain ? childCount : startLine;
    var isSimpleStackCross = true;
    var firstComplexCross = childCount;
    var firstFlexChild = null;
    var currentFlexChild = null;
    var mainDim = leadingPaddingAndBorderMain;
    var crossDim = 0;
    var maxWidth;
    for (i = startLine; i < childCount; ++i) {
      child = node.children[i];
      child.lineIndex = linesCount;
      child.nextAbsoluteChild = null;
      child.nextFlexChild = null;
      var alignItem = getAlignItem(node, child);
      if (alignItem === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && isCrossDimDefined && !isDimDefined(child, crossAxis)) {
        child.layout[dim[crossAxis]] = fmaxf(
          boundAxis(child, crossAxis, node.layout[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(child, crossAxis)
        );
      } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {
        if (firstAbsoluteChild === null) {
          firstAbsoluteChild = child;
        }
        if (currentAbsoluteChild !== null) {
          currentAbsoluteChild.nextAbsoluteChild = child;
        }
        currentAbsoluteChild = child;
        for (ii = 0; ii < 2; ii++) {
          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
          if (!isUndefined2(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {
            child.layout[dim[axis]] = fmaxf(
              boundAxis(child, axis, node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])),
              // You never want to go smaller than padding
              getPaddingAndBorderAxis(child, axis)
            );
          }
        }
      }
      var nextContentDim = 0;
      if (isMainDimDefined && isFlex(child)) {
        flexibleChildrenCount++;
        totalFlexible += child.style.flex;
        if (firstFlexChild === null) {
          firstFlexChild = child;
        }
        if (currentFlexChild !== null) {
          currentFlexChild.nextFlexChild = child;
        }
        currentFlexChild = child;
        nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);
      } else {
        maxWidth = CSS_UNDEFINED;
        if (!isMainRowDirection) {
          if (isDimDefined(node, resolvedRowAxis)) {
            maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
          } else {
            maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
          }
        }
        if (alreadyComputedNextLayout === 0) {
          layoutNode(
            /*(java)!layoutContext, */
            child,
            maxWidth,
            direction
          );
        }
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          nonFlexibleChildrenCount++;
          nextContentDim = getDimWithMargin(child, mainAxis);
        }
      }
      if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim && // If there's only one element, then it's bigger than the content
      // and needs its own line
      i !== startLine) {
        nonFlexibleChildrenCount--;
        alreadyComputedNextLayout = 1;
        break;
      }
      if (isSimpleStackMain && (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {
        isSimpleStackMain = false;
        firstComplexMain = i;
      }
      if (isSimpleStackCross && (getPositionType(child) !== CSS_POSITION_RELATIVE || alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START || isUndefined2(child.layout[dim[crossAxis]]))) {
        isSimpleStackCross = false;
        firstComplexCross = i;
      }
      if (isSimpleStackMain) {
        child.layout[pos[mainAxis]] += mainDim;
        if (isMainDimDefined) {
          setTrailingPosition(node, child, mainAxis);
        }
        mainDim += getDimWithMargin(child, mainAxis);
        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
      }
      if (isSimpleStackCross) {
        child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;
        if (isCrossDimDefined) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
      alreadyComputedNextLayout = 0;
      mainContentDim += nextContentDim;
      endLine = i + 1;
    }
    var leadingMainDim = 0;
    var betweenMainDim = 0;
    var remainingMainDim = 0;
    if (isMainDimDefined) {
      remainingMainDim = definedMainDim - mainContentDim;
    } else {
      remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;
    }
    if (flexibleChildrenCount !== 0) {
      var flexibleMainDim = remainingMainDim / totalFlexible;
      var baseMainDim;
      var boundMainDim;
      currentFlexChild = firstFlexChild;
      while (currentFlexChild !== null) {
        baseMainDim = flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis);
        boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);
        if (baseMainDim !== boundMainDim) {
          remainingMainDim -= boundMainDim;
          totalFlexible -= currentFlexChild.style.flex;
        }
        currentFlexChild = currentFlexChild.nextFlexChild;
      }
      flexibleMainDim = remainingMainDim / totalFlexible;
      if (flexibleMainDim < 0) {
        flexibleMainDim = 0;
      }
      currentFlexChild = firstFlexChild;
      while (currentFlexChild !== null) {
        currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis));
        maxWidth = CSS_UNDEFINED;
        if (isDimDefined(node, resolvedRowAxis)) {
          maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
        } else if (!isMainRowDirection) {
          maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
        }
        layoutNode(
          /*(java)!layoutContext, */
          currentFlexChild,
          maxWidth,
          direction
        );
        child = currentFlexChild;
        currentFlexChild = currentFlexChild.nextFlexChild;
        child.nextFlexChild = null;
      }
    } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {
      if (justifyContent === CSS_JUSTIFY_CENTER) {
        leadingMainDim = remainingMainDim / 2;
      } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {
        leadingMainDim = remainingMainDim;
      } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {
        remainingMainDim = fmaxf(remainingMainDim, 0);
        if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {
          betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
        } else {
          betweenMainDim = 0;
        }
      } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {
        betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
        leadingMainDim = betweenMainDim / 2;
      }
    }
    mainDim += leadingMainDim;
    for (i = firstComplexMain; i < endLine; ++i) {
      child = node.children[i];
      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {
        child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis);
      } else {
        child.layout[pos[mainAxis]] += mainDim;
        if (isMainDimDefined) {
          setTrailingPosition(node, child, mainAxis);
        }
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);
          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
        }
      }
    }
    var containerCrossAxis = node.layout[dim[crossAxis]];
    if (!isCrossDimDefined) {
      containerCrossAxis = fmaxf(
        // For the cross dim, we add both sides at the end because the value
        // is aggregate via a max function. Intermediate negative values
        // can mess this computation otherwise
        boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),
        paddingAndBorderAxisCross
      );
    }
    for (i = firstComplexCross; i < endLine; ++i) {
      child = node.children[i];
      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {
        child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis);
      } else {
        var leadingCrossDim = leadingPaddingAndBorderCross;
        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
          var alignItem = getAlignItem(node, child);
          if (alignItem === CSS_ALIGN_STRETCH) {
            if (isUndefined2(child.layout[dim[crossAxis]])) {
              child.layout[dim[crossAxis]] = fmaxf(
                boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
                // You never want to go smaller than padding
                getPaddingAndBorderAxis(child, crossAxis)
              );
            }
          } else if (alignItem !== CSS_ALIGN_FLEX_START) {
            var remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);
            if (alignItem === CSS_ALIGN_CENTER) {
              leadingCrossDim += remainingCrossDim / 2;
            } else {
              leadingCrossDim += remainingCrossDim;
            }
          }
        }
        child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;
        if (isCrossDimDefined) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
    }
    linesCrossDim += crossDim;
    linesMainDim = fmaxf(linesMainDim, mainDim);
    linesCount += 1;
    startLine = endLine;
  }
  if (linesCount > 1 && isCrossDimDefined) {
    var nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] - paddingAndBorderAxisCross;
    var remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;
    var crossDimLead = 0;
    var currentLead = leadingPaddingAndBorderCross;
    var alignContent = getAlignContent(node);
    if (alignContent === CSS_ALIGN_FLEX_END) {
      currentLead += remainingAlignContentDim;
    } else if (alignContent === CSS_ALIGN_CENTER) {
      currentLead += remainingAlignContentDim / 2;
    } else if (alignContent === CSS_ALIGN_STRETCH) {
      if (nodeCrossAxisInnerSize > linesCrossDim) {
        crossDimLead = remainingAlignContentDim / linesCount;
      }
    }
    var endIndex = 0;
    for (i = 0; i < linesCount; ++i) {
      var startIndex = endIndex;
      var lineHeight = 0;
      for (ii = startIndex; ii < childCount; ++ii) {
        child = node.children[ii];
        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
          continue;
        }
        if (child.lineIndex !== i) {
          break;
        }
        if (!isUndefined2(child.layout[dim[crossAxis]])) {
          lineHeight = fmaxf(lineHeight, child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis));
        }
      }
      endIndex = ii;
      lineHeight += crossDimLead;
      for (ii = startIndex; ii < endIndex; ++ii) {
        child = node.children[ii];
        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
          continue;
        }
        var alignContentAlignItem = getAlignItem(node, child);
        if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {
          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
        } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {
          child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];
        } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {
          var childHeight = child.layout[dim[crossAxis]];
          child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;
        } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {
          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
        }
      }
      currentLead += lineHeight;
    }
  }
  var needsMainTrailingPos = false;
  var needsCrossTrailingPos = false;
  if (!isMainDimDefined) {
    node.layout[dim[mainAxis]] = fmaxf(
      // We're missing the last padding at this point to get the final
      // dimension
      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),
      // We can never assign a width smaller than the padding and borders
      paddingAndBorderAxisMain
    );
    if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsMainTrailingPos = true;
    }
  }
  if (!isCrossDimDefined) {
    node.layout[dim[crossAxis]] = fmaxf(
      // For the cross dim, we add both sides at the end because the value
      // is aggregate via a max function. Intermediate negative values
      // can mess this computation otherwise
      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),
      paddingAndBorderAxisCross
    );
    if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsCrossTrailingPos = true;
    }
  }
  if (needsMainTrailingPos || needsCrossTrailingPos) {
    for (i = 0; i < childCount; ++i) {
      child = node.children[i];
      if (needsMainTrailingPos) {
        setTrailingPosition(node, child, mainAxis);
      }
      if (needsCrossTrailingPos) {
        setTrailingPosition(node, child, crossAxis);
      }
    }
  }
  currentAbsoluteChild = firstAbsoluteChild;
  while (currentAbsoluteChild !== null) {
    for (ii = 0; ii < 2; ii++) {
      axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
      if (!isUndefined2(node.layout[dim[axis]]) && !isDimDefined(currentAbsoluteChild, axis) && isPosDefined(currentAbsoluteChild, leading[axis]) && isPosDefined(currentAbsoluteChild, trailing[axis])) {
        currentAbsoluteChild.layout[dim[axis]] = fmaxf(
          boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis])),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(currentAbsoluteChild, axis)
        );
      }
      if (isPosDefined(currentAbsoluteChild, trailing[axis]) && !isPosDefined(currentAbsoluteChild, leading[axis])) {
        currentAbsoluteChild.layout[leading[axis]] = node.layout[dim[axis]] - currentAbsoluteChild.layout[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]);
      }
    }
    child = currentAbsoluteChild;
    currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;
    child.nextAbsoluteChild = null;
  }
}
function saveMargin(node) {
  var style = node.style;
  var margin = {};
  [
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft"
    // 只支持marginLeft
  ].forEach(function(key) {
    var value = style[key];
    if (value && /^-?\d+%$/.test(value)) {
      margin[key] = value;
      style[key] = 0;
    }
  });
  node.margin = margin;
}
function percent2Num(value) {
  var percent2 = Number(value.substr(0, value.length - 1));
  return percent2 / 100;
}
function layoutMargin(node) {
  var margin = node.margin, layout = node.layout;
  Object.keys(margin).forEach(function(key) {
    var percent2 = percent2Num(margin[key]);
    if ((key === "marginLeft" || key === "marginRight") && layout.width) {
      layout.left += layout.width * percent2;
    } else if ((key === "marginTop" || key === "marginBottom") && layout.height) {
      layout.top += layout.height * percent2;
    }
  });
}
function layoutNode(node, parentMaxWidth, parentDirection) {
  node.shouldUpdate = true;
  saveMargin(node);
  var direction = node.style.direction || CSS_DIRECTION_LTR;
  var skipLayout = !node.isDirty && node.lastLayout && node.lastLayout.requestedHeight === node.layout.height && node.lastLayout.requestedWidth === node.layout.width && node.lastLayout.parentMaxWidth === parentMaxWidth && node.lastLayout.direction === direction;
  if (skipLayout) {
    node.layout.width = node.lastLayout.width;
    node.layout.height = node.lastLayout.height;
    node.layout.top = node.lastLayout.top;
    node.layout.left = node.lastLayout.left;
  } else {
    if (!node.lastLayout) {
      node.lastLayout = {};
    }
    node.lastLayout.requestedWidth = node.layout.width;
    node.lastLayout.requestedHeight = node.layout.height;
    node.lastLayout.parentMaxWidth = parentMaxWidth;
    node.lastLayout.direction = direction;
    node.children.forEach(function(child) {
      child.layout.width = void 0;
      child.layout.height = void 0;
      child.layout.top = 0;
      child.layout.left = 0;
    });
    layoutNodeImpl(node, parentMaxWidth, parentDirection);
    node.lastLayout.width = node.layout.width;
    node.lastLayout.height = node.layout.height;
    node.lastLayout.top = node.layout.top;
    node.lastLayout.left = node.layout.left;
  }
  layoutMargin(node);
}
function computeLayout(node) {
  if (!node)
    return node;
  fillNodes(node);
  layoutNode(node, null, null);
  return node;
}
var css_layout_default = computeLayout;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/computeLayout.js
function createMeasure(style, measureText2) {
  return function() {
    var text = style.text, width = style.width, height = style.height;
    var outputWidth = width;
    var outputHeight = height;
    if (!is_number_default(width) || !is_number_default(height)) {
      var _a = measureText2(text, style), measureWidth = _a.width, measureHeight = _a.height;
      if (!is_number_default(width)) {
        outputWidth = measureWidth;
      }
      if (!is_number_default(height)) {
        outputHeight = measureHeight;
      }
    }
    return {
      width: outputWidth,
      height: outputHeight
    };
  };
}
function getChildrenLayout(nodeTree) {
  if (!nodeTree)
    return;
  var left = 0;
  var top = 0;
  var right = 0;
  var bottom = 0;
  var width = 0;
  var height = 0;
  nodeTree.forEach(function(node) {
    var layout = node.layout;
    if (!layout)
      return;
    left = Math.min(left, layout.left);
    top = Math.min(top, layout.top);
    right = Math.min(right, layout.left + layout.width);
    bottom = Math.min(bottom, layout.top + layout.height);
    width = Math.max(width, layout.width);
    height = Math.max(height, layout.height);
  });
  return {
    left,
    top,
    right,
    bottom,
    width,
    height
  };
}
var NodeTree = (
  /** @class */
  function() {
    function NodeTree2(node) {
      var className = node.className, children = node.children, layout = node.layout;
      var nodeChildren = children && children.length ? children.map(function(child) {
        return new NodeTree2(child);
      }) : void 0;
      var nodeLayout = layout ? layout : getChildrenLayout(nodeChildren);
      this.children = nodeChildren;
      this.layout = nodeLayout;
      this.className = className;
    }
    NodeTree2.prototype.getElementsByClassName = function(targetClassName) {
      var result = [];
      var _a = this, className = _a.className, children = _a.children;
      if (className === targetClassName) {
        result.push(this);
      }
      if (children) {
        children.forEach(function(child) {
          result.push.apply(result, child.getElementsByClassName(targetClassName));
        });
      }
      return result;
    };
    return NodeTree2;
  }()
);
function extendMap(arr, fn) {
  if (!arr) {
    return arr;
  }
  var newArray = [];
  if (!is_array_default(arr)) {
    var rst = fn(arr);
    if (!rst) {
      return newArray;
    }
    if (is_array_default(rst)) {
      newArray = newArray.concat(rst);
    } else {
      newArray.push(rst);
    }
    return newArray;
  }
  for (var i = 0; i < arr.length; i++) {
    var element = arr[i];
    if (is_array_default(element)) {
      newArray = newArray.concat(extendMap(element, fn));
    } else if (element) {
      var rst = fn(element);
      if (!rst) {
        continue;
      }
      if (is_array_default(rst)) {
        newArray = newArray.concat(rst);
      } else {
        newArray.push(rst);
      }
    }
  }
  return newArray;
}
function createChildNodeTree(parent, vNodeChildren) {
  var tag = parent.tag;
  var children = extendMap(vNodeChildren, function(child) {
    var childTag = child.tag, childStyle = child.style, childChildren = child.children;
    if (tag !== Shape2 && childTag === Shape2 && childStyle.display !== "flex") {
      return null;
    }
    if (childTag !== Shape2) {
      return createChildNodeTree(child, childChildren);
    }
    return createNodeTree(child);
  });
  return children;
}
function createNodeTree(vNode) {
  var tag = vNode.tag, type = vNode.type, style = vNode.style, context = vNode.context, vNodeChildren = vNode.children;
  var measureText2 = context.measureText;
  var children = createChildNodeTree(vNode, vNodeChildren);
  if (type === "text") {
    style.measure = createMeasure(style, measureText2);
  }
  return {
    tag,
    type,
    style,
    children,
    // 保留对 vNode 的引用，用于把布局结果回填
    vNode
  };
}
function fillElementLayout(node) {
  var type = node.type, style = node.style, vNode = node.vNode, children = node.children, layout = node.layout;
  var attrs = shape_default(type, layout);
  if (style.measure) {
    delete style.measure;
  }
  vNode.layout = layout;
  vNode.style = __assign(__assign({}, attrs), style);
  if (!children || !children.length) {
    return;
  }
  for (var i = 0, len5 = children.length; i < len5; i++) {
    var child = children[i];
    fillElementLayout(child);
  }
}
function fillComponentLayout(vNode) {
  var layout = vNode.layout, vNodeChildren = vNode.children;
  children_default.map(vNodeChildren, function(child) {
    if (!child) {
      return;
    }
    var childTag = child.tag, childLayout = child.layout, style = child.style;
    if (childTag !== Shape2 && layout && !childLayout) {
      child.layout = layout;
      child.style = __assign({
        width: layout.width,
        height: layout.height
      }, style);
    }
    fillComponentLayout(child);
  });
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/render/index.js
function pickElement(element) {
  if (!element)
    return element;
  return children_default.map(element, function(item) {
    if (!item)
      return item;
    return pick_default(item, ["key", "ref", "type", "props"]);
  });
}
function getStyle2(tagType, props, context) {
  var _a = props.style, customStyle = _a === void 0 ? {} : _a, attrs = props.attrs, zIndex = props.zIndex;
  if (tagType === Shape2) {
    return context.px2hd(__assign(__assign({}, customStyle), attrs));
  }
  if (is_number_default(zIndex)) {
    return {
      zIndex
    };
  }
  return {};
}
function createVNode(parent, vNode) {
  var canvas = parent.canvas, context = parent.context, updater = parent.updater, parentAnimate = parent.animate;
  var ref = vNode.ref, type = vNode.type, originProps = vNode.props;
  var animate = originProps.animate, transformFrom = originProps.transformFrom, props = __rest(originProps, ["animate", "transformFrom"]);
  var tag = getWorkTag(type);
  var animator = new animator_default();
  var style = getStyle2(tag, props, context);
  vNode.parent = parent;
  vNode.tag = tag;
  vNode.style = style;
  vNode.context = context;
  vNode.updater = updater;
  vNode.canvas = canvas;
  vNode.animate = is_boolean_default(animate) ? animate : parentAnimate;
  vNode.animator = animator;
  if (tag === Shape2) {
    var shape = createShape(type, __assign(__assign({}, props), {
      style
    }));
    if (ref) {
      ref.current = shape;
    }
    shape._vNode = vNode;
    vNode.shape = shape;
  } else {
    var component = void 0;
    if (tag === ClassComponent) {
      component = new type(props, context, updater);
    } else {
      component = new component_default(props, context, updater);
      component.render = function() {
        return type(this.props, context, updater);
      };
    }
    var group = new Group();
    component.container = group;
    if (ref) {
      ref.current = component;
    }
    component.context = context;
    component.updater = updater;
    component.animator = animator;
    component._vNode = vNode;
    vNode.shape = group;
    vNode.component = component;
  }
  if (transformFrom && transformFrom.current) {
    var transformVNode = transformFrom.current._vNode;
    vNode.transform = findClosestShapeNode_default(transformVNode);
    if (vNode.transform) {
      vNode.transform.parent.children = null;
    }
  }
  return vNode;
}
function updateVNode(parent, nextNode, lastNode) {
  var canvas = parent.canvas, context = parent.context, updater = parent.updater, parentAnimate = parent.animate;
  var tag = lastNode.tag, animator = lastNode.animator, component = lastNode.component, shape = lastNode.shape, children = lastNode.children;
  var props = nextNode.props;
  var animate = props.animate;
  nextNode.parent = parent;
  nextNode.tag = tag;
  nextNode.canvas = canvas;
  nextNode.context = context;
  nextNode.updater = updater;
  nextNode.component = component;
  nextNode.shape = shape;
  nextNode.parent = parent;
  nextNode.children = children;
  nextNode.animate = is_boolean_default(animate) ? animate : parentAnimate;
  nextNode.animator = animator;
  nextNode.style = getStyle2(tag, props, context);
  if (component) {
    component._vNode = nextNode;
  } else {
    shape._vNode = nextNode;
  }
  return nextNode;
}
function createElement(parent, element) {
  return children_default.map(element, function(el) {
    if (!el)
      return el;
    return createVNode(parent, el);
  });
}
function destroyElement(vNode) {
  children_default.map(vNode, function(node) {
    if (!node)
      return;
    var component = node.component, children = node.children;
    if (component) {
      component.willUnmount();
      destroyElement(children);
      component.didUnmount();
      component.destroy();
    }
  });
}
function updateElement(parent, nextElement, lastElement) {
  var nextType = nextElement.type, nextProps = nextElement.props;
  var lastType = lastElement.type, lastProps = lastElement.props;
  if (nextType === lastType) {
    var nextVNode_1 = updateVNode(parent, nextElement, lastElement);
    if (equal_default(nextProps, lastProps) && parent.context === lastElement.context) {
      return null;
    }
    return nextVNode_1;
  }
  var nextVNode = createVNode(parent, nextElement);
  destroyElement(lastElement);
  return nextVNode;
}
function diffElement(parent, nextElement, lastElement) {
  if (!nextElement && !lastElement) {
    return null;
  }
  if (!nextElement && lastElement) {
    destroyElement(lastElement);
    return null;
  }
  if (nextElement && !lastElement) {
    return createElement(parent, nextElement);
  }
  return updateElement(parent, nextElement, lastElement);
}
function renderComponentNodes(componentNodes) {
  if (!componentNodes || !componentNodes.length) {
    return;
  }
  var shouldProcessChildren = componentNodes.filter(function(node) {
    var component = node.component, props = node.props, context = node.context, layout = node.layout;
    component.layout = layout;
    if (!component.isMounted)
      return true;
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    component.willReceiveProps(props, context);
    component.props = props;
    component.context = context;
    return true;
  });
  if (!shouldProcessChildren.length) {
    return;
  }
  shouldProcessChildren.forEach(function(child) {
    var component = child.component;
    if (!component.isMounted) {
      component.willMount();
    } else {
      component.willUpdate();
    }
  });
  shouldProcessChildren.forEach(function(child) {
    var canvas = child.canvas, component = child.component, children = child.children;
    var newChildren = canvas.toRawChildren(component.render());
    renderChildren(child, newChildren, children);
    if (!component.isMounted) {
      component.didMount();
      component.isMounted = true;
    } else {
      component.didUpdate();
    }
  });
}
function renderVNode(node, nextChildren, lastChildren) {
  var component = node.component;
  var newChildren = pickElement(nextChildren);
  node.children = newChildren;
  if (component) {
    component.children = newChildren;
  }
  var componentNodeChildren = [];
  children_default.compare(newChildren, lastChildren, function(next, last2) {
    var element = diffElement(node, next, last2);
    children_default.map(element, function(child) {
      if (!child)
        return;
      var tag = child.tag, childProps = child.props, childLastChildren = child.children;
      var childrenNode = [];
      if (tag === Shape2) {
        childrenNode = renderVNode(child, childProps.children, childLastChildren);
      } else {
        childrenNode = [child];
      }
      componentNodeChildren = componentNodeChildren.concat(childrenNode);
    });
  });
  return componentNodeChildren;
}
function renderChildren(parent, nextChildren, lastChildren) {
  var componentNodeChildren = renderVNode(parent, nextChildren, lastChildren);
  var nodeTree = createNodeTree(parent);
  css_layout_default(nodeTree);
  fillElementLayout(nodeTree);
  fillComponentLayout(parent);
  var newChildren = parent.children;
  if (!componentNodeChildren.length) {
    return newChildren;
  }
  renderComponentNodes(componentNodeChildren);
  return newChildren;
}
function render(vNode) {
  var lastChildren = vNode.children, props = vNode.props;
  var nextChildren = props.children;
  var children = renderChildren(vNode, nextChildren, lastChildren);
  var childrenAnimation = createAnimation(vNode, children, lastChildren);
  if (childrenAnimation.length) {
    childrenAnimation.forEach(function(animator) {
      animator.loadPlay();
    });
  }
}
function updateComponents(components) {
  if (!components.length)
    return;
  components.forEach(function(component) {
    var vNode = component._vNode, lastChildren = component.children, props = component.props, animator = component.animator;
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    component.willUpdate();
    var canvas = vNode.canvas;
    var newChildren = canvas.toRawChildren(component.render());
    var nextChildren = renderChildren(vNode, newChildren, lastChildren);
    component.children = nextChildren;
    vNode.children = nextChildren;
    var childrenAnimation = createAnimation(vNode, nextChildren, lastChildren);
    if (childrenAnimation && childrenAnimation.length) {
      animator.children = childrenAnimation;
    }
    animator.loadPlay();
    component.didUpdate();
  });
}

// node_modules/.pnpm/@antv+g-plugin-canvas-path-generator@1.1.44_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function generatePath(context, parsedStyle) {
  var r = parsedStyle.r;
  context.arc(r, r, r, 0, Math.PI * 2, false);
}
function generatePath$1(context, parsedStyle) {
  var rxInPixels = parsedStyle.rx, ryInPixels = parsedStyle.ry;
  var rx = rxInPixels;
  var ry = ryInPixels;
  if (context.ellipse) {
    context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r = rx > ry ? rx : ry;
    var scaleX = rx > ry ? 1 : rx / ry;
    var scaleY = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX, scaleY);
    context.arc(0, 0, r, 0, Math.PI * 2);
  }
}
function generatePath$2(context, parsedStyle) {
  var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = x2 - x1;
    y = y2 - y1;
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = x1 - x2;
    y = y1 - y2;
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 - defX + startOffsetX, y1 - defY + startOffsetY);
  context.lineTo(x2 - defX + endOffsetX, y2 - defY + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$path = parsedStyle.path, absolutePath = _parsedStyle$path.absolutePath, segments = _parsedStyle$path.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _markerStart$parentNo = markerStart.parentNode.getStartTangent(), p1 = _markerStart$parentNo[0], p2 = _markerStart$parentNo[1];
    x = p1[0] - p2[0];
    y = p1[1] - p2[1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _markerEnd$parentNode = markerEnd.parentNode.getEndTangent(), _p = _markerEnd$parentNode[0], _p2 = _markerEnd$parentNode[1];
    x = _p[0] - _p2[0];
    y = _p[1] - _p2[1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  for (var i = 0; i < absolutePath.length; i++) {
    var params = absolutePath[i];
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    switch (command) {
      case "M":
        if (useStartOffset) {
          context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);
          context.lineTo(params[1] - defX, params[2] - defY);
        } else {
          context.moveTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "L":
        if (useEndOffset) {
          context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);
        } else {
          context.lineTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "Q":
        context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);
        if (useEndOffset) {
          context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);
        }
        break;
      case "C":
        context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);
        if (useEndOffset) {
          context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);
        }
        break;
      case "A": {
        var arcParams = segments[i].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx - defX, cy - defY);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-(cx - defX), -(cy - defY));
        }
        if (useEndOffset) {
          context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$4(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length14 = points.length;
  var x1 = points[0][0] - defX;
  var y1 = points[0][1] - defY;
  var x2 = points[length14 - 1][0] - defX;
  var y2 = points[length14 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = points[1][0] - points[0][0];
    y = points[1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = points[length14 - 1][0] - points[0][0];
    y = points[length14 - 1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
  for (var i = 1; i < length14 - 1; i++) {
    var point = points[i];
    context.lineTo(point[0] - defX, point[1] - defY);
  }
  context.lineTo(x2, y2);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$defX = parsedStyle.defX, defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX, _parsedStyle$defY = parsedStyle.defY, defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length14 = points.length;
  var x1 = points[0][0] - defX;
  var y1 = points[0][1] - defY;
  var x2 = points[length14 - 1][0] - defX;
  var y2 = points[length14 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x;
  var y;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x = points[1][0] - points[0][0];
    y = points[1][1] - points[0][1];
    rad2 = Math.atan2(y, x);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x = points[length14 - 2][0] - points[length14 - 1][0];
    y = points[length14 - 2][1] - points[length14 - 1][1];
    rad2 = Math.atan2(y, x);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  for (var i = 1; i < length14 - 1; i++) {
    var point = points[i];
    context.lineTo(point[0] - defX, point[1] - defY);
  }
  context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}
function generatePath$6(context, parsedStyle) {
  var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w = width;
  var h2 = height;
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  if (!hasRadius) {
    context.rect(0, 0, w, h2);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r) {
      return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h2) / 2));
    }), tlr = _radius$map[0], trr = _radius$map[1], brr = _radius$map[2], blr = _radius$map[3];
    context.moveTo(signX * tlr, 0);
    context.lineTo(w - signX * trr, 0);
    if (trr !== 0) {
      context.arc(w - signX * trr, signY * trr, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w, h2 - signY * brr);
    if (brr !== 0) {
      context.arc(w - signX * brr, h2 - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr, h2);
    if (blr !== 0) {
      context.arc(signX * blr, h2 - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(0, signY * tlr);
    if (tlr !== 0) {
      context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = function(_AbstractRendererPlug) {
  _inheritsLoose3(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _pathGeneratorFactory;
    var pathGeneratorFactory = (_pathGeneratorFactory = {}, _pathGeneratorFactory[Shape.CIRCLE] = generatePath, _pathGeneratorFactory[Shape.ELLIPSE] = generatePath$1, _pathGeneratorFactory[Shape.RECT] = generatePath$6, _pathGeneratorFactory[Shape.LINE] = generatePath$2, _pathGeneratorFactory[Shape.POLYLINE] = generatePath$5, _pathGeneratorFactory[Shape.POLYGON] = generatePath$4, _pathGeneratorFactory[Shape.PATH] = generatePath$3, _pathGeneratorFactory[Shape.TEXT] = void 0, _pathGeneratorFactory[Shape.GROUP] = void 0, _pathGeneratorFactory[Shape.IMAGE] = void 0, _pathGeneratorFactory[Shape.HTML] = void 0, _pathGeneratorFactory[Shape.MESH] = void 0, _pathGeneratorFactory);
    this.context.pathGeneratorFactory = pathGeneratorFactory;
  };
  _proto.destroy = function destroy() {
    delete this.context.pathGeneratorFactory;
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-canvas-picker@1.8.42_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
function _regeneratorRuntime2() {
  _regeneratorRuntime2 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i = 0, arr2 = new Array(len5); i < len5; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat42 = mat4_exports.create();
var CanvasPickerPlugin = function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    this.canvasConfig = void 0;
    this.pathGeneratorFactory = void 0;
    this.pointInPathPickerFactory = void 0;
    this.isHit = function(displayObject, position, worldTransform, isClipPath, runtime2) {
      var pick = _this2.pointInPathPickerFactory[displayObject.nodeName];
      if (pick) {
        var invertWorldMat = mat4_exports.invert(tmpMat42, worldTransform);
        var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
        var _displayObject$getGeo = displayObject.getGeometryBounds(), halfExtents = _displayObject$getGeo.halfExtents;
        var anchor = displayObject.parsedStyle.anchor;
        localPosition[0] += (anchor && anchor[0] || 0) * halfExtents[0] * 2;
        localPosition[1] += (anchor && anchor[1] || 0) * halfExtents[1] * 2;
        if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, runtime2)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(runtime2, displayObject, position) {
      var context = runtime2.offscreenCanvas.getOrCreateContext(_this2.canvasConfig.offscreenCanvas);
      var generatePath2 = _this2.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position.x, position.y);
    };
  }
  var _proto = CanvasPickerPlugin2.prototype;
  _proto.apply = function apply(context, runtime2) {
    var _renderingContext$roo, _this2 = this;
    var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, pathGeneratorFactory = context.pathGeneratorFactory, pointInPathPickerFactory = context.pointInPathPickerFactory;
    this.canvasConfig = config;
    this.pathGeneratorFactory = pathGeneratorFactory;
    this.pointInPathPickerFactory = pointInPathPickerFactory;
    var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
    renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function() {
      var _ref = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(result) {
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document2, result, runtime2));
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }());
    renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
      return _this2.pick(document2, result, runtime2);
    });
  };
  _proto.pick = function pick(document2, result, runtime2) {
    var topmost = result.topmost, _result$position = result.position, x = _result$position.x, y = _result$position.y;
    var position = vec3_exports.set(tmpVec3a, x, y, 0);
    var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
    var pickedDisplayObjects = [];
    for (var _iterator = _createForOfIteratorHelperLoose2(hitTestList), _step; !(_step = _iterator()).done; ) {
      var displayObject = _step.value;
      var worldTransform = displayObject.getWorldTransform();
      var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false, runtime2);
      if (isHitOriginShape) {
        var clipped = findClosestClipPathTarget(displayObject);
        if (clipped) {
          var clipPath = clipped.parsedStyle.clipPath;
          var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true, runtime2);
          if (isHitClipPath) {
            if (topmost) {
              result.picked = [displayObject];
              return result;
            } else {
              pickedDisplayObjects.push(displayObject);
            }
          }
        } else {
          if (topmost) {
            result.picked = [displayObject];
            return result;
          } else {
            pickedDisplayObjects.push(displayObject);
          }
        }
      }
    }
    result.picked = pickedDisplayObjects;
    return result;
  };
  return CanvasPickerPlugin2;
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function distance5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual3(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray2(xArr, yArr) {
  var minX = Math.min.apply(Math, xArr);
  var minY = Math.min.apply(Math, yArr);
  var maxX = Math.max.apply(Math, xArr);
  var maxY = Math.max.apply(Math, yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function piMod2(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
var line2 = {
  /**
   * 计算线段的包围盒
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {object} 包围盒对象
   */
  box: function box7(x1, y1, x2, y2) {
    return getBBoxByArray2([x1, x2], [y1, y2]);
  },
  /**
   * 线段的长度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 距离
   */
  length: function length11(x1, y1, x2, y2) {
    return distance5(x1, y1, x2, y2);
  },
  /**
   * 根据比例获取点
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} t 指定比例
   * @return {object} 包含 x, y 的点
   */
  pointAt: function pointAt7(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointDistance: function pointDistance7(x1, y1, x2, y2, x, y) {
    var cross4 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross4 < 0) {
      return distance5(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross4 > lengthSquare) {
      return distance5(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 点到直线的距离，而不是点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointToLine: function pointToLine2(x1, y1, x2, y2, x, y) {
    var d4 = [x2 - x1, y2 - y1];
    if (vec2_exports.exactEquals(d4, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d4[1], d4[0]];
    vec2_exports.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2_exports.dot(a, u));
  },
  /**
   * 线段的角度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 导数
   */
  tangentAngle: function tangentAngle7(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON3 = 1e-4;
function nearestPoint4(xArr, yArr, x, y, tCallback, length14) {
  var t = -1;
  var d4 = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length14 && length14 > 200) {
    segNum = length14 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
    var d1 = distance5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d4) {
      t = _t;
      d4 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d4 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval < EPSILON3) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
    var _d = distance5(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d4) {
      t = prev;
      d4 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
      var d22 = distance5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d4) {
        t = next;
        d4 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, xArr.concat([t])),
    y: tCallback.apply(void 0, yArr.concat([t]))
  };
}
function snapLength2(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance5(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt2(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema2(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual3(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt2(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic2(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt2(x1, x2, x3, t);
  var yt = quadraticAt2(y1, y2, y3, t);
  var controlPoint1 = line2.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line2.pointAt(x2, y2, x3, y3, t);
  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
}
function quadraticLength2(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance5(x1, y1, x2, y2) + distance5(x2, y2, x3, y3) + distance5(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic2(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength2.apply(void 0, left) + quadraticLength2.apply(void 0, right);
}
var quadratic2 = {
  box: function box8(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema2(x1, x2, x3)[0];
    var yExtrema2 = extrema2(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt2(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt2(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray2(xArr, yArr);
  },
  length: function length12(x1, y1, x2, y2, x3, y3) {
    return quadraticLength2(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function nearestPoint$13(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint4([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt2);
  },
  pointDistance: function pointDistance8(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance5(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt2,
  pointAt: function pointAt8(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt2(x1, x2, x3, t),
      y: quadraticAt2(y1, y2, y3, t)
    };
  },
  divide: function divide6(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic2(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function tangentAngle8(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt2(x1, x2, x3, t);
    var dy = derivativeAt2(y1, y2, y3, t);
    var angle3 = Math.atan2(dy, dx);
    return piMod2(angle3);
  }
};
function cubicAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt$12(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema$12(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual3(a, 0)) {
    if (!isNumberEqual3(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual3(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt2(x1, x2, x3, x4, t);
  var yt = cubicAt2(y1, y2, y3, y4, t);
  var c1 = line2.pointAt(x1, y1, x2, y2, t);
  var c2 = line2.pointAt(x2, y2, x3, y3, t);
  var c3 = line2.pointAt(x3, y3, x4, y4, t);
  var c12 = line2.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line2.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
}
function cubicLength2(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength2([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = [].concat(cubics[0], [iterationCount - 1]);
  var right = [].concat(cubics[1], [iterationCount - 1]);
  return cubicLength2.apply(void 0, left) + cubicLength2.apply(void 0, right);
}
var cubic2 = {
  extrema: extrema$12,
  box: function box9(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema$12(x1, x2, x3, x4);
    var yExtrema2 = extrema$12(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt2(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var _i = 0; _i < yExtrema2.length; _i++) {
      yArr.push(cubicAt2(y1, y2, y3, y4, yExtrema2[_i]));
    }
    return getBBoxByArray2(xArr, yArr);
  },
  length: function length13(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength2(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function nearestPoint$14(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    return nearestPoint4([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt2, length14);
  },
  pointDistance: function pointDistance9(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length14);
    return distance5(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt2,
  pointAt: function pointAt9(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt2(x1, x2, x3, x4, t),
      y: cubicAt2(y1, y2, y3, y4, t)
    };
  },
  divide: function divide7(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic2(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function tangentAngle9(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt$12(x1, x2, x3, x4, t);
    var dy = derivativeAt$12(y1, y2, y3, y4, t);
    return piMod2(Math.atan2(dy, dx));
  }
};
function distance$1(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}
function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle3 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  var point = {
    x: cx + r * Math.cos(angle3),
    y: cy + r * Math.sin(angle3)
  };
  return distance$1(point.x, point.y, x, y) <= lineWidth / 2;
}
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  return line2.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = inPolygon(points, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, r = _displayObject$parsed.r, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, pointerEvents = _displayObject$parsed.pointerEvents;
  var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var absDistance = distance$1(r, r, position.x, position.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r;
  }
  if (hasStroke) {
    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$1(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, rx = _displayObject$parsed.rx, ry = _displayObject$parsed.ry, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, pointerEvents = _displayObject$parsed.pointerEvents;
  var x = position.x, y = position.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var squareX = (x - rx) * (x - rx);
  var squareY = (y - ry) * (y - ry);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function isPointInPath$2(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, x1 = _displayObject$parsed.x1, y1 = _displayObject$parsed.y1, x2 = _displayObject$parsed.x2, y2 = _displayObject$parsed.y2, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasStroke = _isFillOrStrokeAffect[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x1, y1, x2, y2, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y);
}
function isPointInStroke2(segments, lineWidth, px2, py, length14) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box10 = segment.box;
    if (box10 && !inBox(box10.x - halfWidth, box10.y - halfWidth, box10.width + lineWidth, box10.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = quadratic2.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = cubic2.pointDistance(
          prePoint[0],
          // 上一段结束位置, 即 C 的起始点
          prePoint[1],
          params[1],
          // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length14
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = cubic2.pointDistance(
            prePointInCubic[0],
            // 上一段结束位置, 即 C 的起始点
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length14
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _displayObject$parsed = displayObject.parsedStyle, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, stroke = _displayObject$parsed.stroke, fill = _displayObject$parsed.fill, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, path = _displayObject$parsed.path, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var segments = path.segments, hasArc = path.hasArc, polylines = path.polylines, polygons = path.polygons;
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(runtime2, displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);
    }
    return isHit;
  } else if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, stroke = _displayObject$parsed.stroke, fill = _displayObject$parsed.fill, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, points = _displayObject$parsed.points, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x + x, position.y + y);
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath) {
  var _displayObject$parsed = displayObject.parsedStyle, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, points = _displayObject$parsed.points, _displayObject$parsed2 = _displayObject$parsed.defX, x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2, _displayObject$parsed3 = _displayObject$parsed.defY, y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3, pointerEvents = _displayObject$parsed.pointerEvents, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasStroke = _isFillOrStrokeAffect[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, false);
}
function isPointInPath$6(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _displayObject$parsed = displayObject.parsedStyle, radius = _displayObject$parsed.radius, fill = _displayObject$parsed.fill, stroke = _displayObject$parsed.stroke, lineWidth = _displayObject$parsed.lineWidth, increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting, width = _displayObject$parsed.width, height = _displayObject$parsed.height, pointerEvents = _displayObject$parsed.pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), hasFill = _isFillOrStrokeAffect[0], hasStroke = _isFillOrStrokeAffect[1];
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(0, 0, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(0, 0, width, height, radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(runtime2, displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {
  var tlr = radiusArray[0], trr = radiusArray[1], brr = radiusArray[2], blr = radiusArray[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}
var Plugin2 = function(_AbstractRendererPlug) {
  _inheritsLoose4(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "canvas-picker";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _pointInPathPickerFac;
    var trueFunc = function trueFunc2() {
      return true;
    };
    var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _pointInPathPickerFac[Shape.CIRCLE] = isPointInPath, _pointInPathPickerFac[Shape.ELLIPSE] = isPointInPath$1, _pointInPathPickerFac[Shape.RECT] = isPointInPath$6, _pointInPathPickerFac[Shape.LINE] = isPointInPath$2, _pointInPathPickerFac[Shape.POLYLINE] = isPointInPath$5, _pointInPathPickerFac[Shape.POLYGON] = isPointInPath$4, _pointInPathPickerFac[Shape.PATH] = isPointInPath$3, _pointInPathPickerFac[Shape.TEXT] = trueFunc, _pointInPathPickerFac[Shape.GROUP] = null, _pointInPathPickerFac[Shape.IMAGE] = trueFunc, _pointInPathPickerFac[Shape.HTML] = null, _pointInPathPickerFac[Shape.MESH] = null, _pointInPathPickerFac);
    this.context.pointInPathPickerFactory = pointInPathPickerFactory;
    this.addRenderingPlugin(new CanvasPickerPlugin());
  };
  _proto.destroy = function destroy() {
    delete this.context.pointInPathPickerFactory;
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-canvas-renderer@1.7.47_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
function _regeneratorRuntime3() {
  _regeneratorRuntime3 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep3(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator3(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf5(subClass, superClass);
}
function _setPrototypeOf5(o, p) {
  _setPrototypeOf5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf5(o, p);
}
var CanvasRendererPlugin = function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    this.canvasRendererPluginOptions = void 0;
    this.context = void 0;
    this.pathGeneratorFactory = void 0;
    this.rBush = void 0;
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    this.restoreStack = [];
    this.clearFullScreen = false;
    this.vpMatrix = mat4_exports.create();
    this.dprMatrix = mat4_exports.create();
    this.tmpMat4 = mat4_exports.create();
    this.vec3a = vec3_exports.create();
    this.vec3b = vec3_exports.create();
    this.vec3c = vec3_exports.create();
    this.vec3d = vec3_exports.create();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  var _proto = CanvasRendererPlugin2.prototype;
  _proto.apply = function apply(context, runtime2) {
    var _this2 = this;
    this.context = context;
    var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, pathGeneratorFactory = context.pathGeneratorFactory;
    this.rBush = rBushRoot;
    this.pathGeneratorFactory = pathGeneratorFactory;
    var contextService = context.contextService;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    var handleUnmounted = function handleUnmounted2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
      }
    };
    var handleCulled = function handleCulled2(e2) {
      var object = e2.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
      }
    };
    renderingService.hooks.init.tapPromise(CanvasRendererPlugin2.tag, _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee() {
      var dpr, width, height, context2;
      return _regeneratorRuntime3().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.CULLED, handleCulled);
              dpr = contextService.getDPR();
              width = config.width, height = config.height;
              context2 = contextService.getContext();
              _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
      canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
    });
    renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
      var context2 = contextService.getContext();
      var dpr = contextService.getDPR();
      var width = config.width, height = config.height;
      var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
      var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
      var ratio = rendered / total;
      _this2.clearFullScreen = renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
      if (context2) {
        context2.resetTransform();
        if (_this2.clearFullScreen) {
          _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
        }
      }
    });
    var renderByZIndex = function renderByZIndex2(object, context2) {
      if (object.isVisible() && !object.isCulled()) {
        _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
        _this2.saveDirtyAABB(object);
      }
      var sorted = object.sortable.sorted || object.childNodes;
      sorted.forEach(function(child) {
        renderByZIndex2(child, context2);
      });
    };
    renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
      var context2 = contextService.getContext();
      var dpr = contextService.getDPR();
      mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
      mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
      if (_this2.clearFullScreen) {
        renderByZIndex(renderingContext.root, context2);
      } else {
        var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_this2.removedRBushNodeAABBs.map(function(_ref2) {
          var minX = _ref2.minX, minY = _ref2.minY, maxX = _ref2.maxX, maxY = _ref2.maxY;
          var aabb = new AABB();
          aabb.setMinMax(
            // vec3.fromValues(minX, minY, 0),
            // vec3.fromValues(maxX, maxY, 0),
            [minX, minY, 0],
            [maxX, maxY, 0]
          );
          return aabb;
        })));
        _this2.removedRBushNodeAABBs = [];
        if (AABB.isEmpty(dirtyRenderBounds)) {
          _this2.renderQueue = [];
          return;
        }
        var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
        var x = dirtyRect.x, y = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
        var tl = vec3_exports.transformMat4(_this2.vec3a, [x, y, 0], _this2.vpMatrix);
        var tr = vec3_exports.transformMat4(_this2.vec3b, [x + width, y, 0], _this2.vpMatrix);
        var bl = vec3_exports.transformMat4(_this2.vec3c, [x, y + height, 0], _this2.vpMatrix);
        var br = vec3_exports.transformMat4(_this2.vec3d, [x + width, y + height, 0], _this2.vpMatrix);
        var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
        var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
        var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
        var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
        var ix = Math.floor(minx);
        var iy = Math.floor(miny);
        var iwidth = Math.ceil(maxx - minx);
        var iheight = Math.ceil(maxy - miny);
        context2.save();
        _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
        context2.beginPath();
        context2.rect(ix, iy, iwidth, iheight);
        context2.clip();
        context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
        var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
        if (enableDirtyRectangleRenderingDebug) {
          canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
            dirtyRect: {
              x: ix,
              y: iy,
              width: iwidth,
              height: iheight
            }
          }));
        }
        var dirtyObjects = _this2.searchDirtyObjects(runtime2, dirtyRenderBounds);
        dirtyObjects.sort(function(a, b) {
          return a.sortable.renderOrder - b.sortable.renderOrder;
        }).forEach(function(object) {
          if (object && object.isVisible() && !object.isCulled()) {
            _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
          }
        });
        context2.restore();
        _this2.renderQueue.forEach(function(object) {
          _this2.saveDirtyAABB(object);
        });
        _this2.renderQueue = [];
      }
      _this2.restoreStack.forEach(function() {
        context2.restore();
      });
      _this2.restoreStack = [];
    });
    renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
      if (!_this2.clearFullScreen) {
        _this2.renderQueue.push(object);
      }
    });
  };
  _proto.clearRect = function clearRect(context, x, y, width, height, background) {
    context.clearRect(x, y, width, height);
    if (background) {
      context.fillStyle = background;
      context.fillRect(x, y, width, height);
    }
  };
  _proto.renderDisplayObject = function renderDisplayObject(object, context, canvasContext, restoreStack, runtime2) {
    var nodeName = object.nodeName;
    var parent = restoreStack[restoreStack.length - 1];
    if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
      context.restore();
      restoreStack.pop();
    }
    var styleRenderer = this.context.styleRendererFactory[nodeName];
    var generatePath2 = this.pathGeneratorFactory[nodeName];
    var clipPath = object.parsedStyle.clipPath;
    if (clipPath) {
      this.applyWorldTransform(context, clipPath);
      var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
      if (_generatePath) {
        context.save();
        restoreStack.push(object);
        context.beginPath();
        _generatePath(context, clipPath.parsedStyle);
        context.closePath();
        context.clip();
      }
    }
    if (styleRenderer) {
      this.applyWorldTransform(context, object);
      context.save();
      this.applyAttributesToContext(context, object);
    }
    if (generatePath2) {
      context.beginPath();
      generatePath2(context, object.parsedStyle);
      if (object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
        context.closePath();
      }
    }
    if (styleRenderer) {
      styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
      context.restore();
    }
    object.renderable.dirty = false;
  };
  _proto.convertAABB2Rect = function convertAABB2Rect(aabb) {
    var min4 = aabb.getMin();
    var max4 = aabb.getMax();
    var minX = Math.floor(min4[0]);
    var minY = Math.floor(min4[1]);
    var maxX = Math.ceil(max4[0]);
    var maxY = Math.ceil(max4[1]);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      x: minX,
      y: minY,
      width,
      height
    };
  };
  _proto.mergeDirtyAABBs = function mergeDirtyAABBs(dirtyObjects) {
    var aabb = new AABB();
    dirtyObjects.forEach(function(object) {
      var renderBounds = object.getRenderBounds();
      aabb.add(renderBounds);
      var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
      if (dirtyRenderBounds) {
        aabb.add(dirtyRenderBounds);
      }
    });
    return aabb;
  };
  _proto.searchDirtyObjects = function searchDirtyObjects(runtime2, dirtyRectangle) {
    var _dirtyRectangle$getMi = dirtyRectangle.getMin(), minX = _dirtyRectangle$getMi[0], minY = _dirtyRectangle$getMi[1];
    var _dirtyRectangle$getMa = dirtyRectangle.getMax(), maxX = _dirtyRectangle$getMa[0], maxY = _dirtyRectangle$getMa[1];
    var rBushNodes = this.rBush.search({
      minX,
      minY,
      maxX,
      maxY
    });
    return rBushNodes.map(function(_ref3) {
      var id2 = _ref3.id;
      return runtime2.displayObjectPool.getByEntity(id2);
    });
  };
  _proto.saveDirtyAABB = function saveDirtyAABB(object) {
    var renderable = object.renderable;
    if (!renderable.dirtyRenderBounds) {
      renderable.dirtyRenderBounds = new AABB();
    }
    var renderBounds = object.getRenderBounds();
    if (renderBounds) {
      renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
    }
  };
  _proto.applyAttributesToContext = function applyAttributesToContext(context, object) {
    var _object$parsedStyle = object.parsedStyle, stroke = _object$parsedStyle.stroke, fill = _object$parsedStyle.fill, opacity = _object$parsedStyle.opacity, lineDash = _object$parsedStyle.lineDash, lineDashOffset = _object$parsedStyle.lineDashOffset;
    if (lineDash) {
      context.setLineDash(lineDash);
    }
    if (!is_nil_default(lineDashOffset)) {
      context.lineDashOffset = lineDashOffset;
    }
    if (!is_nil_default(opacity)) {
      context.globalAlpha *= opacity;
    }
    if (!is_nil_default(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
      context.strokeStyle = object.attributes.stroke;
    }
    if (!is_nil_default(fill) && !Array.isArray(fill) && !fill.isNone) {
      context.fillStyle = object.attributes.fill;
    }
  };
  _proto.applyWorldTransform = function applyWorldTransform(context, object, matrix) {
    var tx = 0;
    var ty = 0;
    var _ref4 = object.parsedStyle || {}, anchor = _ref4.anchor;
    var anchorX = anchor && anchor[0] || 0;
    var anchorY = anchor && anchor[1] || 0;
    if (anchorX !== 0 || anchorY !== 0) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 0;
      var height = bounds && bounds.halfExtents[1] * 2 || 0;
      tx = -(anchorX * width);
      ty = -(anchorY * height);
    }
    if (matrix) {
      mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
      this.vec3a[0] = tx;
      this.vec3a[1] = ty;
      this.vec3a[2] = 0;
      mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
      mat4_exports.multiply(this.tmpMat4, matrix, this.tmpMat4);
      mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
    } else {
      mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
      this.vec3a[0] = tx;
      this.vec3a[1] = ty;
      this.vec3a[2] = 0;
      mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
      mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
    }
    context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
  };
  _proto.safeMergeAABB = function safeMergeAABB() {
    var merged = new AABB();
    for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
      aabbs[_key] = arguments[_key];
    }
    aabbs.forEach(function(aabb) {
      merged.add(aabb);
    });
    return merged;
  };
  return CanvasRendererPlugin2;
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
var DefaultRenderer = function() {
  function DefaultRenderer2(imagePool) {
    this.imagePool = void 0;
    this.imagePool = imagePool;
  }
  var _proto = DefaultRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, opacity = parsedStyle.opacity, fillOpacity = parsedStyle.fillOpacity, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity, lineWidth = parsedStyle.lineWidth, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
    var hasFill = !is_nil_default(fill) && !fill.isNone;
    var hasStroke = !is_nil_default(stroke) && !stroke.isNone && lineWidth > 0;
    var isFillTransparent = fill.alpha === 0;
    var hasFilter = !!(filter && filter.length);
    var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
    var nodeName = object.nodeName;
    var isInnerShadow = shadowType === "inner";
    var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
    if (hasFill) {
      context.globalAlpha = opacity * fillOpacity;
      if (!shouldDrawShadowWithStroke) {
        setShadowAndFilter(object, context, hasShadow);
      }
      this.fill(context, object, fill, fillRule, canvasContext, plugin, runtime2);
      if (!shouldDrawShadowWithStroke) {
        this.clearShadowAndFilter(context, hasFilter, hasShadow);
      }
    }
    if (hasStroke) {
      context.globalAlpha = opacity * strokeOpacity;
      context.lineWidth = lineWidth;
      if (!is_nil_default(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      if (!is_nil_default(lineCap)) {
        context.lineCap = lineCap;
      }
      if (!is_nil_default(lineJoin)) {
        context.lineJoin = lineJoin;
      }
      if (shouldDrawShadowWithStroke) {
        if (isInnerShadow) {
          context.globalCompositeOperation = "source-atop";
        }
        setShadowAndFilter(object, context, true);
        if (isInnerShadow) {
          this.stroke(context, object, stroke, canvasContext, plugin, runtime2);
          context.globalCompositeOperation = "source-over";
          this.clearShadowAndFilter(context, hasFilter, true);
        }
      }
      this.stroke(context, object, stroke, canvasContext, plugin, runtime2);
    }
  };
  _proto.clearShadowAndFilter = function clearShadowAndFilter(context, hasFilter, hasShadow) {
    if (hasShadow) {
      context.shadowColor = "transparent";
      context.shadowBlur = 0;
    }
    if (hasFilter) {
      var oldFilter = context.filter;
      if (!is_nil_default(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
        context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
      }
    }
  };
  _proto.fill = function fill(context, object, _fill, fillRule, canvasContext, plugin, runtime2) {
    var _this2 = this;
    if (Array.isArray(_fill)) {
      _fill.forEach(function(gradient2) {
        context.fillStyle = _this2.getColor(gradient2, object, context);
        context.fill(fillRule);
      });
    } else {
      if (isPattern(_fill)) {
        context.fillStyle = this.getPattern(_fill, object, context, canvasContext, plugin, runtime2);
      }
      context.fill(fillRule);
    }
  };
  _proto.stroke = function stroke(context, object, _stroke, canvasContext, plugin, runtime2) {
    var _this2 = this;
    if (Array.isArray(_stroke)) {
      _stroke.forEach(function(gradient2) {
        context.strokeStyle = _this2.getColor(gradient2, object, context);
        context.stroke();
      });
    } else {
      if (isPattern(_stroke)) {
        context.strokeStyle = this.getPattern(_stroke, object, context, canvasContext, plugin, runtime2);
      }
      context.stroke();
    }
  };
  _proto.getPattern = function getPattern(pattern, object, context, canvasContext, plugin, runtime2) {
    var $offscreenCanvas;
    var dpr;
    if (pattern.image.nodeName === "rect") {
      var _pattern$image$parsed = pattern.image.parsedStyle, width = _pattern$image$parsed.width, height = _pattern$image$parsed.height;
      dpr = canvasContext.contextService.getDPR();
      var offscreenCanvas = canvasContext.config.offscreenCanvas;
      $offscreenCanvas = runtime2.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
      $offscreenCanvas.width = width * dpr;
      $offscreenCanvas.height = height * dpr;
      var offscreenCanvasContext = runtime2.offscreenCanvas.getOrCreateContext(offscreenCanvas);
      var restoreStack = [];
      pattern.image.forEach(function(object2) {
        plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, restoreStack, runtime2);
      });
      restoreStack.forEach(function() {
        offscreenCanvasContext.restore();
      });
    }
    var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function() {
      object.renderable.dirty = true;
      canvasContext.renderingService.dirtify();
    });
    return canvasPattern;
  };
  _proto.getColor = function getColor(parsedColor, object, context) {
    var color2;
    if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 1;
      var height = bounds && bounds.halfExtents[1] * 2 || 1;
      color2 = this.imagePool.getOrCreateGradient(_extends2({
        type: parsedColor.type
      }, parsedColor.value, {
        width,
        height
      }), context);
    }
    return color2;
  };
  return DefaultRenderer2;
}();
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter && filter.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
var ImageRenderer = function() {
  function ImageRenderer2(imagePool) {
    this.imagePool = void 0;
    this.imagePool = imagePool;
  }
  var _proto = ImageRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object) {
    var width = parsedStyle.width, height = parsedStyle.height, img = parsedStyle.img, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
    var image;
    var iw = width;
    var ih = height;
    if (is_string_default(img)) {
      image = this.imagePool.getImageSync(img);
    } else {
      iw || (iw = img.width);
      ih || (ih = img.height);
      image = img;
    }
    if (image) {
      var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        context.drawImage(image, 0, 0, iw, ih);
      } catch (e2) {
      }
    }
  };
  return ImageRenderer2;
}();
var TextRenderer = function() {
  function TextRenderer2() {
  }
  var _proto = TextRenderer2.prototype;
  _proto.render = function render3(context, parsedStyle, object) {
    var lineWidth = parsedStyle.lineWidth, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, lineJoin = parsedStyle.lineJoin, miterLimit = parsedStyle.miterLimit, letterSpacing = parsedStyle.letterSpacing, stroke = parsedStyle.stroke, fill = parsedStyle.fill, fillOpacity = parsedStyle.fillOpacity, strokeOpacity = parsedStyle.strokeOpacity, opacity = parsedStyle.opacity, metrics = parsedStyle.metrics, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
    var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
    context.font = font;
    context.lineWidth = lineWidth;
    context.textAlign = textAlign === "middle" ? "center" : textAlign;
    context.textBaseline = textBaseline;
    context.lineJoin = lineJoin;
    if (!is_nil_default(miterLimit)) {
      context.miterLimit = miterLimit;
    }
    var linePositionY = 0;
    if (textBaseline === "middle") {
      linePositionY = -height / 2 - lineHeight / 2;
    } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
      linePositionY = -height;
    } else if (textBaseline === "top" || textBaseline === "hanging") {
      linePositionY = -lineHeight;
    }
    var offsetX = dx || 0;
    linePositionY += dy || 0;
    var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
    setShadowAndFilter(object, context, hasShadow);
    for (var i = 0; i < lines.length; i++) {
      var linePositionX = lineWidth / 2 + offsetX;
      linePositionY += lineHeight;
      if (!is_nil_default(stroke) && !stroke.isNone && lineWidth) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);
      }
      if (!is_nil_default(fill)) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);
      }
    }
  };
  _proto.drawLetterSpacing = function drawLetterSpacing(context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    if (letterSpacing === 0) {
      if (isStroke) {
        this.strokeText(context, text, x, y, strokeOpacity);
      } else {
        this.fillText(context, text, x, y, fillOpacity, opacity);
      }
      return;
    }
    var currentTextAlign = context.textAlign;
    context.textAlign = "left";
    var currentPosition = x;
    if (textAlign === "center" || textAlign === "middle") {
      currentPosition = x - lineMetrics.width / 2;
    } else if (textAlign === "right" || textAlign === "end") {
      currentPosition = x - lineMetrics.width;
    }
    var stringArray = Array.from(text);
    var previousWidth = context.measureText(text).width;
    var currentWidth = 0;
    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];
      if (isStroke) {
        this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);
      } else {
        this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);
      }
      currentWidth = context.measureText(text.substring(i + 1)).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
    context.textAlign = currentTextAlign;
  };
  _proto.fillText = function fillText(context, text, x, y, fillOpacity, opacity) {
    var currentGlobalAlpha;
    var applyOpacity = !is_nil_default(fillOpacity) && fillOpacity !== 1;
    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = fillOpacity * opacity;
    }
    context.fillText(text, x, y);
    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };
  _proto.strokeText = function strokeText(context, text, x, y, strokeOpacity) {
    var currentGlobalAlpha;
    var applyOpacity = !is_nil_default(strokeOpacity) && strokeOpacity !== 1;
    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = strokeOpacity;
    }
    context.strokeText(text, x, y);
    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };
  return TextRenderer2;
}();
var RectRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(RectRenderer2, _DefaultRenderer);
  function RectRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return RectRenderer2;
}(DefaultRenderer);
var CircleRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(CircleRenderer2, _DefaultRenderer);
  function CircleRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return CircleRenderer2;
}(DefaultRenderer);
var EllipseRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(EllipseRenderer2, _DefaultRenderer);
  function EllipseRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return EllipseRenderer2;
}(DefaultRenderer);
var LineRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(LineRenderer2, _DefaultRenderer);
  function LineRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return LineRenderer2;
}(DefaultRenderer);
var PolylineRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PolylineRenderer2, _DefaultRenderer);
  function PolylineRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PolylineRenderer2;
}(DefaultRenderer);
var PolygonRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PolygonRenderer2, _DefaultRenderer);
  function PolygonRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PolygonRenderer2;
}(DefaultRenderer);
var PathRenderer = function(_DefaultRenderer) {
  _inheritsLoose5(PathRenderer2, _DefaultRenderer);
  function PathRenderer2() {
    return _DefaultRenderer.apply(this, arguments) || this;
  }
  return PathRenderer2;
}(DefaultRenderer);
var Plugin3 = function(_AbstractRendererPlug) {
  _inheritsLoose5(Plugin7, _AbstractRendererPlug);
  function Plugin7(options) {
    var _this2;
    if (options === void 0) {
      options = {};
    }
    _this2 = _AbstractRendererPlug.call(this) || this;
    _this2.options = void 0;
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    var _defaultStyleRenderer;
    var canvasRendererPluginOptions = _extends2({
      dirtyObjectNumThreshold: 500,
      dirtyObjectRatioThreshold: 0.8
    }, this.options);
    var imagePool = this.context.imagePool;
    var defaultRenderer = new DefaultRenderer(imagePool);
    var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defaultStyleRenderer[Shape.CIRCLE] = defaultRenderer, _defaultStyleRenderer[Shape.ELLIPSE] = defaultRenderer, _defaultStyleRenderer[Shape.RECT] = defaultRenderer, _defaultStyleRenderer[Shape.IMAGE] = new ImageRenderer(imagePool), _defaultStyleRenderer[Shape.TEXT] = new TextRenderer(), _defaultStyleRenderer[Shape.LINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYLINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYGON] = defaultRenderer, _defaultStyleRenderer[Shape.PATH] = defaultRenderer, _defaultStyleRenderer[Shape.GROUP] = void 0, _defaultStyleRenderer[Shape.HTML] = void 0, _defaultStyleRenderer[Shape.MESH] = void 0, _defaultStyleRenderer);
    this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
    this.context.styleRendererFactory = defaultStyleRendererFactory;
    this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
    delete this.context.defaultStyleRendererFactory;
    delete this.context.styleRendererFactory;
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-image-loader@1.1.45_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
function _regeneratorRuntime4() {
  _regeneratorRuntime4 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep4(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator4(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep4(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep4(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf6(subClass, superClass);
}
function _setPrototypeOf6(o, p) {
  _setPrototypeOf6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf6(o, p);
}
var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create7() {
  var out = new ARRAY_TYPE2(16);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function identity4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function scale7(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
var ImagePool = function() {
  function ImagePool2(canvasConfig) {
    this.canvasConfig = void 0;
    this.imageCache = {};
    this.gradientCache = {};
    this.patternCache = {};
    this.canvasConfig = canvasConfig;
  }
  var _proto = ImagePool2.prototype;
  _proto.getImageSync = function getImageSync(src, callback) {
    if (!this.imageCache[src]) {
      this.getOrCreateImage(src).then(function() {
        if (callback) {
          callback();
        }
      });
    } else {
      if (callback) {
        callback();
      }
    }
    return this.imageCache[src];
  };
  _proto.getOrCreateImage = function getOrCreateImage(src) {
    var _this2 = this;
    if (this.imageCache[src]) {
      return Promise.resolve(this.imageCache[src]);
    }
    var createImage = this.canvasConfig.createImage;
    return new Promise(function(resolve, reject) {
      var image;
      if (createImage) {
        image = createImage(src);
      } else if (isBrowser) {
        image = new window.Image();
      }
      if (image) {
        image.onload = function() {
          resolve(image);
        };
        image.onerror = function(ev) {
          reject(ev);
        };
        image.crossOrigin = "Anonymous";
        image.src = src;
        _this2.imageCache[src] = image;
      }
    });
  };
  _proto.getOrCreatePatternSync = function getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, callback) {
    var patternKey = this.generatePatternKey(pattern);
    if (patternKey && this.patternCache[patternKey]) {
      return this.patternCache[patternKey];
    }
    var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
    var src;
    var needScaleWithDPR = false;
    if (is_string_default(image)) {
      src = this.getImageSync(image, callback);
    } else if ($offscreenCanvas) {
      src = $offscreenCanvas;
      needScaleWithDPR = true;
    } else {
      src = image;
    }
    var canvasPattern = src && context.createPattern(src, repetition);
    if (canvasPattern) {
      var mat;
      if (transform) {
        mat = parsedTransformToMat4(parseTransform(transform));
      } else {
        mat = identity4(create7());
      }
      if (needScaleWithDPR) {
        scale7(mat, mat, [1 / dpr, 1 / dpr, 1]);
      }
      canvasPattern.setTransform({
        a: mat[0],
        b: mat[1],
        c: mat[4],
        d: mat[5],
        e: mat[12],
        f: mat[13]
      });
    }
    if (patternKey && canvasPattern) {
      this.patternCache[patternKey] = canvasPattern;
    }
    return canvasPattern;
  };
  _proto.getOrCreateGradient = function getOrCreateGradient(params, context) {
    var key = this.generateGradientKey(params);
    var type = params.type, steps = params.steps, width = params.width, height = params.height, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
    if (this.gradientCache[key]) {
      return this.gradientCache[key];
    }
    var gradient2 = null;
    if (type === GradientType.LinearGradient) {
      var _computeLinearGradien = computeLinearGradient(width, height, angle3), x1 = _computeLinearGradien.x1, y1 = _computeLinearGradien.y1, x2 = _computeLinearGradien.x2, y2 = _computeLinearGradien.y2;
      gradient2 = context.createLinearGradient(x1, y1, x2, y2);
    } else if (type === GradientType.RadialGradient) {
      var _computeRadialGradien = computeRadialGradient(width, height, cx, cy, size2), x = _computeRadialGradien.x, y = _computeRadialGradien.y, r = _computeRadialGradien.r;
      gradient2 = context.createRadialGradient(x, y, 0, x, y, r);
    }
    if (gradient2) {
      steps.forEach(function(_ref) {
        var offset = _ref.offset, color2 = _ref.color;
        if (offset.unit === UnitType.kPercentage) {
          var _gradient;
          (_gradient = gradient2) === null || _gradient === void 0 ? void 0 : _gradient.addColorStop(offset.value / 100, color2.toString());
        }
      });
      this.gradientCache[key] = gradient2;
    }
    return this.gradientCache[key];
  };
  _proto.generateGradientKey = function generateGradientKey(params) {
    var type = params.type, width = params.width, height = params.height, steps = params.steps, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
    return "gradient-" + type + "-" + ((angle3 === null || angle3 === void 0 ? void 0 : angle3.toString()) || 0) + "-" + ((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0) + "-" + ((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0) + "-" + ((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0) + "-" + width + "-" + height + "-" + steps.map(function(_ref2) {
      var offset = _ref2.offset, color2 = _ref2.color;
      return "" + offset + color2;
    }).join("-");
  };
  _proto.generatePatternKey = function generatePatternKey(pattern) {
    var image = pattern.image, repetition = pattern.repetition;
    if (is_string_default(image)) {
      return "pattern-" + image + "-" + repetition;
    } else if (image.nodeName === "rect") {
      return "pattern-" + image.entity + "-" + repetition;
    }
  };
  return ImagePool2;
}();
var LoadImagePlugin = function() {
  function LoadImagePlugin2() {
  }
  var _proto = LoadImagePlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    var handleMounted = function handleMounted2(e2) {
      var object = e2.target;
      var nodeName = object.nodeName, attributes = object.attributes;
      if (nodeName === Shape.IMAGE) {
        var img = attributes.img;
        if (is_string_default(img)) {
          imagePool.getImageSync(img, function() {
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      }
    };
    var handleAttributeChanged = function handleAttributeChanged2(e2) {
      var object = e2.target;
      var attrName = e2.attrName, newValue = e2.newValue;
      if (object.nodeName === Shape.IMAGE) {
        if (attrName === "img") {
          if (is_string_default(newValue)) {
            imagePool.getOrCreateImage(newValue).then(function() {
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        }
      }
    };
    renderingService.hooks.init.tapPromise(LoadImagePlugin2.tag, _asyncToGenerator4(_regeneratorRuntime4().mark(function _callee() {
      return _regeneratorRuntime4().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
      canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
      canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
    });
  };
  return LoadImagePlugin2;
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin4 = function(_AbstractRendererPlug) {
  _inheritsLoose6(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "image-loader";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.context.imagePool = new ImagePool(this.context.config);
    this.addRenderingPlugin(new LoadImagePlugin());
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-plugin-mobile-interaction@0.7.42_@antv+g-lite@1.0.42/node_modules/@antv/g-plugin-mobile-interaction/dist/index.esm.js
function _regeneratorRuntime5() {
  _regeneratorRuntime5 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep5(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator5(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep5(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep5(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose7(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf7(subClass, superClass);
}
function _setPrototypeOf7(o, p) {
  _setPrototypeOf7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf7(o, p);
}
var MobileInteractionPlugin = function() {
  function MobileInteractionPlugin2() {
  }
  var _proto = MobileInteractionPlugin2.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService, contextService = context.contextService;
    var canvasEl = contextService.getDomElement();
    var onPointerDown = function onPointerDown2(ev) {
      renderingService.hooks.pointerDown.call(ev);
    };
    var onPointerUp = function onPointerUp2(ev) {
      renderingService.hooks.pointerUp.call(ev);
    };
    var onPointerMove = function onPointerMove2(ev) {
      renderingService.hooks.pointerMove.call(ev);
    };
    var onPointerOver = function onPointerOver2(ev) {
      renderingService.hooks.pointerOver.call(ev);
    };
    var onPointerOut = function onPointerOut2(ev) {
      renderingService.hooks.pointerOut.call(ev);
    };
    var onPointerCancel = function onPointerCancel2(ev) {
      renderingService.hooks.pointerCancel.call(ev);
    };
    renderingService.hooks.init.tapPromise(MobileInteractionPlugin2.tag, _asyncToGenerator5(_regeneratorRuntime5().mark(function _callee() {
      return _regeneratorRuntime5().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvasEl.addEventListener("touchstart", onPointerDown, true);
              canvasEl.addEventListener("touchend", onPointerUp, true);
              canvasEl.addEventListener("touchmove", onPointerMove, true);
              canvasEl.addEventListener("touchcancel", onPointerCancel, true);
              canvasEl.addEventListener("mouseout", onPointerOut, true);
              canvasEl.addEventListener("mouseover", onPointerOver, true);
            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(MobileInteractionPlugin2.tag, function() {
      canvasEl.removeEventListener("touchstart", onPointerDown, true);
      canvasEl.removeEventListener("touchend", onPointerUp, true);
      canvasEl.removeEventListener("touchmove", onPointerMove, true);
      canvasEl.removeEventListener("touchcancel", onPointerCancel, true);
      canvasEl.removeEventListener("mouseout", onPointerOut, true);
      canvasEl.removeEventListener("mouseover", onPointerOver, true);
    });
  };
  return MobileInteractionPlugin2;
}();
MobileInteractionPlugin.tag = "MobileInteraction";
var Plugin5 = function(_AbstractRendererPlug) {
  _inheritsLoose7(Plugin7, _AbstractRendererPlug);
  function Plugin7() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "mobile-interaction";
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.addRenderingPlugin(new MobileInteractionPlugin());
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  return Plugin7;
}(AbstractRendererPlugin);

// node_modules/.pnpm/@antv+g-mobile-canvas@0.8.42_@antv+g-lite@1.0.42/node_modules/@antv/g-mobile-canvas/dist/index.esm.js
function _regeneratorRuntime6() {
  _regeneratorRuntime6 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep6(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator6(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep6(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep6(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _inheritsLoose8(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf8(subClass, superClass);
}
function _setPrototypeOf8(o, p) {
  _setPrototypeOf8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf8(o, p);
}
function _regeneratorRuntime$1() {
  _regeneratorRuntime$1 = function _regeneratorRuntime7() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function define3(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; ) {
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          }
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object) {
      keys.push(key);
    }
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this) {
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        }
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator$1(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
var DragndropPlugin = function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    this.dragndropPluginOptions = void 0;
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  var _proto = DragndropPlugin2.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    var renderingService = context.renderingService, renderingContext = context.renderingContext;
    var document2 = renderingContext.root.ownerDocument;
    var canvas = document2.defaultView;
    var handlePointerdown = function handlePointerdown2(event) {
      var target = event.target;
      var isDocument = target === document2;
      var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
      if (draggableEventTarget) {
        var dragstartTriggered = false;
        var dragstartTimeStamp = event.timeStamp;
        var dragstartClientCoordinates = [event.clientX, event.clientY];
        var currentDroppable = null;
        var lastDragClientCoordinates = [event.clientX, event.clientY];
        var handlePointermove = function() {
          var _ref = _asyncToGenerator$1(_regeneratorRuntime$1().mark(function _callee(event2) {
            var timeElapsed, distanceMoved, point, elementsBelow, elementBelow, droppableBelow;
            return _regeneratorRuntime$1().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 8;
                      break;
                    }
                    timeElapsed = event2.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                    if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    event2.type = "dragstart";
                    draggableEventTarget.dispatchEvent(event2);
                    dragstartTriggered = true;
                  case 8:
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates = [event2.clientX, event2.clientY];
                    if (isDocument) {
                      _context.next = 21;
                      break;
                    }
                    point = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    _context.next = 17;
                    return document2.elementsFromPoint(point[0], point[1]);
                  case 17:
                    elementsBelow = _context.sent;
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        event2.type = "dragover";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                    }
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function handlePointermove2(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        canvas.addEventListener("pointermove", handlePointermove);
        var stopDragging = function stopDragging2(originalPointerUpEvent) {
          if (dragstartTriggered) {
            originalPointerUpEvent.detail = {
              preventClick: true
            };
            var _event = originalPointerUpEvent.clone();
            if (currentDroppable) {
              _event.type = "drop";
              _event.target = currentDroppable;
              currentDroppable.dispatchEvent(_event);
            }
            _event.type = "dragend";
            draggableEventTarget.dispatchEvent(_event);
            dragstartTriggered = false;
          }
          canvas.removeEventListener("pointermove", handlePointermove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: true
        });
        target.addEventListener("pointerupoutside", stopDragging, {
          once: true
        });
      }
    };
    renderingService.hooks.init.tapPromise(DragndropPlugin2.tag, _asyncToGenerator$1(_regeneratorRuntime$1().mark(function _callee2() {
      return _regeneratorRuntime$1().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              canvas.addEventListener("pointerdown", handlePointerdown);
            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
      canvas.removeEventListener("pointerdown", handlePointerdown);
    });
  };
  return DragndropPlugin2;
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin6 = function(_AbstractRendererPlug) {
  _inheritsLoose$1(Plugin7, _AbstractRendererPlug);
  function Plugin7(options) {
    var _this2;
    if (options === void 0) {
      options = {};
    }
    _this2 = _AbstractRendererPlug.call(this) || this;
    _this2.options = void 0;
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  var _proto = Plugin7.prototype;
  _proto.init = function init() {
    this.addRenderingPlugin(new DragndropPlugin(_extends3({
      overlap: "pointer",
      isDocumentDraggable: false,
      isDocumentDroppable: false,
      dragstartDistanceThreshold: 0,
      dragstartTimeThreshold: 0
    }, this.options)));
  };
  _proto.destroy = function destroy() {
    this.removeAllRenderingPlugins();
  };
  _proto.setOptions = function setOptions(options) {
    Object.assign(this.plugins[0].dragndropPluginOptions, options);
  };
  return Plugin7;
}(AbstractRendererPlugin);
function isCanvasElement(el) {
  if (!el || typeof el !== "object")
    return false;
  if (el.nodeType === 1 && el.nodeName) {
    return true;
  }
  return !!el.isCanvasElement;
}
var Canvas2DContextService = function() {
  function Canvas2DContextService2(context) {
    this.$canvas = void 0;
    this.dpr = void 0;
    this.context = void 0;
    this.canvasConfig = void 0;
    this.canvasConfig = context.config;
  }
  var _proto = Canvas2DContextService2.prototype;
  _proto.init = function() {
    var _init = _asyncToGenerator6(_regeneratorRuntime6().mark(function _callee() {
      var _this$canvasConfig, canvas, devicePixelRatio, dpr;
      return _regeneratorRuntime6().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$canvasConfig = this.canvasConfig, canvas = _this$canvasConfig.canvas, devicePixelRatio = _this$canvasConfig.devicePixelRatio;
              this.$canvas = canvas;
              this.context = this.$canvas.getContext("2d");
              dpr = devicePixelRatio || 1;
              dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
              this.dpr = dpr;
              this.resize(this.canvasConfig.width, this.canvasConfig.height);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function init() {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.getContext = function getContext() {
    return this.context;
  };
  _proto.getDomElement = function getDomElement() {
    return this.$canvas;
  };
  _proto.getDPR = function getDPR() {
    return this.dpr;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    if (this.$canvas.getBoundingClientRect) {
      return this.$canvas.getBoundingClientRect();
    }
  };
  _proto.destroy = function destroy() {
    this.context = null;
    this.$canvas = null;
  };
  _proto.resize = function resize(width, height) {
    var devicePixelRatio = this.canvasConfig.devicePixelRatio;
    var pixelRatio = devicePixelRatio;
    var canvasDOM = this.$canvas;
    if (canvasDOM.style) {
      canvasDOM.style.width = width + "px";
      canvasDOM.style.height = height + "px";
    }
    if (isCanvasElement(canvasDOM)) {
      canvasDOM.width = width * pixelRatio;
      canvasDOM.height = height * pixelRatio;
      if (pixelRatio !== 1) {
        this.context.scale(pixelRatio, pixelRatio);
      }
    }
  };
  _proto.applyCursorStyle = function applyCursorStyle(cursor) {
  };
  _proto.toDataURL = function() {
    var _toDataURL = _asyncToGenerator6(_regeneratorRuntime6().mark(function _callee2(options) {
      var type, encoderOptions;
      return _regeneratorRuntime6().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              type = options.type, encoderOptions = options.encoderOptions;
              return _context2.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function toDataURL(_x) {
      return _toDataURL.apply(this, arguments);
    }
    return toDataURL;
  }();
  return Canvas2DContextService2;
}();
var ContextRegisterPlugin = function(_AbstractRendererPlug) {
  _inheritsLoose8(ContextRegisterPlugin2, _AbstractRendererPlug);
  function ContextRegisterPlugin2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
    _this2.name = "mobile-canvas-context-register";
    return _this2;
  }
  var _proto = ContextRegisterPlugin2.prototype;
  _proto.init = function init() {
    this.context.ContextService = Canvas2DContextService;
  };
  _proto.destroy = function destroy() {
    delete this.context.ContextService;
  };
  return ContextRegisterPlugin2;
}(AbstractRendererPlugin);
var Renderer = function(_AbstractRenderer) {
  _inheritsLoose8(Renderer2, _AbstractRenderer);
  function Renderer2(config) {
    var _this2;
    _this2 = _AbstractRenderer.call(this, config) || this;
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new Plugin4());
    _this2.registerPlugin(new Plugin());
    _this2.registerPlugin(new Plugin3());
    _this2.registerPlugin(new Plugin5());
    _this2.registerPlugin(new Plugin2());
    _this2.registerPlugin(new Plugin6({
      isDocumentDraggable: is_nil_default(config === null || config === void 0 ? void 0 : config.isDocumentDraggable) ? true : config.isDocumentDraggable,
      isDocumentDroppable: is_nil_default(config === null || config === void 0 ? void 0 : config.isDocumentDroppable) ? true : config.isDocumentDroppable,
      dragstartDistanceThreshold: is_nil_default(config === null || config === void 0 ? void 0 : config.dragstartDistanceThreshold) ? 10 : config.dragstartDistanceThreshold,
      dragstartTimeThreshold: is_nil_default(config === null || config === void 0 ? void 0 : config.dragstartTimeThreshold) ? 50 : config.dragstartTimeThreshold
    }));
    return _this2;
  }
  return Renderer2;
}(AbstractRenderer);

// node_modules/.pnpm/@antv+g-mobile-canvas-element@0.6.42_@antv+g-lite@1.0.42/node_modules/@antv/g-mobile-canvas-element/dist/index.esm.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var CanvasElement = function() {
  function CanvasElement2(ctx) {
    this.width = void 0;
    this.height = void 0;
    this.isCanvasElement = true;
    this.context = void 0;
    this.emitter = new import_eventemitter34.default();
    this.context = ctx;
    var canvas = ctx.canvas || {};
    this.width = canvas.width || 0;
    this.height = canvas.height || 0;
  }
  var _proto = CanvasElement2.prototype;
  _proto.getContext = function getContext(contextId, contextAttributes) {
    return this.context;
  };
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    var width = this.width;
    var height = this.height;
    return {
      top: 0,
      right: width,
      bottom: height,
      left: 0,
      width,
      height,
      x: 0,
      y: 0
    };
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    this.emitter.on(type, listener);
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    this.emitter.off(type, listener);
  };
  _proto.dispatchEvent = function dispatchEvent(e2) {
    this.emitter.emit(e2.type, e2);
    return true;
  };
  return CanvasElement2;
}();
function supportEventListener(canvas) {
  if (!canvas) {
    return false;
  }
  if (canvas.nodeType !== 1 || !canvas.nodeName || canvas.nodeName.toLowerCase() !== "canvas") {
    return false;
  }
  var support = false;
  try {
    canvas.addEventListener("eventTest", function() {
      support = true;
    });
    canvas.dispatchEvent(new Event("eventTest"));
  } catch (error) {
    support = false;
  }
  return support;
}
function createMobileCanvasElement(ctx) {
  if (!ctx) {
    return null;
  }
  if (supportEventListener(ctx.canvas)) {
    return ctx.canvas;
  }
  return new CanvasElement(ctx);
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/component/updater.js
function createUpdater(canvas) {
  var setStateQueue = [];
  function process() {
    var item;
    var renderComponents = [];
    var renderCallbackQueue = [];
    while (item = setStateQueue.shift()) {
      var state = item.state, component = item.component, callback = item.callback;
      if (component.destroyed) {
        continue;
      }
      if (!component.prevState) {
        component.prevState = Object.assign({}, component.state);
      }
      if (typeof state === "function") {
        Object.assign(component.state, state(component.prevState, component.props));
      } else {
        Object.assign(component.state, state);
      }
      component.prevState = component.state;
      if (typeof callback === "function") {
        renderCallbackQueue.push({
          callback,
          component
        });
      }
      if (renderComponents.indexOf(component) < 0) {
        renderComponents.push(component);
      }
    }
    canvas.updateComponents(renderComponents);
    commitRenderQueue(renderCallbackQueue);
  }
  function enqueueSetState(component, state, callback) {
    if (setStateQueue.length === 0) {
      setTimeout(process, 0);
    }
    setStateQueue.push({
      component,
      state,
      callback
    });
  }
  function commitRenderQueue(callbackQueue) {
    for (var i = 0; i < callbackQueue.length; i++) {
      var _a = callbackQueue[i], callback = _a.callback, component = _a.component;
      callback.call(component);
    }
  }
  var updater = {
    // isMounted: function(publicInstance) {
    //   return false;
    // },
    enqueueForceUpdate: enqueueSetState,
    // enqueueReplaceState: function(publicInstance, completeState) {
    // },
    enqueueSetState
  };
  return updater;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/index.js
var import_eventemitter35 = __toESM(require_eventemitter3());

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/theme.js
var THEME = {
  fontSize: "24px",
  fontFamily: '"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif',
  pixelRatio: 1,
  padding: [0, 0, 0, 0]
};
var theme_default = THEME;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/cssRule.js
var elementStyle = {
  fillStyle: "String",
  font: "String",
  globalAlpha: "Number",
  lineCap: "String",
  lineWidth: ["Number", "String"],
  lineJoin: "String",
  miterLimit: "Number",
  shadowBlur: "Number",
  shadowColor: "String",
  shadowOffsetX: "Number",
  shadowOffsetY: "Number",
  strokeStyle: "String",
  textAlign: "String",
  textBaseline: "String",
  lineDash: ["Array", "Number"],
  shadow: "String",
  matrix: "Array",
  stroke: "String",
  fill: ["String", "Object"],
  opacity: "Number",
  fillOpacity: "Number",
  strokeOpacity: "Number"
};
var DEFAULT_CSS_RULE = {
  group: __assign({}, elementStyle),
  text: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    text: "String",
    width: "Number",
    height: "Number",
    fontSize: ["Number", "String"],
    fontFamily: "String",
    fontStyle: "String",
    fontWeight: ["Number", "String"],
    fontVariant: "String"
  }),
  circle: __assign(__assign({}, elementStyle), {
    cx: "Number",
    cy: "Number",
    r: "Number"
  }),
  path: __assign({}, elementStyle),
  ellipse: __assign(__assign({}, elementStyle), {
    cy: "Number",
    cx: "Number",
    ry: "Number",
    rx: "Number"
  }),
  rect: __assign(__assign({}, elementStyle), {
    width: "Number",
    height: "Number",
    x: "Number",
    y: "Number",
    radius: ["Array", "Number"]
  }),
  image: __assign(__assign({}, elementStyle), {
    width: "Number",
    height: "Number",
    x: "Number",
    y: "Number",
    img: "String",
    src: "String"
  }),
  line: __assign(__assign({}, elementStyle), {
    x1: "Number",
    x2: "Number",
    y1: "Number",
    y2: "Number"
  }),
  polyline: __assign(__assign({}, elementStyle), {
    points: "Array",
    smooth: "Boolean"
  }),
  polygon: __assign(__assign({}, elementStyle), {
    points: "Array"
  }),
  arc: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    r: "Number",
    startAngle: ["Number", "String"],
    endAngle: ["Number", "String"],
    anticlockwise: "Boolean"
  }),
  marker: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    radius: "Number",
    symbol: "String"
  }),
  sector: __assign(__assign({}, elementStyle), {
    x: "Number",
    y: "Number",
    startAngle: ["Number", "String"],
    endAngle: ["Number", "String"],
    r: "Number",
    r0: "Number",
    anticlockwise: "Boolean"
  })
};
function checkCSSRule(type, style) {
  if (!style) {
    return style;
  }
  var cssStyle = {};
  Object.keys(style).forEach(function(key) {
    var value = style[key];
    if (is_nil_default(value)) {
      return;
    }
    var rule = DEFAULT_CSS_RULE[type] && DEFAULT_CSS_RULE[type][key];
    if (!rule) {
      cssStyle[key] = value;
      return;
    }
    var valueType = Object.prototype.toString.call(value);
    if (is_array_default(rule)) {
      for (var i = 0, len5 = rule.length; i < len5; i++) {
        if (valueType === "[object ".concat(rule[i], "]")) {
          cssStyle[key] = value;
          return;
        }
      }
      return;
    }
    if (valueType === "[object ".concat(rule, "]")) {
      cssStyle[key] = value;
    }
  });
  return cssStyle;
}

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/util.js
var ONE_REM;
try {
  ONE_REM = parseInt(document.documentElement.style.fontSize, 10) || 50;
} catch (e2) {
  ONE_REM = 50;
}
var SCALE = ONE_REM / 100;
function defaultPx2hd(px2) {
  if (!px2) {
    return 0;
  }
  return Number((px2 * SCALE).toFixed(1));
}
function parsePadding(padding) {
  if (is_number_default(padding)) {
    return [padding, padding, padding, padding];
  }
  var top = padding[0];
  var right = is_number_default(padding[1]) ? padding[1] : padding[0];
  var bottom = is_number_default(padding[2]) ? padding[2] : top;
  var left = is_number_default(padding[3]) ? padding[3] : right;
  return [top, right, bottom, left];
}
function batch2hd(px2hd2) {
  var batchPx2hd = function batchPx2hd2(value) {
    if (is_string_default(value) && /^-?\d+(\.\d+)?px$/.test(value)) {
      var num = value.substr(0, value.length - 2);
      return px2hd2(Number(num));
    }
    if (is_array_default(value)) {
      return value.map(function(v) {
        return batchPx2hd2(v);
      });
    }
    if (is_plain_object_default(value)) {
      var result = {};
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var rst = batchPx2hd2(value[key]);
          if (!rst) {
            result[key] = rst;
            continue;
          }
          if (key === "padding" || key === "margin") {
            var paddingArray = parsePadding(rst);
            result[key] = paddingArray;
            result["".concat(key, "Top")] = paddingArray[0];
            result["".concat(key, "Right")] = paddingArray[1];
            result["".concat(key, "Bottom")] = paddingArray[2];
            result["".concat(key, "Left")] = paddingArray[3];
            continue;
          }
          result[key] = rst;
        }
      }
      return result;
    }
    return value;
  };
  return batchPx2hd;
}
var px2hd = batch2hd(defaultPx2hd);

// node_modules/.pnpm/@antv+g-web-animations-api@1.0.31_@antv+g-lite@1.0.42/node_modules/@antv/g-web-animations-api/dist/index.esm.js
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose9(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf9(subClass, superClass);
}
function _setPrototypeOf9(o, p) {
  _setPrototypeOf9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf10(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf9(o, p);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var AnimationEvent = function(_FederatedEvent) {
  _inheritsLoose9(AnimationEvent2, _FederatedEvent);
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _this2 = _FederatedEvent.call(this, manager) || this;
    _this2.currentTime = void 0;
    _this2.timelineTime = void 0;
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  return AnimationEvent2;
}(FederatedEvent);
var sequenceNumber = 0;
var Animation = function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    this.effect = void 0;
    this.timeline = void 0;
    this.id = void 0;
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this.oldPlayState = void 0;
    this._holdTime = void 0;
    this.readyPromise = void 0;
    this.finishedPromise = void 0;
    this.resolveReadyPromise = void 0;
    this.rejectReadyPromise = void 0;
    this.resolveFinishedPromise = void 0;
    this.rejectFinishedPromise = void 0;
    this.onfinish = void 0;
    this.oncancel = void 0;
    this.onframe = void 0;
    this._currentTime = 0;
    this._startTime = void 0;
    this._playbackRate = 1;
    this._totalDuration = void 0;
    this._inEffect = void 0;
    this._inTimeline = true;
    this.onremove = void 0;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "" + sequenceNumber++;
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  var _proto = Animation2.prototype;
  _proto.updatePromises = function updatePromises() {
    var oldPlayState = this.oldPlayState;
    var newPlayState = this.pending ? "pending" : this.playState;
    if (this.readyPromise && newPlayState !== oldPlayState) {
      if (newPlayState === "idle") {
        this.rejectReadyPromise();
        this.readyPromise = void 0;
      } else if (oldPlayState === "pending") {
        this.resolveReadyPromise();
      } else if (newPlayState === "pending") {
        this.readyPromise = void 0;
      }
    }
    if (this.finishedPromise && newPlayState !== oldPlayState) {
      if (newPlayState === "idle") {
        this.rejectFinishedPromise();
        this.finishedPromise = void 0;
      } else if (newPlayState === "finished") {
        this.resolveFinishedPromise();
      } else if (oldPlayState === "finished") {
        this.finishedPromise = void 0;
      }
    }
    this.oldPlayState = newPlayState;
    return this.readyPromise || this.finishedPromise;
  };
  _proto.play = function play() {
    this.updatePromises();
    this._paused = false;
    if (this._isFinished || this._idle) {
      this.rewind();
      this._startTime = null;
    }
    this._finishedFlag = false;
    this._idle = false;
    this.ensureAlive();
    this.timeline.applyDirtiedAnimation(this);
    if (this.timeline.animations.indexOf(this) === -1) {
      this.timeline.animations.push(this);
    }
    this.updatePromises();
  };
  _proto.pause = function pause() {
    this.updatePromises();
    if (this.currentTime) {
      this._holdTime = this.currentTime;
    }
    if (!this._isFinished && !this._paused && !this._idle) {
      this.currentTimePending = true;
    } else if (this._idle) {
      this.rewind();
      this._idle = false;
    }
    this._startTime = null;
    this._paused = true;
    this.updatePromises();
  };
  _proto.finish = function finish() {
    this.updatePromises();
    if (this._idle)
      return;
    this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
    this._startTime = this._totalDuration - this.currentTime;
    this.currentTimePending = false;
    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };
  _proto.cancel = function cancel() {
    this.updatePromises();
    if (!this._inEffect)
      return;
    this._inEffect = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._startTime = null;
    this.effect.update(null);
    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };
  _proto.reverse = function reverse() {
    this.updatePromises();
    var oldCurrentTime = this.currentTime;
    this.playbackRate *= -1;
    this.play();
    if (oldCurrentTime !== null) {
      this.currentTime = oldCurrentTime;
    }
    this.updatePromises();
  };
  _proto.updatePlaybackRate = function updatePlaybackRate(playbackRate) {
    this.playbackRate = playbackRate;
  };
  _proto.targetAnimations = function targetAnimations() {
    var _this$effect2;
    var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
    return target.getAnimations();
  };
  _proto.markTarget = function markTarget() {
    var animations = this.targetAnimations();
    if (animations.indexOf(this) === -1) {
      animations.push(this);
    }
  };
  _proto.unmarkTarget = function unmarkTarget() {
    var animations = this.targetAnimations();
    var index = animations.indexOf(this);
    if (index !== -1) {
      animations.splice(index, 1);
    }
  };
  _proto.tick = function tick(timelineTime, isAnimationFrame) {
    if (!this._idle && !this._paused) {
      if (this._startTime === null) {
        if (isAnimationFrame) {
          this.startTime = timelineTime - this._currentTime / this.playbackRate;
        }
      } else if (!this._isFinished) {
        this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
      }
    }
    if (isAnimationFrame) {
      this.currentTimePending = false;
      this.fireEvents(timelineTime);
    }
  };
  _proto.rewind = function rewind() {
    if (this.playbackRate >= 0) {
      this.currentTime = 0;
    } else if (this._totalDuration < Infinity) {
      this.currentTime = this._totalDuration;
    } else {
      throw new Error("Unable to rewind negative playback rate animation with infinite duration");
    }
  };
  _proto.persist = function persist() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.addEventListener = function addEventListener(type, listener, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.dispatchEvent = function dispatchEvent(event) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.commitStyles = function commitStyles() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.ensureAlive = function ensureAlive() {
    if (this.playbackRate < 0 && this.currentTime === 0) {
      var _this$effect3;
      this._inEffect = !!((_this$effect3 = this.effect) === null || _this$effect3 === void 0 ? void 0 : _this$effect3.update(-1));
    } else {
      var _this$effect4;
      this._inEffect = !!((_this$effect4 = this.effect) === null || _this$effect4 === void 0 ? void 0 : _this$effect4.update(this.currentTime));
    }
    if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
      this._inTimeline = true;
      this.timeline.animations.push(this);
    }
  };
  _proto.tickCurrentTime = function tickCurrentTime(newTime, ignoreLimit) {
    if (newTime !== this._currentTime) {
      this._currentTime = newTime;
      if (this._isFinished && !ignoreLimit) {
        this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      }
      this.ensureAlive();
    }
  };
  _proto.fireEvents = function fireEvents(baseTime) {
    var _this2 = this;
    if (this._isFinished) {
      if (!this._finishedFlag) {
        if (this.onfinish) {
          var event = new AnimationEvent(null, this, this.currentTime, baseTime);
          setTimeout(function() {
            if (_this2.onfinish) {
              _this2.onfinish(event);
            }
          });
        }
        this._finishedFlag = true;
      }
    } else {
      if (this.onframe && this.playState === "running") {
        var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
        this.onframe(_event);
      }
      this._finishedFlag = false;
    }
  };
  _createClass2(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get() {
      if (this._idle)
        return "idle";
      if (this._isFinished)
        return "finished";
      if (this._paused)
        return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get() {
      var _this3 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this3.resolveFinishedPromise = function() {
            resolve(_this3);
          };
          _this3.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
  }, {
    key: "currentTime",
    get: function get() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set7(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime))
        return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    },
    set: function set7(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime))
          return;
        if (this._paused || this._idle)
          return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get() {
      return this._playbackRate;
    },
    set: function set7(value) {
      if (value === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }]);
  return Animation2;
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A2 = function A3(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B2 = function B3(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C2 = function C3(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0)
      aB = currentT;
    else
      aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0)
      return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2)
    return function(t) {
      return t;
    };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist4 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist4 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE)
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    else if (initialSlope === 0)
      return guessForT;
    else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  };
  return function(t) {
    if (t === 0 || t === 1)
      return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-" + letter.toLowerCase();
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function Quad2(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic2(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart2(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint2(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo2(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine2(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ2(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back2(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce2(t) {
  var pow2, b = 4;
  while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params = params, _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a = clamp_default(Number(amplitude), 1, 10);
  var p = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1)
    return t;
  return -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
};
var Spring = function Spring2(t, params, duration) {
  if (params === void 0) {
    params = [];
  }
  var _params2 = params, _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1)
    return t;
  return 1 - progress;
};
var Steps = function Steps2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params3 = params, _params3$ = _params3[0], steps = _params3$ === void 0 ? 10 : _params3$, type = _params3[1];
  var trunc = type == "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _params4 = params, mX1 = _params4[0], mY1 = _params4[1], mX2 = _params4[2], mY2 = _params4[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return 1 - ease2(1 - t, params, duration);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function stepEnd(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function linear(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  in: easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear2 = function linear3(x) {
  return x;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count, pos2) {
  return function(x) {
    if (x >= 1) {
      return 1;
    }
    var stepSize = 1 / count;
    x += pos2 * stepSize;
    return x - x % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(" + numberString + "," + numberString + "," + numberString + "," + numberString + "\\)");
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, cubicData.slice(1).map(Number));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both")
        return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both")
        return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d4 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d4 += 1;
    }
    currentDirection = "normal";
    if (d4 !== Infinity && d4 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null)
    return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration);
        target2.style[interpolation.property] = interpolation.interpolation(scaledLocalTime);
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) {
        if (isNotReservedWord(property)) {
          target2.style[property] = null;
        }
      }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f) {
    var interpolated = interpolate(from, to, f);
    return !runtime.enableCSSParsing && is_number_default(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left, right, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata.int) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var usedLeft;
      var usedRight;
      if (runtime.enableCSSParsing) {
        var computedLeft = runtime.styleValueRegistry.parseProperty(property, left, target);
        var computedRight = runtime.styleValueRegistry.parseProperty(property, right, target);
        usedLeft = runtime.styleValueRegistry.computeProperty(property, computedLeft, target);
        usedRight = runtime.styleValueRegistry.computeProperty(property, computedRight, target);
      } else {
        var parser = propertyHandler.parserWithCSSDisabled;
        usedLeft = parser ? parser(left, target) : left;
        usedRight = parser ? parser(right, target) : right;
      }
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, interpolationArgs);
        return function(t) {
          if (t === 0)
            return left;
          if (t === 1)
            return right;
          return interp(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right : left;
  });
}
function interpolate(from, to, f) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f) + to * f;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    if (from.length === to.length) {
      var r = [];
      for (var i = 0; i < from.length; i++) {
        r.push(interpolate(from[i], to[i], f));
      }
      return r;
    }
  }
  throw new Error("Mismatched interpolation arguments " + from + ":" + to);
}
var AnimationEffectTiming = function() {
  function AnimationEffectTiming2() {
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear2;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.playbackRate = void 0;
    this.effect = void 0;
    this.composite = void 0;
    this.activeDuration = void 0;
    this.endTime = void 0;
    this.currentIteration = null;
    this.progress = null;
  }
  _createClass2(AnimationEffectTiming2, [{
    key: "easing",
    get: function get() {
      return this._easing;
    },
    set: function set7(value) {
      this.easingFunction = parseEasingFunction(value);
      this._easing = value;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay
     */
  }]);
  return AnimationEffectTiming2;
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values = effectInput[property];
    if (!Array.isArray(values)) {
      values = [values];
    }
    var numKeyframes = values.length;
    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i] = keyframe;
      }
      if (values[i] !== void 0 && values[i] !== null) {
        normalizedEffectInput[i][property] = values[i];
      }
    }
  }
  normalizedEffectInput.sort(function(a, b) {
    return (a.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing === null || timing === void 0 ? void 0 : timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue))
            throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1)
            throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error(memberValue + " compositing is not supported");
        }
      } else
        ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i = 0; i < keyframes.length; i++) {
    var offset = keyframes[i].offset;
    if (!is_nil_default(offset)) {
      if (offset < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var length14 = keyframes.length;
    keyframes[length14 - 1].computedOffset = Number((_keyframes$offset = keyframes[length14 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length14 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length14; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!is_nil_default(_offset) && !is_nil_default(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++) {
          keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        }
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset)
    spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  var _timingInput;
  timingInput = numericTimingToObject((_timingInput = timingInput) !== null && _timingInput !== void 0 ? _timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = void 0;
    this.animation = void 0;
    this.timing = void 0;
    this.computedTiming = void 0;
    this.normalizedKeyframes = void 0;
    this.timeFraction = void 0;
    this.interpolations = void 0;
    this.target = target;
    this.timing = normalizeTimingInput(timingInput, false);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    this.computedTiming = new Proxy(this.timing, {
      get: function get(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        } else if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        } else if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        } else if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        } else if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set7() {
        return true;
      }
    });
  }
  var _proto = KeyframeEffect2.prototype;
  _proto.applyInterpolations = function applyInterpolations() {
    this.interpolations(this.target, Number(this.timeFraction));
  };
  _proto.update = function update(localTime) {
    if (localTime === null) {
      return false;
    }
    this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
    return this.timeFraction !== null;
  };
  _proto.getKeyframes = function getKeyframes() {
    return this.normalizedKeyframes;
  };
  _proto.setKeyframes = function setKeyframes(keyframes) {
    this.normalizedKeyframes = normalizeKeyframes(keyframes);
  };
  _proto.getComputedTiming = function getComputedTiming() {
    return this.computedTiming;
  };
  _proto.getTiming = function getTiming() {
    return this.timing;
  };
  _proto.updateTiming = function updateTiming(timing) {
    var _this2 = this;
    Object.keys(timing || {}).forEach(function(name) {
      _this2.timing[name] = timing[name];
    });
  };
  return KeyframeEffect2;
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    this.document = void 0;
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.frameId = void 0;
    this.webAnimationsNextTick = function(t) {
      _this2.currentTime = t;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t < Number(_this2.currentTime))
        t = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  var _proto = AnimationTimeline2.prototype;
  _proto.getAnimations = function getAnimations() {
    this.discardAnimations();
    return this.animations.slice();
  };
  _proto.isTicking = function isTicking() {
    return this.inTick;
  };
  _proto.play = function play(target, keyframes, options) {
    var effect = new KeyframeEffect(target, keyframes, options);
    var animation = new Animation(effect, this);
    this.animations.push(animation);
    this.restartWebAnimationsNextTick();
    animation.updatePromises();
    animation.play();
    animation.updatePromises();
    return animation;
  };
  _proto.applyDirtiedAnimation = function applyDirtiedAnimation(animation) {
    var _this2 = this;
    if (this.inTick) {
      return;
    }
    animation.markTarget();
    var animations = animation.targetAnimations();
    animations.sort(compareAnimations);
    var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
    inactiveAnimations.forEach(function(animation2) {
      var index = _this2.animations.indexOf(animation2);
      if (index !== -1) {
        _this2.animations.splice(index, 1);
      }
    });
    this.applyPendingEffects();
  };
  _proto.restart = function restart() {
    if (!this.ticking) {
      this.ticking = true;
      this.requestAnimationFrame(function() {
      });
      this.hasRestartedThisFrame = true;
    }
    return this.hasRestartedThisFrame;
  };
  _proto.destroy = function destroy() {
    this.document.defaultView.cancelAnimationFrame(this.frameId);
  };
  _proto.applyPendingEffects = function applyPendingEffects() {
    this.pendingEffects.forEach(function(effect) {
      effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
    });
    this.pendingEffects = [];
  };
  _proto.updateAnimationsPromises = function updateAnimationsPromises() {
    this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
      return animation.updatePromises();
    });
  };
  _proto.discardAnimations = function discardAnimations() {
    this.updateAnimationsPromises();
    this.animations = this.animations.filter(function(animation) {
      return animation.playState !== "finished" && animation.playState !== "idle";
    });
  };
  _proto.restartWebAnimationsNextTick = function restartWebAnimationsNextTick() {
    if (!this.timelineTicking) {
      this.timelineTicking = true;
      this.requestAnimationFrame(this.webAnimationsNextTick);
    }
  };
  _proto.rAF = function rAF(f) {
    var id2 = this.rafId++;
    if (this.rafCallbacks.length === 0) {
      this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
    }
    this.rafCallbacks.push([id2, f]);
    return id2;
  };
  _proto.requestAnimationFrame = function requestAnimationFrame3(f) {
    var _this3 = this;
    return this.rAF(function(x) {
      _this3.updateAnimationsPromises();
      f(x);
      _this3.updateAnimationsPromises();
    });
  };
  _proto.tick = function tick(t, isAnimationFrame, updatingAnimations) {
    var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
    this.inTick = true;
    this.hasRestartedThisFrame = false;
    this.currentTime = t;
    this.ticking = false;
    var newPendingClears = [];
    var newPendingEffects = [];
    var activeAnimations = [];
    var inactiveAnimations = [];
    updatingAnimations.forEach(function(animation) {
      animation.tick(t, isAnimationFrame);
      if (!animation._inEffect) {
        newPendingClears.push(animation.effect);
        animation.unmarkTarget();
      } else {
        newPendingEffects.push(animation.effect);
        animation.markTarget();
      }
      if (animation._needsTick)
        _this4.ticking = true;
      var alive = animation._inEffect || animation._needsTick;
      animation._inTimeline = alive;
      if (alive) {
        activeAnimations.push(animation);
      } else {
        inactiveAnimations.push(animation);
      }
    });
    (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
    (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
    if (this.ticking)
      this.requestAnimationFrame(function() {
      });
    this.inTick = false;
    return [activeAnimations, inactiveAnimations];
  };
  return AnimationTimeline2;
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/canvas/index.js
function measureText(container, px2hd2, theme) {
  return function(text, font) {
    var _a = font || {}, _b = _a.fontSize, fontSize = _b === void 0 ? theme.fontSize : _b, _c = _a.fontFamily, fontFamily = _c === void 0 ? theme.fontFamily : _c, _d = _a.fontWeight, fontWeight = _d === void 0 ? theme.fontWeight : _d, _e = _a.fontVariant, fontVariant = _e === void 0 ? theme.fontVariant : _e, _f = _a.fontStyle, fontStyle = _f === void 0 ? theme.fontStyle : _f, _g = _a.textAlign, textAlign = _g === void 0 ? theme.textAlign : _g, _h = _a.textBaseline, textBaseline = _h === void 0 ? theme.textBaseline : _h, _j = _a.lineWidth, lineWidth = _j === void 0 ? 1 : _j;
    var style = {
      x: 0,
      y: 0,
      fontSize: px2hd2(fontSize),
      fontFamily,
      fontStyle,
      fontWeight,
      fontVariant,
      text,
      textAlign,
      textBaseline,
      lineWidth,
      visibility: "hidden"
    };
    var result = checkCSSRule("text", style);
    var shape = new Text({
      style: result
    });
    container.appendChild(shape);
    var _k = shape.getBBox(), width = _k.width, height = _k.height;
    shape.remove();
    return {
      width,
      height
    };
  };
}
function computeLayout3(style) {
  var left = style.left, top = style.top, width = style.width, height = style.height, padding = style.padding;
  var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
  return {
    left: left + paddingLeft,
    top: top + paddingTop,
    width: width - paddingLeft - paddingRight,
    height: height - paddingTop - paddingBottom
  };
}
var Canvas2 = (
  /** @class */
  function() {
    function Canvas3(props) {
      var context = props.context, _a = props.renderer, renderer = _a === void 0 ? new Renderer() : _a, width = props.width, height = props.height, customTheme = props.theme, customPx2hd = props.px2hd, customPixelRatio = props.pixelRatio, landscape = props.landscape, rendererContainer = props.container, customStyle = props.style, _b = props.animate, animate = _b === void 0 ? true : _b, createImage = props.createImage, requestAnimationFrame3 = props.requestAnimationFrame, cancelAnimationFrame3 = props.cancelAnimationFrame;
      var px2hd2 = is_function_default(customPx2hd) ? batch2hd(customPx2hd) : px2hd;
      var theme = px2hd2(__assign(__assign({}, theme_default), customTheme));
      var pixelRatio = theme.pixelRatio, fontSize = theme.fontSize, fontFamily = theme.fontFamily, padding = theme.padding;
      var devicePixelRatio = customPixelRatio ? customPixelRatio : pixelRatio;
      var updater = createUpdater(this);
      var canvasElement = createMobileCanvasElement(context);
      var canvas = new Canvas({
        container: rendererContainer,
        canvas: canvasElement,
        devicePixelRatio,
        renderer,
        width,
        height,
        supportsTouchEvents: true,
        supportsPointerEvents: true,
        createImage,
        requestAnimationFrame: requestAnimationFrame3,
        cancelAnimationFrame: cancelAnimationFrame3
      });
      var container = canvas.getRoot();
      var _c = canvas.getConfig(), canvasWidth = _c.width, canvasHeight = _c.height;
      container.setAttribute("fontSize", fontSize);
      container.setAttribute("fontFamily", fontFamily);
      var gesture = new gesture_default(container);
      var componentContext = {
        ctx: context,
        root: this,
        canvas,
        px2hd: px2hd2,
        theme,
        gesture,
        measureText: measureText(container, px2hd2, theme)
      };
      var vNode = {
        key: void 0,
        tag: ClassComponent,
        // style: layout,
        // @ts-ignore
        type: Canvas3,
        props,
        shape: container,
        animate,
        // @ts-ignore
        component: this,
        canvas: this,
        context: componentContext,
        updater
      };
      this._ee = new import_eventemitter35.default();
      this.props = props;
      this.context = componentContext;
      this.updater = updater;
      this.gesture = gesture;
      this.theme = theme;
      this.canvas = canvas;
      this.container = container;
      this.el = canvasElement;
      this.vNode = vNode;
      this.landscape = landscape;
      this.updateLayout(__assign(__assign({}, props), {
        width: canvasWidth,
        height: canvasHeight
      }));
    }
    Canvas3.prototype.updateComponents = function(components) {
      updateComponents(components);
    };
    Canvas3.prototype.update = function(nextProps) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, props, vNode, _b, animate;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a = this, props = _a.props, vNode = _a.vNode;
              if (equal_default(nextProps, props)) {
                return [
                  2
                  /*return*/
                ];
              }
              _b = props.animate, animate = _b === void 0 ? true : _b;
              this.props = nextProps;
              vNode.props = nextProps;
              vNode.animate = animate;
              return [4, this.render()];
            case 1:
              _c.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.render = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a, canvas, vNode;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = this, canvas = _a.canvas, vNode = _a.vNode;
              return [4, canvas.ready];
            case 1:
              _b.sent();
              render(vNode);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.emit = function(type, event) {
      this._ee.emit(type, event);
    };
    Canvas3.prototype.on = function(type, listener) {
      this._ee.on(type, listener);
    };
    Canvas3.prototype.off = function(type, listener) {
      this._ee.off(type, listener);
    };
    Canvas3.prototype.getCanvasEl = function() {
      return this.el;
    };
    Canvas3.prototype.resize = function(width, height) {
      return __awaiter(this, void 0, void 0, function() {
        var canvas;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              canvas = this.canvas;
              canvas.resize(width, height);
              this.updateLayout(__assign(__assign({}, this.props), {
                width,
                height
              }));
              return [4, this.render()];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Canvas3.prototype.updateLayout = function(props) {
      var width = props.width, height = props.height;
      var _a = this.context, px2hd2 = _a.px2hd, theme = _a.theme;
      var style = px2hd2(__assign({
        left: 0,
        top: 0,
        width,
        height,
        padding: theme.padding
      }, props.style));
      var layout = computeLayout3(style);
      var left = layout.left, top = layout.top;
      this.container.setAttribute("x", left);
      this.container.setAttribute("y", top);
      this.context = __assign(__assign({}, this.context), {
        left,
        top,
        width: layout.width,
        height: layout.height
      });
      this.vNode = __assign(__assign({}, this.vNode), {
        style: layout,
        context: this.context
      });
    };
    Canvas3.prototype.toRawChildren = function(children) {
      return children;
    };
    Canvas3.prototype.destroy = function() {
      var _a = this, canvas = _a.canvas, children = _a.children, el = _a.el;
      destroyElement(children);
      el.width = 0;
      el.height = 0;
      this.props = null;
      this.context = null;
      this.updater = null;
      this.theme = null;
      this.canvas = null;
      this.container = null;
      this.el = null;
      this.vNode = null;
      canvas.ready.then(function() {
        canvas.destroy();
      });
    };
    return Canvas3;
  }()
);
var canvas_default = Canvas2;

// node_modules/.pnpm/@antv+f-engine@0.0.35/node_modules/@antv/f-engine/es/timeline.js
var Timeline = (
  /** @class */
  function(_super) {
    __extends(Timeline2, _super);
    function Timeline2(props) {
      var _this2 = _super.call(this, props) || this;
      _this2.next = function() {
        var _a2 = _this2, state = _a2.state, props2 = _a2.props;
        var index = state.index, count2 = state.count, delay2 = state.delay;
        var loop = props2.loop;
        var next = loop ? (index + 1) % count2 : index + 1;
        if (next < count2) {
          setTimeout(function() {
            _this2.setState({
              index: next
            });
          }, delay2 || 0);
        }
      };
      var delay = props.delay, _a = props.start, start = _a === void 0 ? 0 : _a, children = props.children;
      var count = children_default.toArray(children).length;
      _this2.state = {
        delay,
        count,
        index: start
      };
      return _this2;
    }
    Timeline2.prototype.didMount = function() {
      this.animator.on("end", this.next);
    };
    Timeline2.prototype.didUnmount = function() {
      this.animator.off("end", this.next);
    };
    Timeline2.prototype.render = function() {
      var _a = this, state = _a.state, props = _a.props;
      var children = props.children;
      var index = state.index;
      var childrenArray = children_default.toArray(children);
      return childrenArray[index];
    };
    return Timeline2;
  }(component_default)
);

// node_modules/.pnpm/@antv+f-vue@0.0.35_vue@3.2.47/node_modules/@antv/f-vue/es/index.js
var toRawChildren = function toRawChildren2(slots) {
  return children_default.map(slots, function(slot) {
    if (!slot)
      return slot;
    var element = toRaw(slot);
    if (isVNode(element)) {
      var key = element.key, ref = element.ref, type = element.type, props = element.props, children = element.children;
      if (children) {
        props.children = toRawChildren2(children);
      }
      return {
        key,
        ref,
        type,
        props
      };
    }
    if (element.default) {
      var children = element.default();
      return toRawChildren2(children);
    }
    return null;
  });
};
var es_default = {
  props: {
    className: {
      type: String,
      required: false
    },
    pixelRatio: {
      type: Number,
      default: 1,
      required: false
    },
    width: {
      type: [Number, String],
      required: false
    },
    height: {
      type: [Number, String],
      required: false
    },
    padding: {
      type: [Number, String, Array],
      required: false
    },
    animate: {
      type: [Boolean],
      default: true,
      required: false
    },
    px2hd: {
      type: [Function],
      required: false
    }
  },
  methods: {
    getProps: function getProps() {
      var _a = this, $props = _a.$props, $slots = _a.$slots;
      var props = toRaw($props);
      var canvasEl = this.$el;
      var context = canvasEl.getContext("2d");
      return __assign(__assign({}, props), {
        // context 内部创建，不能被覆盖
        context,
        children: toRawChildren($slots)
      });
    }
  },
  mounted: function mounted() {
    return __awaiter(this, void 0, void 0, function() {
      var props, canvas;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            props = this.getProps();
            canvas = new canvas_default(props);
            return [4, canvas.render()];
          case 1:
            _a.sent();
            this.canvas = canvas;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  updated: function updated() {
    return __awaiter(this, void 0, void 0, function() {
      var props, canvas;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            props = this.getProps();
            canvas = this.canvas;
            return [4, canvas.update(props)];
          case 1:
            _a.sent();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  render: function render2() {
    return h("canvas", {
      className: "f-chart ".concat(this.className || ""),
      style: {
        width: "100%",
        height: "100%",
        display: "block",
        padding: 0,
        margin: 0
      }
    });
  },
  beforeUnmount: function beforeUnmount() {
    var canvas = this.canvas;
    canvas.destroy();
  }
};
export {
  es_default as default
};
//# sourceMappingURL=@antv_f-vue.js.map
