# 分时函数
### requestIdleCallback 浏览器空闲时执行
```html
<div class="w_680 d_f jc_sb">
    <div class="d_f fd_c ai_c">
        <button onclick="handleInsert()">插入1万个元素(原始写法)</button>

        <div id="idOld"></div>
    </div>

    <div class="d_f fd_c ai_c">
        <button onclick="handleOptimize()">插入1万个元素(优化后的写法)</button>

        <div id="idOptimize"></div>
    </div>
</div>

<script>
    function handleInsert() {
        console.time();
        let idOld = document.querySelector("#idOld"),
                datas = Array.from({ length: 100000 }, (_, i) => i + 1);

        for (const item of datas) {
            const div = document.createElement("div");

            div.textContent = item;
            idOld.appendChild(div);
        }
        console.timeEnd();
    }


    // 优化方式一(参数归一化)
    function handleOptimize() {
        console.time();
        let datas = Array.from({ length: 100000 }, (_, i) => i + 1),
                idOptimize = document.querySelector("#idOptimize"),
                taskHandler = (item, i) => {
                    const div = document.createElement("div");

                    div.textContent = item;
                    idOptimize.appendChild(div);
                };

        performChunk(datas, taskHandler);
        console.timeEnd();
        // performChunk(100000, taskHandler);
    }

    function performChunk(datas, taskHandler) {
        // 参数归一化
        if (typeof datas === "number") datas = Array.from({ length: datas }, (_, i) => i + 1);
        if (datas.length === 0) return false;

        let i = 0;

        function _run() {
            if (i >= datas.length) return false;

            requestIdleCallback((idle) => {
                while (idle.timeRemaining() > 0 && i < datas.length) {
                    taskHandler(datas[i], i);

                    i++;
                }

                _run();
            });
        }

        _run();
    }


    // 优化方式二(当浏览器不支持requestIdleCallback方法的时候)
    function handleOptimize1() {
        console.time();
        let datas = Array.from({ length: 100000 }, (_, i) => i + 1),
                idOptimize = document.querySelector("#idOptimize"),
                taskHandler = (item, i) => {
                    const div = document.createElement("div");

                    div.textContent = item;
                    idOptimize.appendChild(div);
                },
                scheduler = (task) => {
                    setTimeout(() => {
                        const start = Date.now();
                        task(() => Date.now() - start < 50);
                    }, 100);
                };

        performChunk1(datas, taskHandler, scheduler);
        console.timeEnd();
    }

    function performChunk1(datas, taskHandler, scheduler) {
        if (typeof datas === "number") datas = Array.from({ length: datas }, (_, i) => i + 1);
        if (datas.length === 0) return false;

        let i = 0;

        function _run() {
            if (i >= datas.length) return false;

            scheduler((isGoOn) => {
                while (isGoOn() > 0 && i < datas.length) {
                    taskHandler(datas[i], i);

                    i++;
                }

                _run();
            });
        }

        _run();
    }

    // 优化方式三(判断环境)
    function handleOptimize2() {
        console.time();
        let datas = Array.from({ length: 100000 }, (_, i) => i + 1),
                idOptimize = document.querySelector("#idOptimize"),
                taskHandler = (item, i) => {
                    const div = document.createElement("div");

                    div.textContent = item;
                    idOptimize.appendChild(div);
                };

        browserPerformChunk2(datas, taskHandler);
        console.timeEnd();
    }

    function browserPerformChunk2(datas, taskHandler) {
        const scheduler = (task) => {
            requestIdleCallback((idle) => {
                task(() => idle.timeRemaining() > 0);
            });
        };

        performChunk2(datas, taskHandler, scheduler);

    }

    function performChunk2(datas, taskHandler, scheduler) {
        if (typeof datas === "number") datas = Array.from({ length: datas }, (_, i) => i + 1);
        if (datas.length === 0) return false;

        let i = 0;

        function _run() {
            if (i >= datas.length) return false;

            scheduler((isGoOn) => {
                while (isGoOn() > 0 && i < datas.length) {
                    taskHandler(datas[i], i);

                    i++;
                }

                _run();
            });
        }

        _run();
    }

</script>
```

## 分片

#### (可以通过 DocumentFragment 的使用，减少 DOM 操作次数，降低回流对性能的影响。并且可以通过 requestAniminationFrame 保证插入新节点操作在页面重绘前执行，二者结合可以实现数据渲染优化。)

#### 关于requestAnimationFrame

1. requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。

2. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量。

3. requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销


#### 第一种
```html
<ul id="list-with-big-data">1000个好友</ul>

<script>
  // 全局变量，先扔这儿
  let [ary, ul] = [[], document.querySelector("#list-with-big-data")];
  // 生成好友数据，暂拟1000个
  for (i = 1; i < 1000; i++) {
    ary.push(i);
  }

  // step1.
  console.time();

  function renderList() {
    for (let i = 0; i < ary.length; i++) {
      let li = document.createElement("li");
      li.innerHTML = ary[i];
      ul.appendChild(li);
    }
  }

  renderList();

  console.timeEnd();
```

#### 第二种
```javascript

  console.time();

  function renderData(fn, count) {
    // renderData方法接受两个参数fn和count，fn为创建节点逻辑方法，count参数表示每批创建节点数量。
    // 每次遍历count个数据，传入节点创建函数，同时删除此数据。
    let dataChunk = () => {
      for (i = 0; i < (Math.min(ary.length, count || 0)); i++) {
        let item = ary.shift();
        // 将每条数据作为参数传入节点创建函数中。
        fn(item);
      }
    };
    // 此处计时器设为10毫秒，当然也改为参数传入。
    return () => {
      let timeOut = setInterval(function(params) {
        // dataChunk方法遍历数据时，逐一将数据删除，当数据为空时，结束计时器。
        if (ary.length === 0) {
          return clearInterval(timeOut);
        }
        dataChunk();
      }, 10);
    };
  }

  const renderList1 = renderData((n) => {
    // 再简单不过的创建节点并插入的过程。 默认第二个参数即count为8，表一次渲染8条数据。
    let li = document.createElement("li");
    li.innerHTML = n;
    ul.appendChild(li);
  }, 8);
  renderList1();

  console.timeEnd();
```


#### 第三种
```javascript  
  console.time();
  function renderList2(count = 8) {
    let dataChunk = function() {
      // 创建fragment，fragment详细可移步度娘。 vue双向绑定的实现大多也有用到。
      let fragment = document.createDocumentFragment();
      for (i = 0; i < (Math.min(ary.length, count || 0)); i++) {
        // 与step2大同小异，将节点创建移步此处，并逐条删除数据。
        let li = document.createElement("li");
        li.innerHTML = ary[0];
        // 私以为就是将动态生成的list节点挂载到fragment生成的虚拟dom上，之后再一并插入到ul底下。
        fragment.appendChild(li);
        ary.shift();
      }
      ;
      ul.appendChild(fragment);
      renderData();
    };
    var renderData = () => {
      if (ary.length > 0) {
        // 此处调用requestAnimationFrame方法，将dataChunk作为参数传入，实现递归，反复的一进一出渲染数据。
        window.requestAnimationFrame(dataChunk);
      }
    };
    renderData();
  }

  renderList2();

  console.timeEnd();

```


* setTimeout 延迟加载 （使用不当可能适得其反）
* web worker 多线程 （不能操作dom，主要计算密集型的任务）
* requestIdleCallback 帧空闲时运行 （react18带🔥的，低优先级任务）
* requestAnimationFrame 每帧都会运行 （主要做动画效果调优）
