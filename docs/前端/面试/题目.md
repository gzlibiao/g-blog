### http1.0 和 http2.0  https 对比 
1. http1 文本形式传输 http2 二进制传输数据
2. 连接复用：HTTP/1.0 采用“短连接”，请求和响应都需要单独建立和关闭一条 TCP 连接。而 HTTP/2.0 支持“长连接”，即可复用同一条 TCP 连接发送多个请求和响应。
3. 多路复用：HTTP/1.0 每次只能发送一个请求，请求的顺序与响应的顺序相同。而 HTTP/2.0 支持多路复用，即可以同时发送多个请求，在服务端响应时按照请求的优先级和顺序依次返回。
4. 请求头压缩：HTTP/1.0 的请求头信息没有压缩，可能会导致一些额外的网络开销。而 HTTP/2.0 使用了 HPACK 算法对请求头进行压缩，减少了网络传输的数据量。
5. 服务器推送：HTTP/2.0 支持服务器推送，即在客户端请求的同时，服务端可以主动将一些与请求相关的资源推送到客户端缓存中，加速页面加载速度。而 HTTP/1.0 并不支持服务器推送。
6. HTTPS：HTTPS 是在 HTTP 协议基础上加入了安全层的协议，通过使用 SSL/TLS 加密通信内容，确保数据的安全性和完整性。HTTPS 使用了公钥加密和对称密钥加密等多种技术，使得数据在传输过程中不容易被窃听或篡改。使用 HTTPS 可以保护用户的隐私信息，防止恶意攻击和数据泄露。

### 设计过复杂的功能点
审核规则

### 你觉得你同时懂前后端有什么用？
1. 需求评审阶段可以提前发现问题，避免后续一系列问题
2. 开发阶段中更好的定位问题

### pinia 和 vuex区别
1. pinia更友好支持compositionApi
2. Vuex使用全局单例模式，即在整个应用程序中只有一个Store实例，所有组件共享这个实例。而Pinia则为每个组件实例创建一个自己的Store实例
3. vuex 修改状态我们会调mutations或actions中的函数 Pinia中我们只会调store实例 的属性或方法修改数据

### 实现两个大数相加
```javascript
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //...
}
实现代码如下:

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f!==0){
      sum = '' + f + sum;
   }
   return sum;
}
```

### 跨域
前端配置 代理服务器
后端响应 请求头 cors
nginx配置 反向代理

### cors请求预检



### 前端微应用是一种将前端应用拆分成独立的小型应用，每个应用都可以独立部署、运行和维护的架构模式。以下是前端微应用的优缺点：

优点：

灵活性： 前端微应用可以独立开发、部署和运行，各个微应用之间相互独立，可以根据需要单独更新或扩展某个微应用，提高整体系统的灵活性。

可维护性： 拆分成多个微应用后，每个微应用的代码量和复杂度都会减少，便于团队成员理解和维护，同时也降低了修改一个微应用对其他微应用的影响。

性能优化： 每个微应用可以独立加载和运行，可以根据需求进行性能优化，提升用户体验。

技术栈独立： 每个微应用可以选择适合自己业务场景的技术栈，不同微应用之间可以使用不同的框架或语言，灵活性更高。

缺点：

跨应用通信： 不同微应用之间的通信可能会变得复杂，需要设计合适的通信机制来实现数据共享和交互。

项目搭建成本： 拆分成多个微应用会增加项目的搭建成本，需要设计合适的架构和规范，以及建立统一的脚手架工具来支持微应用的开发和部署。

路由管理： 多个微应用之间的路由管理可能会变得复杂，需要考虑如何统一管理路由和页面跳转，以保证用户体验。

总体来说，前端微应用架构适合大型复杂的前端应用，能够提高系统的灵活性和可维护性，但也需要在设计和实施上花费一定的精力和成本。
