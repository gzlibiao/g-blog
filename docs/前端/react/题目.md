# react 引入css的几种方式
遵循规则 
-- 不能污染其他组件
-- 支持动态css
-- 支持css所有特性
-- 编写起来方便
* 1 变量式声明 const div1={width:'300px'} 内联样式
* 2 组件中 import 引入css文件
* 3 css module.css 文件

# react 中常见的钩子
useState              
useMemo               计算属性
useCallback           计算函数
useContext            获取上下文对象，传值
useRef                通过ref获取实例
useEffect             生命周期钩子结合 初次渲染 更新 销毁
useLayoutEffect       重绘前触发生命周期钩子 阻塞更新，解决界面闪动
useReducer            dispatch修改
useImperativeHandle  设置ref实例上的属性
useHistory            路由前进后退
useLocation           路由参数获取

# 生命周期
1. 初始化
2. 更新
3. 销毁

* 1、getDefaultProps()
设置默认的props，也可以用dufaultProps设置组件的默认属性.

* 2、getInitialState()
在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props

* 3、componentWillMount()
组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。
在渲染前调用,在客户端也在服务端。

* 4、 render()
react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。

* 5、componentDidMount()
组件渲染之后调用，只调用一次。

在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。

如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。


* 6、componentWillReceiveProps(nextProps)

组件初始化时不调用，组件接受新的props时调用。

使用componentWillReceiveProps的时候，不要去向上分发，调用父组件的相关setState方法，否则会成为死循环

在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。

* 7、shouldComponentUpdate(nextProps, nextState)

react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，

如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，

节省大量性能，尤其是在dom结构复杂的时候

返回一个布尔值。在组件接收到新的props或者state时被调用。

在初始化时或者使用forceUpdate时不被调用。

可以在你确认不需要更新组件时使用。

* 8、componentWillUpdata(nextProps, nextState)

组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state

* 9、render()

组件渲染

* 10、componentDidUpdate()

组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。

卸载
* 11、componentWillUnmount()

组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

生命周期	调用次数	能否使用 setSate()
getDefaultProps	1(全局调用一次)	否
getInitialState	1	否
componentWillMount	1	是
render	>=1	否
componentDidMount	1	是
componentWillReceiveProps	>=0	是
shouldComponentUpdate	>=0	否
componentWillUpdate	>=0	否
componentDidUpdate	>=0	是
componentWillUnmount	1	否
